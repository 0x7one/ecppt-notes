# [ECPPT](https://members.elearnsecurity.com/courses/penetration_testing_professional_v5)
__________________________
# Linux Exploitation
# Module 2 - Information Gathering

https://cdn.members.elearnsecurity.com/ptp_v5/section_4/module_2/html/index.html

###### Module Map
1. Remote Enumeration
2. Local Enumeration
__________________________
## 2.1. Remote Enumeration
Remote enumeration is the process of gathering as much information about a target system from an across-the-network perspective using all of the tools we have at our disposal.

Keep in mind that the information gathering and enumeration phases of any penetration test are considered the most important.

It is the result of these phases of the engagement that lead us to identify vulnerabilities, misconfigurations, and ultimately to exploitation.

#### 2.1.1. OS Fingerprinting (Re-cap)
Similar to the information gathering techniques found in previous sections of this course, the steps are very alike and follow a similar methodology of port scanning, service identification, OS fingerprinting, banner grabbing, etc.

There are several 'tells' that can aid us in identifying whether a target system is a Linux-based system or another variant.

As a typical first step in identifying the OS of a target, we can use Nmap's OS Detection as a first pass:
  ```
  nmap -O --osscan-guess <IP_Address>
  ```
  ```
  Nmap scan report for kali.localdomain (192.168.13.26)
  Host is up (0.000069s latency).
  Not shown: 996 closed ports
  PORT      STATE SERVICE
  25/tcp    open  smtp
  111/tcp   open  rpcbind
  587/tcp   open  submission
  2849/tcp  open  nfs
  Device type: general purpose
  Running: Linux 3,X|4.X
  OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4
  OS details: Linux 3.8 - 4.9
  Network Distance: 0 hops

  OS detection performed. Please report any incorrect results at https://nmap.org/submit/
  Nmap done: 1 IP address (1 host_up) scanned in 1.61 seconds
  ```

As seen in the previous slide, we used the `-O` along with the `--osscan-guess` option, which enables Nmap's "aggressive" OS detection mode.

In addition to utilizing Nmap's built-in options to discern the OS, there are few other things we can use from the output to help us in identifying the OS.

For instance, the open ports that are usually returned from a port scan can offer some insight as to the OS.

As an example, we can see that TCP/111 (rpcbind) and TCP/2049 (nfs) were identified.
  ```
  nmap -v -sT -O 192.168.13.26
  ```
  ```
  Nmap scan report for kali.localdomain (192.168.13.26)
  Host is up (0.000069s latency).
  Not shown: 996 closed ports

  PORT      STATE SERVICE
  25/tcp    open  smtp
  111/tcp   open  rpcbind
  587/tcp   open  submission
  2849/tcp  open  nfs
  MAC Address: 00:0C:29:09:35:EE (VMWare)
  Device Type: general purpose
  Running: Linux 3.X|4.X
  OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4
  OS details: Linux 3.2 - 4.8
  ```

These are another indicator that our remote host is a Linux-based host as those ports are rarely found on Windows machines and are indicative of Linux-based services. There are exceptions, however...

**Keep in mind that just because a port scan returns ports or services that are indicative of a particular OS or platform, doesn't mean that they were not put there to throw off an attacker.**

Windows-based honeypots can be used to masquerade as Linux hosts, and vice versa.

So you need to enumerate over and over again.

**Note:**
  As learned from previous sections, the remote enumeration phase often begins with port scans for both TCP and UDP ports against target system(s) including service version fingerprinting `-sV` and can be accomplished with a Nmap command similar to the following:
    ```
    nmap -v -sS -sU -sV -n 192.168.0.1/24
    ```

  One we've identified open services on live target systems, we can begin further enumerating those services for version information, configuration details, and potential exploitability

  In many cases, the type of information certain services can provide an attacker, depending on configuration, can lead to the leaking of sensitive information, configuration details, and in some cases, full compromise of a target host, as we will see shortly.

  In the modules that follow, we will focuses on several commonly discovered services which are considered "Low Hanging Fruit" due to their common occurrence within environments, and their common misconfigurations.

#### 2.1.2. Enumerating NFS
One of these commonly found service is the [Network File System (NFS)](https://en.wikipedia.org/wiki/Network_File_System) this is an [RPC-based](https://en.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call) file sharing protocol often found configured on Unix-like systems, is typically used to provide access to shared resources, and can be found listening on TCP and/or UDP port 2049. Nmap can easily identify a system running NFS.
  ```
  nmap -sT -sU -sV -p2049 <IP_Address>
  ```
  ```
  Nmap scan report for kali.localdomain (192.168.13.26)
  Host is up (0.000069s latency).
  Not shown: 996 closed ports

  PORT      STATE SERVICE VERSION
  2849/tcp  open  nfs     3-4 (RPC #100003)
  2849/udp  open  nfs     3-4 (RPC #100003)

  ```

Please note that since NFS is an RPC-based service and relies on other RPC services, such as `mountd`, it should be directly queried via the Portmapper service which is found on port TCP and/or UDP 111 when using Nmap NSE scripts for instance.

We'll cover the portmapper service shortly.

And administrator wishing to share files from an NFS server will configure what are known as *exports*.
  Exports are the mechanism used by NFS in order to *export* directories, in other words, make entire directories available to other users over the network.

  Exports configured for any given NFS server can usually be found in the `/etc/exports` file on a target host locally.

  For now, we are going to focus on identifying available exports from a remote perspective.

  One common issue with NFS, is that oftentimes administrators will configure exports with little attention to security, and will usually *export* directories in a manner that allows any host or IP address to connect, without any authentication, and if we're lucky, also provide write-access to directories.

Steps:
1. Check services
2. Check if nfs directories
3. Try to mount

Steps:
  Once we've identified that a server is running NFS, the first things we want to do is query it with several Nmap NSE scripts. Specifically, `nfs-ls`, `nfs-showmount`, and `nfs-stafs`
    We can find some NSE scripts we can use for NFS with a simple command:
      ```
      ls /usr/share/nmap/scripts/ | grep nfs
      ```
      ```
      nfs-ls.se
      nfs-showmount.nse
      nfs-statfs.nse
      ```

  We can then use a command similar to the following to obtain results relevant to NFS:
    ```
    nmap --script nfs-ls,nfs-showmount,nfs-statfs <IP_Address>
    ```
    ```
    PORT      STATE SERVICE
    111/tcp   open  rpcbind
    | nfs-ls: Volume /var/www
    |   access: Read Lookup Modify NoExtend NoDelete NoExecute
    | PERMISSION  UID GID SIZE  TIME                 FILENAME
    | rwxr-xr-x   0   0   4096  2017-11-20T14:47:35  .
    | rwxr-xr-x   0   0   4096  2017-11-20T14:47:35  ..
    | rwxr-xr-x   0   0   4096  2017-11-20T14:47:35  html
    |  
    | Volume /home/bob
    |   access: Read Lookup Modify NoExtend NoDelete NoExecute
    | PERMISSION  UID   GID  SIZE  TIME                 FILENAME
    | rwxr-xr-x   1001  1001 4096  2017-12-21T17:59:10  .
    | ?????????   ?     ?    ?     ?                    ..
    | rw-r--r--   1001  1001 220   2017-12-21T18:43:10  .bash_import
    | rw-r--r--   1001  1001 3391  2017-12-21T18:43:10  .bashrc
    | rw-r--r--   1001  1001 3526  2017-12-21T18:43:10  .bashrc.original
    | rw-r--r--   1001  1001 675   2017-12-21T18:43:10  .profile
    | rw-r--r--   0     0    83    2017-12-21T17:59:10  notes.txt
    |_
    | nfs-showmount:
    |   /var/www *
    |   /home/bob *
    ```
  Alternatively, we can use the built-in `showmount` command with the `-e` or `--exports` switches to show any exports that would be available to use as well.

    However, we can see it won't return as much information as the previous Nmap command, as it is designed to simply list any available exports.
      ```
      showmount -e 192.168.13.26
      ```
      ```
      Export list for 192.168.13.26
      /var/www *
      /home/bob
      ```

In the previous 2 examples, we can see that our tool identified 2 exported directories, followed by a "\*" value, which allows mounting the exports from any IP address or host. This configuration is often catastrophic.

  Ideally, an administrator would want to explicitly define (whitelist) IP addresses or hosts that should be allowed to connect to the NFS server, in which case, the output would be something similar to:
  ```
  Export list for 192.168.13.26:
  /var/www admin.foocampus.com 192.168.13.100
  /home/bob 192.168.13.129
  ```

  Even in the case where our access is restricted due to an NFS whitelist configuration like the above, the output still gives us valuable information regarding which IP address or hosts can mount any available exports.

  In this scenario, that information would be useful in the case we can either *spoof* our IP address to match a whitelisted IP address or *take control* of a host which is allowed to connect.

Once we've gathered the relevant NFS server information and have confirmed a misconfiguration, we can attempt to mount the available exported directories; this can be accomplished by first creating a temporary directory as your mount point:
  ```
  mkdir -p /mnt/home/bob
  ```

  Then, the exported NFS directory can be mounted with the following `mount` command:
    ```
    mount -t nfs <NFS Server IP>:/home/bob /mnt/home/bob -o nolock
    ```

  We can confirm that the previous commands were successful by viewing our currently mounted file systems and confirming that our NFS mount exists by just running the `mount` command without any arguments:
    ```
    mount
    ```
    ```
    sunrpc on /run/rpc_pipefs type rpc_pipefs (rw,realtime)
    nfsd on /proc/fs/nfsd tpe nfsd (rw,realtime)
    192.168.13.26:/home/bob on /mnt/home/bob type nfs4 (rw,realtime,vers=4.2,rsize=1048576,wsize=1048576,namelen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.13.26,local_lock=none,addr=192.168.13.26)
    ```

  We can then change into our `/mnt/home/bob` directory and list its contents, and interact with it as if it's another mounted partition on our OS.
    ```
    cd /mnt/home/bob && ls -al
    ```
    ```
    total 28
    drwxr-xr-x 2 bob  bob  4096 Dec 21 12:59 .
    drwxr-xr-x 3 root root 4096 Dec 21 13:12 ..
    -rw-r--r-- 1 bob  bob  220  Dec 20 13:43 .bash_logout
    -rw-r--r-- 1 bob  bob  3391 Dec 20 13:43 .bashrc
    -rw-r--r-- 1 bob  bob  3526 Dec 20 13:43 .bashrc.original
    -rw-r--r-- 1 root root 83   Dec 21 12:59 notes.txt
    -rw-r--r-- 1 bob  bob  675  Dec 20 13:43 .profile
    ```

  Fortunately, for us, `bob` is an administrator and was keeping sensitive information in his home directory in a `notes.txt` file, which was available to all via the poorly configured NFS export.
    ```
    cat /mnt/home/bob/notes.txt
    ```
    ```
    passwords for production:

    prod-db
    proddbusr:Jh728*k62

    prod-web
    wwwuser:i827h%81n
    ```

#### 2.1.3. Enumerating Portmapper (rpcbind)
[Portmapper](https://en.wikipedia.org/wiki/Portmap) (AKA rpcbind) is another common service found on Linux-based systems and is used to essentially "map" RPC ([Open Network Computing Remote Procedure Call](https://en.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call) or "ONC RPC", not to be confused with Microsoft's implementation of RPC) services to their corresponding TCP or UDP ports on a target system.

Information gleaned from the portmap service can offer insight regarding ports that are listening on a machine, but that may not necessarily be accessible over the network.

  As an example, a target system may be running a custom RPC service that is only accessible from the local host or may be running NFS, but only accessible from the local network, etc.

  Knowing this information can give us more insight as to local services that may be running, which could help us further exploiting a system, if and when local access has been obtained.

Portmapper is typically found listening on ports TCP/UDP 111 and in some cases, ports TCP/UDP 32771, and can be enumerated using Nmap NSE scripts, or by using the built-in `rpcinfo` command.

In the next sections, we can see that querying the portmapper service on port TCP/111, gives un an idea of other RPC-based services and ports that a system might have open, either remotely or locally.

You can think of it as a static `port map` for RPC-based ports/services.

Querying a single port (TCP/111), essentially enumerates all related RPC-related service ports without us having to conduct a port scan against all those ports individually.

Furthermore, it gives us knowledge of which ports the system has open locally (bound to localhost), which we couldn't normally identify with an usual port scan.


Nmap's `npsinfo` and `rpc-grind` NSE scripts can be used to enumerate the Portmapper and associated RCP services:
  ```
  nmap --script rpc-grind,rpcinfo 192.168.13.26 -p 111
  ```
  ```
  PORT    STATE   SERVICE
  111/tcp open    rpcbind
  | rpcinfo:
  |   program   version     port/proto  service
  |   100000    2,3,4          111/tcp  rpcbind
  |   100000    2,3,4          111/udp  rpcbind
  |   100003    3             2049/udp  nfs
  |   100003    3,4           2049/tcp  nfs
  |   100005    1,2,3        37697/tcp  mountd
  |   100005    1,2,3        46656/udp  mountd
  |   100021    1,3,4        39047/tcp  nlockmgr
  |   100021    1,3,4        53488/udp  nlockmgr
  |   100027    3             2049/tcp  nfs_acl
  |   100027    3             2049/udp  nfs_acl
  2048/tcp open nfs_acl   
  ```

The stand-alone `rpcinfo` command with the `-p <host>` argument can also give us similar results.
  ```
  rpcinfo -p 192.168.13.26
  ```
  ```

  program   vers     proto   port  service
   100000      4       tcp    111  portmapper
   100000      3       tcp    111  portmapper
   100000      2       tcp    111  portmapper
   100000      4       udp    111  portmapper
   100000      3       udp    111  portmapper
   100000      2       udp    111  portmapper
   100005      1       udp  59939  mountd
   100005      1       tcp  43421  mountd
   100005      2       udp  53604  mountd
   100005      2       tcp  49311  mountd
   100005      3       udp  46656  mountd
   100005      3       tcp  37697  mountd
   100003      3       tcp   2049  nfs
   100003      4       tcp   2049  nfs
   100003      3       tcp   2049  
   100003      3       udp   2049  nfs
   100003      3       udp   2049  
  ```

Later we'll see how we can use a `xinetd` RPC-based UDP service combined with a `netcat` reverse shell, and a *port knocking* method for persistence on a host once we have access.

#### 2.1.4. SMB (Samba)
[Samba](https://en.wikipedia.org/wiki/Samba_(software)), a Linux-based implementation of the [SMB/CIFS](https://en.wikipedia.org/wiki/Server_Message_Block) protocols, provides print and file sharing services for windows clients within an environment.

Recent versions also seamlessly can be integrated with Active Directory domains.

Samba can offer us a great bit of information when enumerated properly.
  Depending on the configuration, we can obtain OS version, user accounts on the system, file shares, their permissions, and potentially sensitive data, and depending on its integration with Active Directory, can be used to enumerate much more information.

  Improperly configured Samba servers can also lead to remote code execution among other things, as we'll see in later sections of this course.

Samba can be found listening on the usual **NetBIOS** ports
  ```
  netbios-ns      137/tcp       # NETBIOS Name Service
  netbios-ns      137/udp   
  netbios-dgm     138/tcp       # NETBIOS Datagram Service
  netbios-dgm     138/udp
  netbios-ssn     139/tcp       # NETBIOS Session Service
  netbios-ssn     139/udp
  microsoft-ds    445/tcp       # Microsoft Naked CIFS
  ```

Samba can be trivially identified with a version scan (`-sV`) against NetBIOS ports.
  ```
  nmap -sT -sU -sV 192.168.13.26 -p135,137,138,139,445 --open
  ```
  ```
  PORT    STATE          SERVICE     VERSION
  139/tcp open           netbios-ssn Samba smbd 3.X - 4.X (workgroup: FOOCAMPUS)
  445/tcp open           netbios-ssn Samba smbd 3.X - 4.X (workgroup: FOOCAMPUS)
  137/udp open           netbios-sn  Samba nmbd netbios-ns (workgroup: FOOCAMPUS)
  138/udp open|filtered  netbios-dgm
  MAC Address: 00:0C:29:09:35:EE (VMware)
  Service Info: Host: SAMBASRV
  ```

Now that we've identifies that Samba is one the target system, we can begin enumerating it for various information, including shares, users, password policies, etc.

  For this, we'll first start with our trusted Nmap NSE scripts, related to enumerating SMB.

  There are several SMB-related NSE scripts we can use, but we'll start with `smb-enum-shares` to get an idea of shares that are available on the target.
    ```
    nmap --script smb-enum-shares 192.168.13.26
    ```
    ```
    smb-enum-shares:
      account_used: guest
      \\192.168.13.26\IPCS:
        Type: 5TYPE_IPC_HIDDEN
        Comment: IPC Service (Samba 4.7.3-Debian)
        Users: 1
        Max Users: <unlimited>
        Path: C:\tmp
        Anonymous access: READ/WRITE
        Current user access: READ/WRITE
      \\192.168.13.26\print$:
        Type: 5TYPE_DISKTREE
        Comment: Printer Drivers
        Users: 0
        Max Users: <unlimited>
        Path: C:\var\lib\samba\printers
        Anonymous access: <none>
        Current user access: <none>
      \\192.168.13.26\www:
        Type: 5TYPE_DISKTREE
        Comment: Web Development Share
        Users: 0
        Max Users: <unlimited>
        Path: C:\var\www\html
        Anonymous access: READ
        Current user access: READ
    ```

    From the output, there are several things we can confirm about the system:
    - Samba version and OS (`IPC Service (Samba 4.7.3-Debian)`)
    - Shares (Others)
    - Anonymous/Guest Access is Allowed (`account_used: guest`, `Anonymous access`)
    - Access Rights for Shares (Others)

  Alternatively, we can also use `smbclient` with the `-L` switch and IP address to obtain similar information about shares as well, including WORKGROUP and NetBIOS name.

    Simply hitting `<Enter>` at the authentication prompt and obtaining the results, also confirms that anonymous or guest access to the samba server is enabled:
      ```
      smbclient -L 192.168.13.26
      ```
      ```
      Enter WORKGROUP\root's password:

          Sharename     Type      Comment
          ---------     ----      -------
          www           Disk      Web Development Share
          print$        Disk      Printer Drivers
          IPC$          IPC       IPC service (Samba 4.7.3-Debian)
      Reconnecting with SMB1 for workgroup listing.

          Server        Comment       Workgroup     Master
          --------      -------       ---------     ------
                                      FOOCAMPUS     SAMBASRV
      ```

    In addition to simply listing shares which we have access to, we also want to know what type of access we have to which shares, i.e. `READ ONLY`, `WRITE`, etc.
      We can use [smbmap](https://github.com/ShawnDEvans/smbmap) for this purpose.
      ```
      smbmap -H 192.168.13.23
      ```
      ```
      [+] Finding open SMB ports...
      [+] Guest SMB session established on 192.168.13.26...
      [+] IP: 192.168.13.26:445     Name: server2.localdomain
              Disk                                  Permissions
              ----                                  -----------
              www                                   READ ONLY
              print$                                NO ACCESS
              IPC$                                  NO ACCESS
      ```

      From the output above, we can see we have `READ ONLY` access to the `www` share.
      Although we won't be able to write, upload, or edit files in that directory, we can still benefit from `READ ONLY` access regarding credential from files, etc.

    There are many other options available to us with `smbmap`, including interacting with the remote file system, searching file contents for specific strings, and even executing commands.

    The full capability of *smbmap* is left as an exercise for the student.

  Once we've identified shares (in this case, we've identified *www* as being an interesting share we can access), we have several options for interacting with them. Once, again, *smbclient* can be used, but his time, we'll specify a host with the command, as follows:
    ```
    smbclient \\\\192.168.13.26\\www
    ```
    ```
    Enter WORKGROUP\root's password:
    Try "help" to get a list of possible commands.
    smb: \>
    ```

    You can then *<Enter>* past the password prompt because we've already confirmed the share allows guest or anonymous access. If all goes well, you should then be presented with an *smb: \>* shell prompt.

    Typing `help` at the `smb: \>` prompt once you've connected to the share, offers us some helpful options.

    The 2 most used (for our purposes) of course, are the `get` and `put` commands, which we'll see later.

  Another method we can use to mount SMB shares is by using `mount`.
    This is similar to how we did with the NFS shares, but will require the `cifs-utils` package in this case.
    `cifs-utils` can be installed by issuing an `apt install cifs-util` command from your shell.
    Once the `cifs-utils` are installed, we can use commands like the following to mount the Samba share:
      ```
      mkdir /mnt/www

      mount -t cifs \\\\192.168.13.26\\www /mnt/www
      ```

    Then simply browse your mount directory, to access it.
      ```
      cd /mnt/www && ls -als
      ```
      ```
      total 2052
         0 drwxr-xr-x 2 root root     0 Nov 20 09:47 .
         4 drwxr-xr-x 2 root root  4096 Jan  7 23:01 ..
      1024 -rwxr-xr-x 1 root root 10701 Nov  9 08:39 index.html
      1024 -rwxr-xr-x 1 root root   612 Nov  9 08:38 index.nginx-debian.html
      ```

Now that we've enumerated shares, a next step is to enumerate users over the SMB protocol.
  Enumerating users when it comes to Samba or over SMB can be accomplished in several ways.

  The first way we'll go over is a manual method using `rpcclient`, and we'll also briefly cover a great tool that can automate the information gathering process for Samba or any other SMB-based service, whether it's on Linux or Windows.

  Methods:
  1. Bash `for loop` and `rpcclient` <br>
    Using `rpcclient` and a list of potential usernames we've gathered from other phases of information gathering, we can concoct a simple one-liner `for loop` in bash with `rpcclient` to enumerate the Samba server for users.

    For instance, we know that *root* is likely a user considering the OS; so that name will go in our `users.txt` file.

    We also know that *bob* is a user since we saw his home directory during NFS enumeration, so we'll include his name in the list as well, and so on.

    You may also want to check out the [statistically-likely-usernames](https://github.com/insidetrust/statistically-likely-usernames) Github to help create a user list consisting of probable usernames.

    Once we've generated our list of potential usernames, we can feed that to `rpcclient` with the `lookupnames` option in the form of a bash `for loop`
      ```
      $ cat users.txt
      bob
      www
      admin
      root
      sara
      jamie
      alice
      todd
      ```
      ```
      for u in $(cat users.txt);
              do rpcclient -U "" 192.168.13.26 -N --command="lookupnames $u"
      done |grep "User: 1"
      ```
      Description:
      - `-U` : for anonymous/guest logon (blank value)
      - `lookupnames` : is an rpcclient command
      - `-N` : specifies to use no password, since we can log in as guest


    After executing the aboce bash code, you should receive output similar to the following:
      ```
      bob S-1-22-1-1001 (User: 1)
      root S-1-22-1-0 (User: 1)
      todd S-1-22-1-1002 (User: 1)
      ```

      The `User: 1` in the output indicates that the user exists on the remote system.
      In this case, `bob`, `root`, and `todd` were found to be valid users.

    The above automated method can also be accomplished manually using `rpcclient` with the `lookupnames` command:
      ```
      root@tester:~# rpcclient -U "" 192.168.13.26 -N
      rpcclient $> lookupnames root
      root S-1-22-1-0 (User: 1)
      rpcclient $> lookupnames bob
      bob S-1-22-1-1001 (User: 1)
      rpcclient $> lookupnames todd
      todd S-1-22-1-1002 (User: 1)
      rpcclient $> lookupnames www
      result was NT_STATUS_NONE_MAPPED
      rpcclient $>
      ```

    There are several options available with `rpcclient`, some other useful commands include:
    - `lookupsids`
    - `netshareenum`
    - `srvinfo`
    - `enumprivs`

  2. Automated (enum4linux)<br>
    A great tool we can use to enumerate SMB server automatically is [enum4linux](https://github.com/portcullislabs/enum4linux) by Portcullis Labs.

    It can be used to enumerate the following:
    - OS
    - Users
    - Password policies
    - Group membership
    - Shares
    - Domain/Workgroup identification

    Example `enum4linux` output against a Samba server:
      ```
      enum4linux 192.168.13.26
      ```
      ```
       ============================================
      |    Nbstat Information for 192.168.13.26    |
       ============================================
      Looking up status of 192.168.13.26
              SAMBASRV        <00> -          B <ACTIVE>  Workstation Service
              SAMBASRV        <03> -          B <ACTIVE>  Messenger Service
              SAMBASRV        <20> -          B <ACTIVE>  File Server Service
              ..__MSBROWSE__. <01> - <GROUP>  B <ACTIVE>  Master Browser
              FODCAMPUS       <08> - <GROUP>  B <ACTIVE>  Domain/Workgroup Name
              FODCAMPUS       <1d> -          B <ACTIVE>  Master Browser
              FODCAMPUS       <1e> - <GROUP>  B <ACTIVE>  Browser Service Elections

              MAC Address = 00-00-00-00-00-00

      [+] Password Info for Domain: SAMBASRV

                [+] Minimum password length: 5
                [+] Password history length: None
                [+] Maximum password age: 37 days 6 hours 21 minutes
                [+] Password Complexity Flags: 000000
      ```

#### 2.1.5. Enumerating SMTP Users
This section covers user enumeration through SMTP servers using enabled [verbs](https://cr.yp.to/smtp/vrfy.html) (or options) that are enabled on a mail server.

You're probably familiar with the *HELO*, *RCPT*, or *MAIL* verbs if you've ever sent an email while directly connected to an email server via telnet or some other way; (telnet mail.server.site 25) for instance.

The following information does apply for both Windows and Linux-based mail servers since SMTP is the underlying protocol, but since large majority of mail servers in-use are Linux-based, we'll be focusing on enumerating users from [Sendmail](https://www.proofpoint.com/us/open-source-email-solution), a popular Open-Source \*NIX-based mail server.

In the wild, you will mostly encounter Sendmail, Postfix, Exim, or Microsoft Exchange. The following techniques can apply to all.

Similar to the user enumeration process for SMB users, as discussed previously, there are several ways to accomplish this task either using manual methods or using tools designed for the purpose of enumerating users from a mail server.
  We will cover several verbs/methods we can use to enumerate users from SMTP in the upcoming sections.

Steps:
  The first task is to enumerate which options, *verbs* or *features* are enabled on an SMTP server, usually found on *TCP/25*.
    This can be accomplished with the *smtp-commands* Nmap NSE scripts:
      ```
      nmap --scripts smtp-commands 192.168.13.26 -p 25
      ```
      ```
      PORT    STATE   SERVICE
      25/tcp  open    smtp
      | smtp-commands: server2.localdomain Hello tester.local domain [192.168.13.14], please to meet you, ENHANCEDSTATUSCODES, PIPELINING, EXPN, VERB, 8BITMIME, SIZE, DSN, ETRN, AUTH DIGEST-MD5 CRAM-MD5, DELIVERBY, HELP
      |_ 2.0.0 this is sendmail version 8.15.2 2.0.0 Topics: 2.0.0 HELO EHLO MAIL RCPT DATA 2.0.0 RSET NOOP QUIT HELP VRFY 2.0.0 EXPN VERB ETRN DSN AUTH 2.0.0 STARTTLS 2.0.0 For more info use "HELP <topic>". 2.0.0 To report bugs in the implementation see 2.0.0 http://www.sendmail.org/email-addresses.html 2.0.0 For local information send email to Postmaster at your site. 2.0.0 End of HELP info.
      ```

    We can also achieve the same results with a direct connection to port 25 using `telnet` or `netcat` by simply issuing a `help` command, followed by `<Enter>` command once connected:
      ```
      telnet 192.168.13.26 25
      ```
        OR
      ```
      nc 192.168.13.26 25
      ```
      Result
      ```
      220 server2.localdomain ESMTP Sendmail 8.15.2/8.15.2/Debian-9;
      Mon, 8 Jan 2018 15:18:11 -0500; (No UCE/UBE) logging access from:
      tester.localdomain(OK)-tester.localdomain [192.168.13.14]
      help
      214-2.0.0 This is sendmail version 8.15.2
      214-2.0.0 Topics:
      214-2.0.0       HELO    EHLO    MAIL    RCPT    DATA
      214-2.0.0       RSET    NOOP    QUIT    HELP    VRFY
      214-2.0.0       EXPN    VERB    ETRN    DSN     AUTH
      214-2.0.0       STARTTLS
      214-2.0.0 For more info use "HELP <topic>"
      214-2.0.0 To report bugs in the implementation see
      214-2.0.0       http://www.sendmail.org/email-addresses.html
      214-2.0.0 For local information send email to Postmaster at your site.
      214-2.0.0 End of HELP info
      ```

    From the above outputs, we can see which features or *verbs* are enabled on the mail server.

    For our purposes, we are interested in the [RCPT](https://cr.yp.to/smtp/mail.html), [VRFY and EXPN verbs](https://cr.yp.to/smtp/vrfy.html). (All of which can be used to enumerate users on the server)

  Using `RCPT TO` (who we are sending the mail to, in this case, the user we are enumerating), we can enumerate users via direct connection to the mail server with either *telnet* or *netcat*.
    We are going to use *telnet*. The series of commands required is pretty straightforward:
    1. Connect using `telnet`
      ```
      telnet 192.168.13.26 25
      ```
    2. We issue the *HELO* verb with *tester.localdomain* for a domain name:
      ```
      220 server2.localdomain ESMTP Sendmail 8.15.2/8.15.2/Debian-9;
      Mon, 8 Jan 2018 15:18:11 -0500; (No UCE/UBE) logging access from:
      tester.localdomain(OK)-tester.localdomain [192.168.13.14]
      HELO tester.localdomain
      250 server2.localdomain Hello tester.localdomain [192.168.13.14], pleased to meet you
      ```
    3. We then tell who the mail will be from with the `MAIL FROM:` Verb:
      ```
      MAIL FROM: tester@tester.localdomain
      250 2.1.0 tester@tester.localdomain... Sender ok
      ```
    4. We can then proceed with sequentially enumerating potential users from the system with the `RCPT TO: <user@domain.com>` command:
      ```
      RCPT TO: root@server2.localdomain
      250 2.1.5 root@server2.localdomain... Recipient ok
      RCPT TO: nouser@server2.localdomain
      250 5.1.1 root@server2.localdomain... User unknown
      RCPT TO: sara@server2.localdomain
      250 2.1.5 root@server2.localdomain... Recipient ok
      ```
      Valid users will return a Status Code of `250 2.1.5` while a `550 5.1.1` Status Code and `User unknown` message denotes a non-existent user.

  Another feature we can use to enumerate users is the `EXPN` feature.
    `EXPN` was designed to be used to query a mail server for a list of members within a mailing list on a server.
    The typical command would be `EXPN mailing-list-name`, which would return a list of all users belonging to the list.

    It can also be used to query for a user by simply supplying a username as part of the command:
      ```
      250 server2.localdomain Hello tester.localdomain [192.168.13.14], pleased to meet you
      EXPN sara
      250 2.1.5 <sara@server2.localdomain>
      EXPN nosuchuser
      550 5.1.1 nosuchuser... User unknown
      EXPN bob
      250 2.1.5 <bob@server2.localdomain>
      ```

    Valid users will return a Status Code of `250 2.1.5` while a `550 5.1.1` Status Code and `User unknown` message denotes a non-existent user.

  Lastly, `VRFY` request can also be used and is more common than the `EXPN` method.
    The same command line can be used with `VRFY`, and the results are similar to the `EXPN` output
      ```
      250 server2.localdomain Hello tester.localdomain [192.168.13.14], pleased to meet you
      VRFY sara
      250 2.1.5 <sara@server2.localdomain>
      VRFY nosuchuser
      550 5.1.1 nosuchuser... User unknown
      VRFY bob
      250 2.1.5 <bob@server2.localdomain>
      ```
    Valid users will return a Status Code of `250 2.1.5` while a `550 5.1.1` Status Code and `User unknown` message denotes a non-existent user.

[smtp-user-enum]() by pentestmonkey is a great tool that automates the user enumeration process for SMTP.
  The previous section should give you a better understanding of how this tool works and what it's doing under the good because after all understanding exactly what our tools are doing, is an important part of who we are as penetration testers.

  smtp-user-enum tests all three methods, `RCPT`, `EXPN`, and `VRFY` that we've discussed, against a list of users. An example of the commands listed in its help:
    ```
    $ smtp-user-enum -M VRFY -U users.txt -t 10.0.0.1
    $ smtp-user-enum -M EXPN -u admin1 -t 10.0.0.1
    $ smtp-user-enum -M RCPT -U users.txt -T mail-server-ips.txt
    $ smtp-user-enum -M EXPN -D example.com -U users.txt -t 10.0.0.1
    ```

  Here is some sample output from running it against a Sendmail server:
    ```
    root@tester:~# smtp-user-enum -M VRFY -U users.txt -t 192.168.13.26
    Starting smtp-user-enum v1.2 (http://pentestmonkey.net/tools/smtp-user-enum)

     --------------------------------------
    |           Scan Information           |
     --------------------------------------

    Mode ....................... VRFY
    Worker Processes ........... 5
    Usernames file ............. users.txt
    Target count ............... 1
    Username count ............. 8
    Target TCP count ........... 25
    Query timeout .............. 5 secs
    Target domain ..............

    ######## Scan started at Mon Jan 8 17:57:51 2018 ########
    192.168.13.26: www exists
    192.168.13.26: sara exists
    192.168.13.26: root exists
    192.168.13.26: bob exists
    192.168.13.26: todd exists
    ######## Scan completed at Mon Jan 8 17:57:53 2018 ########
    5 results

    8 queries in 2 seconds (4.0 queries / sec)
    ```

## 2.2 Local Enumeration
Now that we've covered some methodology in regards to information gathering from a remote perspective, it's time to step into what we do once we've obtained access to a Linux machine.

This section is a precursor to the *Post Exploitation* module of this course in the sense that we've gotten some type of access to a machine:
- Either as a low-privileged or high-privileged user
- Via a shell
- Through a web application or some other means,
  with the ultimate goal of obtaining higher-level access to our current machine, and furthermore, access to other machines within an environment as a result of information obtained from our exploited host

During this process, we're gathering information from our exploited machine(s), and using the information gathered to give us the situational awareness that is needed to better understand and further exploit the environment we are in.

Often, when this phase is complete, due to the depth of information that can be obtained, we sometimes find ourselves understanding the systems and surrounding infrastructure better than the administrator and engineers that built them in the first place.

The type of information we gather during this phase falls into 2 higher level categories:
- Network information
- System information

Both involve different sets of tools and methods, but the good news is, for the most part, once we have access to a Linux host, most of those tools are already provided for us.

This methodology that follows will be useful in the post-exploitation section we'll cover in later modules.

#### 2.2.1. Network Information
For network information, we can ask ourselves some important questions:
- How is the exploited machine connected to the network?
- Is the machine multi-homed? Can we pivot to other hosts in other segments?
- Do we have unfettered outbound conectivity to the internet or is egreess (outbound) traffic limited to certain ports or protocols?
- Is there a firewall between me and other devices/machines?
- Is the machine I am on, communicating with other hosts?
  If so, what is the purpose of the hosts that my current machine is communicating with?
- What protocols are being used that are originating from my actively exploited machine? Are we initiating FTP connections or other connections (SSH, etc) to other machines?
- Are other machines initiating a connection with me? If so, can that traffic be intercepted or sniffed as cleartext in transit? Is it encrypted?

  All of those questions can be answered with some standard utilities we can find on our compromised Linux host, in addition to some simple bash scripting.

  The section that follow are essentially a cheat sheet for commands we can execute once we've gotten access to a machine or network/

  Remember to keep a log of all of the information gathered, since we will need to revisit all of our collected data for the post-exploitation phase.

###### 2.2.1.1. ifconfig
`ifconfig` is used to get information regarding our current network interfaces.
We want to know what our IP addresses is, and whether or not there are additional interfaces that we may be able to use as pivots to other network segments.

For a full listing of interfaces, use the `-a` switch
  ```
  ifconfig -a
  ```

###### 2.2.1.2. route
`route` is used to print our current network routes, which includes our gateway (of course).

Knowing what our static routes and gateway are can help us in case we need to manually configure our network interfaces, pivot to other network segments, or will come in handy if we decide to execute ARP-poisoning or other MitM style attacks.

Simply executing `route -n` from a shell will list current network route information.
  ```
  route -n
  ```
  ```
  Kernel IP routing table
  Destination     Gateway          Genmask        Flags Metric Ref  User  Iface
  0.0.0.0         192.168.13.250   0.0.0.0        UG    100    0       0  eth0
  192.168.13.0    0.0.0.0          255.255.255.0  UG    100    0       0  eth0

  ```

###### 2.2.1.3. traceroute
Sometimes we'll want to know how many hops are between our compromised machine, an other network segments. We can use traceroute for this.
  ```
  traceroute -n <IP_Address>
  ```

###### 2.2.1.4. DNS Information
Important question to answer:
- What machine is resolving our DNS queries?
- Can we use it to exfiltrate data over a DNS tunnel?
- Is the DNS server vulnerable to any exploits?
- Is it an Active Directory controller?

DNS server information is typically stored in the `resolv.conf` in the `/etc` directory
  ```
  $cat /etc/resolv.conf
  # Generated by Network Manager
  search localdomain
  nameserver 8.8.8.8
  ```

###### 2.2.1.5. ARP Cache
The systems' ARP cache can be used to give us a bit of situational awareness regarding machines near us, or machines that our currently exploited system communicates with for one reason or another.

This information is useful when it comes down to determining who we are communicating with, what's being communicated, and whether that traffic or communication has any value to us from an exploitation perspective. i.e. transmitted in cleartext, etc.
  ```
  arp -en
  ```
  ```
  Address         HWtype     HWaddress              Flags Mask  Iface
  192.168.13.250  ether      00:00:00:00:20:da      C           eth0
  192.168.13.26   ether      00:0c:29:09:35:ee      C           eth0
  ```

###### 2.2.1.6. netstat
`netstat` gives us insight regarding:
- What other machines or devices we are currently connected to
- Which ports or services on other machines we are connected to
- What ports our current machine are listening on
- Are there other systems establishing connections with our current machine

We can list all TCP and UDP connection to other systems and listening services with:
   ```
   netstat -auntp
   ```
   ```
   Active Internet connections (servers and established)
   Proto Recv-Q Send-Q Local Address   Foreign Address  State     PID/Program name
   tcp        0      0 0.0.0.0:25      0.0.0.0:*        LISTEN    1768/sendmail: MTA:
   tcp        0      0 0.0.0.0:587     0.0.0.0:*        LISTEN    1768/sendmail: MTA:
   tcp        0      0 127.0.0.0:125   0.0.0.0:*        TIME_WAIT -
   udp        0      0 0.0.0.0:40804   127.0.0.1:59364  LISTEN    1630/snmpd
   udp        0      0 0.0.0.0:68      0.0.0.0:*        LISTEN    570/dhclient
   udp        0      0 127.0.0.1:161   0.0.0.0:*        LISTEN    1630/snmpd
   ```

In the rare case that you're on a very restricted system, and the `netstat` command is missing, Etienne Stalmans did some [great research](https://staaldraad.github.io/2017/12/20/netstat-without-netstat/) regarding parsing similar information from the `/proc/net/tcp` and `/proc/net/tcp` files.

  We encourage you to explore the work done there for a better understanding of how netstat obtains its information.

###### 2.2.1.7. ss
An alternative to netstat that we can use to list active network connections is the `ss` command

`ss-twurp` comes in handy for another perspective on established connections, bytes being transferred, and the process/users responsible for the connections.


###### 2.2.1.8. Outbound Port Connectivity
Another thing we want to check is whether or not our outbound port connectivity is restricted in any way.

Knowing this information will come in handy if and when we need to establish outbound connections to other systems we control for the purpose of maintaining access or exfiltrating data.

A quick way we can check outbound port connectivity status is with `portquiz,net`
  `portquiz.net` is a web server which has most (if not all) TCP ports listening. We can use it to confirm we can connect to arbitrary ports outside our network with a quick nmap scan:
    ```
    nmap -sT -p4444-4450 portquiz.net
    ```
    ```
    PORT      STATE   SERVICE
    4444/tcp  open    krb524
    4445/tcp  open    upnotifyp
    4446/tcp  open    n1-fwp
    4447/tcp  open    n1-rmgmt
    4448/tcp  open    asc-slmd
    4449/tcp  open    privatewire
    4450/tcp  open    camp
    ```
  We can see that ports 4444-4450/TCP are allowed outbound from our current machine.
  Keep in mind that any scans originating from your compromised machine can alert network administrators of anomalous activity. Consider using nmap's `--T` (timing) option at a low value to stay under any internal IDS radar.


Here is a summary of some of the commands we can use to obtain information regarding our network state:

|  Command                       | Function                             |
|--------------------------------|--------------------------------------|
| `cat /etc/resolv.conf`         | DNS Server                           |
| `ifconfig -a`                  | List Current Network Interface Config |
| `route`                        | Current Network Route Information
| `traceroute -n <IP_Address>`   | Trace our route across network segments |
| `arp -a`                       | List our ARP Cache
| `netstat -auntp`               | Established and Listening TCP/UDP Ports/Connections |
| `ss -twurp`                    | Listing active connections, processes, users, and bytes |
| `nmap -sT -p5555 portquiz.net` | Check outbound firewall rules       |



#### 2.2. System Information
The System Information gathering phase is much like the Network Information phase, except we're getting much more data.

Our goal with this phase is to get information regarding:
- OS and Kernel
- Environment Variables
- Interesting Files and Sensitive Information
- Users, Groups, Permissions, and Privileges
- Services and Associated Configuration files
- Cron jobs, System Tasks
- Installed Applications and Versions
- Running Processes

Our ultimate objective from this portion of the testing is to elevate our privileges once we've obtained access to a system or systems, and obtain additional footholds within an environment as a result of the information we obtain.


Rather than go into many specifics in this section on every command we can use to gather critical information about the system (as we'll see there are many to explore), we'll provide them here in a list summary.

  Many of these commands will also be covered more in-depth in other modules, specifically, in Post-Exploitation.

Additionally, there are several great tools and other resources we can use to automate the process of information gathering once we're on a target machine.

#### 2.2.3. System Information Commands Summary

|  Command                       | Function                             |
|--------------------------------|--------------------------------------|
|`id`        | Current User Information                  |
|`uname -a`  | Kernel Version                            |
|`grep $USER`| Current User Information from /etc/passwd |
|`lastlog`   | Most Recent Logins                        |
|`w`         | Who is currently logged onto the system   |
|`last`      | Last logged-on users                      |
|
```
for user in $(cat /etc/passwd | cut -f1 -d":"); do id $user; done
```
| All Users including UID and GID information|
|
```
cat /etc/passwd |cut -f1,3,4 -d":" |grep "0:0" |cut -f1 -d":" |awk '{print $1}'
```
| List all UID 0 (root) accounts|
|`cat /etc/passwd`         | Read passwd File |
|`cat /etc/shadow`         | Check readability of the shadow file   |
|`sudo -l`                 | What can we sudo without a password?   |
|`cat /etc/sudoers`        | Can we read the `etc/sudoers` file     |
|`cat /root/.bash_history` | Can we read root `.bash_history` file? |
|
```
find /home/* -name *.*history* -print 2> /dev/null
```
| Can we read any other users' `.bash_history` files? |
|
`cat /etc/issue`
`cat /etc/*-release`| Operating System |
|
`sudo -l |grep vim`
`sudo -l |grep nmap`
`sudo -l |grep vi`
| Can we sudo known binaries that allow breaking out into a shell? |
|`ls -als /root/`   | Can we list root's home directory?           |
|`echo $PATH`       | Current `$PATH` environment variable         |
|
`cat /etc/crontab && ls -als`
`/etc/cron*`
| List all cron jobs |
|
```
find /etc/cron* -type f -perm -o+w -exec ls -l {} \;
```
| Find world-writeable corn jobs |
|`pas auxwww` | List running processes |
|`ps -u root` | List all processes running as root |
|`ps -u $USER`| List all processes running as current user |
|
```
find / -perm -4000 -type f 2>/dev/null
```
| Find SUID files |
|
```
find / -uid 0 -perm -4000 -type f 2>/dev/null
```
| Find SUID files owned by root |
|
```
find / -perm -4000 -type f 2>/dev/null
```
| Find GUID files |
|
```
find -perm -2 -type f 2>/dev/null
```
| Find world-writeable files |
|`ls -al /etc/*.conf`     | List all conf files in `/etc/`                  |
|`grep pass* /etc/*.conf` | Find conf files that contain the string `pass*` |
|`lsof -n`                | List all open files                             |
|`dpkg -l`                | List Installed packages (Debian)                |
|
`sudo -V`
`httpd -v`
`apache2 -v`
`mysql -V`
`sendmail -d0.1`
| Common software versions |
|
```
ps aux | awk '{print $11}' |xargs -r ls -la 2>/dev/null |awk '!x[$0]++'
```
| Print process binaries/paths and permissions |


#### 2.2.4. Information Gathering Tools and Resources
By no means are the previous slides a complete list of all commands that we can use for gathering local system information.

There are hundreds of ways to gather the same information, and we should also use our imagination as to what we should be looking for and ways to elevate our privileges or exploit our targets.

There are also countless great resources and tools we can use to accomplish these tasks more efficiently.

###### 2.2.4.1. LinEnum
[LinEnum](https://github.com/rebootuser/LinEnum) is an automated information gathering tool.
LinEnum captures what we've covered, and much more.

As we have mentioned, there are plenty of ways of getting the same information, and LinEnum takes care a lot of that process.

###### 2.2.4.2. LinuxPrivChecker
Similarly, [LinuxPrivChecker](https://github.com/sleventyeleven/linuxprivchecker) is another great script we can use for checking for privilege escalation methods.

###### 2.2.4.3. Unix-Privsc-Check
[Unix-privesc-check](http://pentestmonkey.net/tools/audit/unix-privesc-check) is another great script for finding common misconfigurations which can help us elevate our privileges on a Linux-based system.

###### 2.2.4.4. mimipenguin
[mimipenguin](https://github.com/huntergregal/mimipenguin) is a tool we can use for dumping the logon password for the currently logged on user. This should be done during the post-exploitation phase, but let's document it here as well.

###### 2.2.4.5. Additional Resources
The following resources are invaluable when it comes to information gathering and privilege escalation. We suggest you to immerse yourself in these and get familiar with all of the techniques.
- [Local Linux Enumeration & Privilege Escalation Cheatsheet](https://www.rebootuser.com/?p=1623)
- [Basic Linux Privilege Escalation](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/)
- [Local UNIX PrivEsc Aggregation - FuzzySecurity (Kernel Exploits)](https://github.com/FuzzySecurity/Unix-PrivEsc)


## Conclusion
As you navigate through your potential future as a penetration tester, you will see that it is often the small and usually overlooked misconfigurations found early in the stages of information gathering that become the most critical, and not necessarily the complicated exploits or zero-days, which result in reaching your objectives.

Don't leave any stone unturned when it comes to information gathering and enumeration.
