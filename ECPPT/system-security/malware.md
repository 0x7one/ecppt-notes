# [ECPPT](https://members.elearnsecurity.com/courses/penetration_testing_professional_v5)
__________________________
# System Security
# Module 6 - Malware

https://cdn.members.elearnsecurity.com/ptp_v5/section_1/module_6/html/index.html
________________________________________
## 1. Classification
Types of Malware:
- Virus
- Trojan Horse
- Rootkit
- Bootkit
- Backdoor
- Adware
- Spyware
- Greyware
- Dialer
- Key-logger
- Botnet
- Ransomware
- Data-stealing malware
- Worm

________________________________________
#### A. Virus
Computer virus is a computer program that copies itself and spreads without permission or knowledge of the owner.

Virous do not spread via exploiting vulnerabilities (the ones that do that are called worms)

The only way viruses are supposed to spread is with the host - at least in their rigorous classification.

Let us say, that a virus has infected a file; now if the owner moves the file to any system, the virus has thus a chance to spread and survive.

Viruses can be classified into the following sub-types:
- Resident type
  which when executed becomes memory resident (and waits for some triggers such as loading of other program). It then infects other program and so on.
- Non-resident type
  once a virus is executed, it will search for files it can infect. Then after infecting them, it will quit. When the infected program is run again, it will again find new targets and so on.
- Boot-sector virus
  which spreads via boots sectors. For example, if a user leaves a infected CD-ROM while turning off a system, the next time system will boot-up, the boot sector virus will activate and will thus spread to the hard-disk which will then spread it to another disks / flash-drives. When disk / flask-drives disks are moved, the cycle gets repeated.
- Multi-partite type
  The virus has several types of infection mechanisms such as they can have both Boot-sector and resident type virus or even more.
_______________________________________
#### B. Trojan Horse
Trojan horse is a kind of malware that appears to the user to perform a function but in-fact facilitates unauthorized access to the owner's system.

They are not self-repeating like viruses.

_______________________________________
#### C. Rootkit
Rootkit is a malware which is designed to hide the fact that a compromise has already been done or to do the compromise at a deeper level.

A rootkit is basically used as a supplement to other malware.

Basically, rootkits can be used to hide processes, files on the system, implement backdoors and/or create loopholes.

Rootkit exist for all major operating systems such as Windows, Linux, Solaris, OS X, etc.

They are basically installed as drivers (or kernel modules).

Rootkits are known to exits at the following levels (even at lower levels possibly):
- Application level
  They replace actual program with copies of other programs
- Library level
  Let us say that 10 applications are sharing a library, taking control of the library means taking control of all 10 apps
- Kernel level
  This is the most common type and was first developed by Greg Hoglund around 1999 for Windows NT. They are known for their resistance to removal since they run at the same privilege level at which Anti-Virus solutions are run
- Hypervisor level
  These days, processor have come up with support for virtualization. Rootkits which use such processor-specific technologies are called hyper-visor rootkits. E.g., blue-pill and subvirt.
- Firmware level
  Rootkits for firmware such as BIOS, ACPI tables or device ROMSS are known to exist. They have the highest chance of survival because currently, no tools exist to verify/scan up the firmware level rootkits.

_______________________________________
#### D. Bootkit
Bootkits are rootkits which grabs the OS during the boot process itself and were introduces by Nitin Kumar and Vipin Jumar in 2007 (author of this section).

They differ from the rootkits in the installation process and how they take control of the OS.

They start attacking the OS when the OS has not even started, so they are able to completely violate the security of the target OS.

_______________________________________
#### E. Backdoor
Backdoor is a software (or modification to the software) which help in bypassing authentication mechanism, keeping remote access open (for later unauthorized purpose) which trying to remain hidden.

For example, a backdoor in a login system might give you access when a specifies username/password is entered, even though they might not be a valid combination.

_______________________________________
#### F. Adware
Adware is basically advertising supported software which displays ads from time-to-time during the use of the software.

Some adware also act as spyware. Adware also install other unwanted software on the users system which might/might not be malware. This is done without the consent of the user.

_______________________________________
#### G. Spyware
Spyware is a software which keeps on spying the user's activities such as collecting user information, his website visiting record and other information without the consent of the user.

This information is sent to the author after a certain amount has been collected.

They are also called privacy-violating software or privacy-invading software.

Normally, a system which has spyware also has other kinds of malware such as rootkits/trojans to hide the tracks and to keep in control of the machine.


_______________________________________
#### H. Greyware
**Greyware** is a collective name for spyware and adware. A greyware can be either spyware or adware or both.

_______________________________________
#### I. Dialer
Dialer is a software which is used to connect to the internet but instead of using normal numbers, they connect to premium numbers which are charged highly.

Thus the owner  of the dialer who has setup the stuff makes bug sums of money.

_______________________________________
#### J. Key-logger
Key-loggers are malware which log down key pressed by the key owner without their consent. Thus, the person is unaware that his actions are being monitored.

For example, a person might type his credit-card numbers which might them be misused by the keylogger creator.

There are numerous kinds and methods of keylogging such as:
- Software keylogger
  kernel mode or user mode keyloggers
- Hardware keylogger
  firmware-based keylogger can be put in BIOS

  PS/2 and USB keyboards can be sniffed with an additional device placed between the keyboard port and CPU.
- Wireless keyboard sniffer
  Passive sniffers can be used to collect keyboard data in case of wireless keyboards
- Acoustic keylogger
  These kinds of keylogger are based on the sound made when a key is struck by the user

  After sometime of data logging, clear patterns can be distinguished when a key is pressed or released which leads to remote passive keylogging
- Optical keylogger
  Optical keylogging is done by a person standing beside you or by a camera.
_______________________________________
#### K. Botnet
Botnet refers to a collection of compromised computers which run commands automatically and autonomously (with the help of command and control server).

Botnets are typically created when a number of clients install the same malware.

This is usually done via drive-by-downloads (drive-by-download means a compromised website will try to exploit your web browser and install a software without user consent).

The controller or owner of the botnet is called a bot master and is usually the one who gives commands to the bots.

Botnets are used by the botmaster for reasons such as distributed denial of service (DDOS), sending SPAM, etc.

_______________________________________
#### L. Ransomware
This is a software which locks down important files with a password then demands from the user to send money and in return promises to unlock the files.

The most famous example being gpcode which used public-key cryptography to encrypt the user files.

_______________________________________
#### M. Data-stealing malware
Data stealing malware basically steals data such as private encryption keys, credit-card data, competitors data such as internal secret algorithms, new product designs, and other internal data which could be used by the 3rd party to cause damage to the original data owner.

Some of these are highly targeted attacks and are never detected.

_______________________________________
#### N. Worm
Worms are basically software which use network/system vulnerabilities to spread themselves from system to system.

They are typically part of other software such as rootkit and are normally the entry point into the system.

They basically compromise the system (locally or remotely) and then provide access to other software such as bot clients, spyware, key-loggers, and so on.

_______________________________________
## 2. Techniques Used by Malware
The most important covert methods are:
- Streams
- Hooking native APIs/SSDT
- Hooking IRP

Theses topic are highly moving targets with new methods/techniques invented every new months.

_______________________________________
#### 2.1. Streams
Streams are a feature of NTFS file system, they are not available on FAT file systems.

Microsoft calls them Alternate Data Stream.

The original data stream is file dat itself (it is the data stream with no name), all other streams have a name. Alternate data streams can be used to store file metadata / or any other data.

To explain the concept, let us give you a demo. The demo has been tested on Windows XP SP3 (but should work flawlessly on other Windows NT based OS too)

**Example:**
1. Type the following command in the command prompt:
```
echo This data is hidden in the stream. Can you read it?

>> sample.txt:hstream
```

Now you can check the file named `sample.txt`.

You will be surprised to see that the file size is reported as 0 bytes. You can retrieve back your data by using the following command:
```
more < sample.txt:hstream
```

2. Now let us explain how to use the stream programmatically.

In the **CreateFile** API in Windows, just append `:stream_name` to the file name, where `streamname` is the name of the stream.

```
#include <windows.h>
#include <stdio.h>

void main(){
  hStream = CreateFile( "sample.txt:mystream",
    GENERIC_WRITE,
    FILE_SHARE_WRITE,
    NULL,
    OPEN_ALWAYS,
    0,
    NULL);
  if (hStream == INVALID_HANDLE_VALUE)
    printf("Cannot open sample.txt:mystream\n");
  else
    WriteFile(hStream,"This data is hidden in the stream. Can you Read IT ???", 53, &dwRet, NULL);
}

```

_______________________________________
#### 2.2. Hooking Native API/SSDT
**Hooking** means that we want our malicious function to be called instead of the actual function

SSDT stands for System Service Descriptor Table. Native API is API which resides in ntdll.dll and is basically used to communicate with kernel mode.

This communication happen using SSDT table.

For each entry in SSDT table, there is a suitable function in kernel mode which completes the task specified by the API; this representation can be pictured as:

User mode Native API|<===>|SSDT Table|<===>|Kernel Mode
-----|---|---|---|----|

SSDT table resides in the kernel and is exported as **KeServiceDescriptorTable**. The following are the services available for reading/writing file:
- **NtOpenFile**
- **NtCreateFile**
- **NtReadFile**
- **NtWriteFile**
- **NtQueryDictionaryFile** (This is used to query content of the directory)

Microsoft keeps on adding new services on every OS release.

**Example:**
Let us consider the case of a directory query.

For that, we have to hook **NtQueryDictionaryFile**

Steps:
1. Hook SSDT table entry corresponding to  **NtQueryDictionaryFile**
2. Now, whenever the above function is called, your function will be called
3. Right after your function gets called, call original function and get its result (directory listing)
4. If the result was successful, modify the results (hide the file/sub-directory you want to hide)
5. Now pass back the result to the caller
6. You are hidden

This is a very basic method. Nowadays almost all anti-virus / rootkit-detectors scan SSDT table for modifications (they compare it with the copy stored in the kernel) and thus detection can be done.

_______________________________________
#### 2.3. Hooking IRP
Windows architecture in kernel mode introduced the concepts or IRPs (I/O Request Packets) to transmit piece of data from one component to another.

The concept of IRPs is well explained in the Windows Driver Development Kit (it is available for free)

Almost everything in windows kernel use IRPs. For example network interface (TCP/UDP, etc.), file system, keyboard and mouse, and almost all existent drivers.

There are basically 2 ways to play with IRPs:
- Become a filter driver
  Register with the OS as a filter driver or an attached device
- Hooking the function pointer
  the array that can be shown with Winddk (about the function pointer can be modified)

  Code snipper showing function pointer hooking:
  ```
  old_power_irp = DriverObject->MajorFunction[IRP_MJ_OWER];
  DriverObject->MajorFunction[IRP_MJ_OWER] = my_new_irp
  ```

  As you can see, function pointer is one of the easiest method to hook functions.

The basic IRP design is so that after an IRP has been created, it is passed to all the devices registered at lower levels.

The design has pre-processing mode and post-processing mode.

Pre-processing is done when an IRP arrives and post-processing is done when the IRP has been processed by all the levels below the current level.

Each device object has its own function table. Hooking the function pointers of such objects is called DKOM (Direct Kernel Object Manipulation).

All file systems, network layers, devices like keyboard, mouse, etc. have such objects.

For example:
- `\device\tcp`
- `\device\ip`
- `\Device\KeyboardClass0`
- `\FileSystem\ntfs`

Filer drivers are basically used by Anti-viruses to get control whenever a new file is written.

_______________________________________
#### 2.4. Hiding a Process
Hiding a process requires a more difficult approach. It requires a combination of different techniques.

E.g., first thing you have to do is to hook NtOpenProcess native API (probably using SSDT table hooks).

Other things to do is to hide process from EPROCESS list.

This list is maintained by the OS for all active processes.

The EPROCESS list has the following structure:
```
kd> dt _EPROCESS
    +0x000 Pcb                : _KPROCESS
    +0x06C ProcessLock        : _EX_PUSH_LOCK
    +0x070 CreateTime         : _LARGE_INTEGER
    +0x078 ExitTime           : _LARGE_INTEGER
    +0x080 RundownProtect     : _EX_RUNDOWN_REF
    +0x084 UniqueProcessId    : Ptr32 Void
    +0x088 ActiveProcessLinks : _LIST_ENTRY
    +0x090 QuotaUsage         : [3] Uint48
    ...
    +0x0C4 ObjectTable        : Ptr32 _HANDLE_TABLE
    +0x0C8 Token              : _EX_FAST_REF
    ...
    +0x174 ImageFileName      : [16] Uchar

```

Note : UniqueProcessId, ActiveProcessLinks, Token, and ImageFileName are normally most used

As you can see in the above  structure, **ActiveProcessLinks** is the circular doubly linked list with \*FLINK and \*BLINK as pointers to other structures.

The easiest thing to do is to unlink the structure relative to our process from the list (Refer to Module 3 for more information on this list).

If the driver is loaded, you will also have to unlink it form the **PsLoadedModuleList**.

API hooking is essentially the act of intercepting an APIP function call, and modifying its functionality somehow, either by redirecting it to a function of our choice, stopping the function from being called, or logging the request - the possibilities are endless.

_______________________________________
#### 2.5. API Hooking



_______________________________________
#### 2.6. Anti-Debugging Methods



_______________________________________
#### 2.7. Anti-Virtual Machine



_______________________________________
#### 2.8. Obfuscation



_______________________________________
#### 2.9. Packets



_______________________________________
#### 2.10. Polymorphism



_______________________________________
#### 2.11. Metamorphism



_______________________________________
## 3. How Malware Spreads


_______________________________________
## 4. Samples

_______________________________________
